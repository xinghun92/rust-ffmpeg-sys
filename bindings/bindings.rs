/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = index % 8;
        let mask = 1 << bit_index;

        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                val |= 1 << i;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            self.set_bit(i + bit_offset, val_bit_is_set);
        }
    }
}
pub const __DARWIN_ONLY_64_BIT_INO_T: libc::c_int = 0;
pub const __DARWIN_ONLY_VERS_1050: libc::c_int = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: libc::c_int = 1;
pub const __DARWIN_UNIX03: libc::c_int = 1;
pub const __DARWIN_64_BIT_INO_T: libc::c_int = 0;
pub const __DARWIN_VERS_1050: libc::c_int = 0;
pub const __DARWIN_NON_CANCELABLE: libc::c_int = 0;
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: libc::c_int = 4096;
pub const __DARWIN_C_FULL: libc::c_int = 900000;
pub const __DARWIN_C_LEVEL: libc::c_int = 900000;
pub const __STDC_WANT_LIB_EXT1__: libc::c_int = 1;
pub const __DARWIN_NO_LONG_LONG: libc::c_int = 0;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: libc::c_int = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: libc::c_int = 3;
pub const EPERM: libc::c_int = 1;
pub const ENOENT: libc::c_int = 2;
pub const ESRCH: libc::c_int = 3;
pub const EINTR: libc::c_int = 4;
pub const EIO: libc::c_int = 5;
pub const ENXIO: libc::c_int = 6;
pub const E2BIG: libc::c_int = 7;
pub const ENOEXEC: libc::c_int = 8;
pub const EBADF: libc::c_int = 9;
pub const ECHILD: libc::c_int = 10;
pub const EDEADLK: libc::c_int = 11;
pub const ENOMEM: libc::c_int = 12;
pub const EACCES: libc::c_int = 13;
pub const EFAULT: libc::c_int = 14;
pub const ENOTBLK: libc::c_int = 15;
pub const EBUSY: libc::c_int = 16;
pub const EEXIST: libc::c_int = 17;
pub const EXDEV: libc::c_int = 18;
pub const ENODEV: libc::c_int = 19;
pub const ENOTDIR: libc::c_int = 20;
pub const EISDIR: libc::c_int = 21;
pub const EINVAL: libc::c_int = 22;
pub const ENFILE: libc::c_int = 23;
pub const EMFILE: libc::c_int = 24;
pub const ENOTTY: libc::c_int = 25;
pub const ETXTBSY: libc::c_int = 26;
pub const EFBIG: libc::c_int = 27;
pub const ENOSPC: libc::c_int = 28;
pub const ESPIPE: libc::c_int = 29;
pub const EROFS: libc::c_int = 30;
pub const EMLINK: libc::c_int = 31;
pub const EPIPE: libc::c_int = 32;
pub const EDOM: libc::c_int = 33;
pub const ERANGE: libc::c_int = 34;
pub const EAGAIN: libc::c_int = 35;
pub const EWOULDBLOCK: libc::c_int = 35;
pub const EINPROGRESS: libc::c_int = 36;
pub const EALREADY: libc::c_int = 37;
pub const ENOTSOCK: libc::c_int = 38;
pub const EDESTADDRREQ: libc::c_int = 39;
pub const EMSGSIZE: libc::c_int = 40;
pub const EPROTOTYPE: libc::c_int = 41;
pub const ENOPROTOOPT: libc::c_int = 42;
pub const EPROTONOSUPPORT: libc::c_int = 43;
pub const ESOCKTNOSUPPORT: libc::c_int = 44;
pub const ENOTSUP: libc::c_int = 45;
pub const EPFNOSUPPORT: libc::c_int = 46;
pub const EAFNOSUPPORT: libc::c_int = 47;
pub const EADDRINUSE: libc::c_int = 48;
pub const EADDRNOTAVAIL: libc::c_int = 49;
pub const ENETDOWN: libc::c_int = 50;
pub const ENETUNREACH: libc::c_int = 51;
pub const ENETRESET: libc::c_int = 52;
pub const ECONNABORTED: libc::c_int = 53;
pub const ECONNRESET: libc::c_int = 54;
pub const ENOBUFS: libc::c_int = 55;
pub const EISCONN: libc::c_int = 56;
pub const ENOTCONN: libc::c_int = 57;
pub const ESHUTDOWN: libc::c_int = 58;
pub const ETOOMANYREFS: libc::c_int = 59;
pub const ETIMEDOUT: libc::c_int = 60;
pub const ECONNREFUSED: libc::c_int = 61;
pub const ELOOP: libc::c_int = 62;
pub const ENAMETOOLONG: libc::c_int = 63;
pub const EHOSTDOWN: libc::c_int = 64;
pub const EHOSTUNREACH: libc::c_int = 65;
pub const ENOTEMPTY: libc::c_int = 66;
pub const EPROCLIM: libc::c_int = 67;
pub const EUSERS: libc::c_int = 68;
pub const EDQUOT: libc::c_int = 69;
pub const ESTALE: libc::c_int = 70;
pub const EREMOTE: libc::c_int = 71;
pub const EBADRPC: libc::c_int = 72;
pub const ERPCMISMATCH: libc::c_int = 73;
pub const EPROGUNAVAIL: libc::c_int = 74;
pub const EPROGMISMATCH: libc::c_int = 75;
pub const EPROCUNAVAIL: libc::c_int = 76;
pub const ENOLCK: libc::c_int = 77;
pub const ENOSYS: libc::c_int = 78;
pub const EFTYPE: libc::c_int = 79;
pub const EAUTH: libc::c_int = 80;
pub const ENEEDAUTH: libc::c_int = 81;
pub const EPWROFF: libc::c_int = 82;
pub const EDEVERR: libc::c_int = 83;
pub const EOVERFLOW: libc::c_int = 84;
pub const EBADEXEC: libc::c_int = 85;
pub const EBADARCH: libc::c_int = 86;
pub const ESHLIBVERS: libc::c_int = 87;
pub const EBADMACHO: libc::c_int = 88;
pub const ECANCELED: libc::c_int = 89;
pub const EIDRM: libc::c_int = 90;
pub const ENOMSG: libc::c_int = 91;
pub const EILSEQ: libc::c_int = 92;
pub const ENOATTR: libc::c_int = 93;
pub const EBADMSG: libc::c_int = 94;
pub const EMULTIHOP: libc::c_int = 95;
pub const ENODATA: libc::c_int = 96;
pub const ENOLINK: libc::c_int = 97;
pub const ENOSR: libc::c_int = 98;
pub const ENOSTR: libc::c_int = 99;
pub const EPROTO: libc::c_int = 100;
pub const ETIME: libc::c_int = 101;
pub const EOPNOTSUPP: libc::c_int = 102;
pub const ENOPOLICY: libc::c_int = 103;
pub const ENOTRECOVERABLE: libc::c_int = 104;
pub const EOWNERDEAD: libc::c_int = 105;
pub const EQFULL: libc::c_int = 106;
pub const ELAST: libc::c_int = 106;
pub const __WORDSIZE: libc::c_int = 64;
pub const __PTHREAD_SIZE__: libc::c_int = 8176;
pub const __PTHREAD_ATTR_SIZE__: libc::c_int = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: libc::c_int = 8;
pub const __PTHREAD_MUTEX_SIZE__: libc::c_int = 56;
pub const __PTHREAD_CONDATTR_SIZE__: libc::c_int = 8;
pub const __PTHREAD_COND_SIZE__: libc::c_int = 40;
pub const __PTHREAD_ONCE_SIZE__: libc::c_int = 8;
pub const __PTHREAD_RWLOCK_SIZE__: libc::c_int = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: libc::c_int = 16;
pub const INT8_MAX: libc::c_int = 127;
pub const INT16_MAX: libc::c_int = 32767;
pub const INT32_MAX: libc::c_int = 2147483647;
pub const INT64_MAX: libc::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: libc::c_int = -128;
pub const INT16_MIN: libc::c_int = -32768;
pub const INT32_MIN: libc::c_int = -2147483648;
pub const INT64_MIN: libc::c_longlong = -9223372036854775808;
pub const UINT8_MAX: libc::c_int = 255;
pub const UINT16_MAX: libc::c_int = 65535;
pub const UINT32_MAX: libc::c_uint = 4294967295;
pub const UINT64_MAX: libc::c_int = -1;
pub const INT_LEAST8_MIN: libc::c_int = -128;
pub const INT_LEAST16_MIN: libc::c_int = -32768;
pub const INT_LEAST32_MIN: libc::c_int = -2147483648;
pub const INT_LEAST64_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: libc::c_int = 127;
pub const INT_LEAST16_MAX: libc::c_int = 32767;
pub const INT_LEAST32_MAX: libc::c_int = 2147483647;
pub const INT_LEAST64_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: libc::c_int = 255;
pub const UINT_LEAST16_MAX: libc::c_int = 65535;
pub const UINT_LEAST32_MAX: libc::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: libc::c_int = -1;
pub const INT_FAST8_MIN: libc::c_int = -128;
pub const INT_FAST16_MIN: libc::c_int = -32768;
pub const INT_FAST32_MIN: libc::c_int = -2147483648;
pub const INT_FAST64_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: libc::c_int = 127;
pub const INT_FAST16_MAX: libc::c_int = 32767;
pub const INT_FAST32_MAX: libc::c_int = 2147483647;
pub const INT_FAST64_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: libc::c_int = 255;
pub const UINT_FAST16_MAX: libc::c_int = 65535;
pub const UINT_FAST32_MAX: libc::c_uint = 4294967295;
pub const UINT_FAST64_MAX: libc::c_int = -1;
pub const INTPTR_MAX: libc::c_ulonglong = 9223372036854775807;
pub const INTPTR_MIN: libc::c_longlong = -9223372036854775808;
pub const UINTPTR_MAX: libc::c_int = -1;
pub const INTMAX_MIN: libc::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: libc::c_int = -1;
pub const PTRDIFF_MIN: libc::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: libc::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: libc::c_int = -1;
pub const RSIZE_MAX: libc::c_int = -1;
pub const WINT_MIN: libc::c_int = -2147483648;
pub const WINT_MAX: libc::c_int = 2147483647;
pub const SIG_ATOMIC_MIN: libc::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: libc::c_int = 2147483647;
pub const FF_LAMBDA_SHIFT: libc::c_int = 7;
pub const FF_LAMBDA_SCALE: libc::c_int = 128;
pub const FF_QP2LAMBDA: libc::c_int = 118;
pub const FF_LAMBDA_MAX: libc::c_int = 32767;
pub const FF_QUALITY_SCALE: libc::c_int = 128;
pub const AV_TIME_BASE: libc::c_int = 1000000;
pub const __PRI_8_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &'static [u8; 3usize] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &'static [u8; 2usize] = b"j\0";
pub const PRId8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIi8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIo8: &'static [u8; 4usize] = b"hho\0";
pub const PRIu8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIx8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIX8: &'static [u8; 4usize] = b"hhX\0";
pub const PRId16: &'static [u8; 3usize] = b"hd\0";
pub const PRIi16: &'static [u8; 3usize] = b"hi\0";
pub const PRIo16: &'static [u8; 3usize] = b"ho\0";
pub const PRIu16: &'static [u8; 3usize] = b"hu\0";
pub const PRIx16: &'static [u8; 3usize] = b"hx\0";
pub const PRIX16: &'static [u8; 3usize] = b"hX\0";
pub const PRId32: &'static [u8; 2usize] = b"d\0";
pub const PRIi32: &'static [u8; 2usize] = b"i\0";
pub const PRIo32: &'static [u8; 2usize] = b"o\0";
pub const PRIu32: &'static [u8; 2usize] = b"u\0";
pub const PRIx32: &'static [u8; 2usize] = b"x\0";
pub const PRIX32: &'static [u8; 2usize] = b"X\0";
pub const PRId64: &'static [u8; 4usize] = b"lld\0";
pub const PRIi64: &'static [u8; 4usize] = b"lli\0";
pub const PRIo64: &'static [u8; 4usize] = b"llo\0";
pub const PRIu64: &'static [u8; 4usize] = b"llu\0";
pub const PRIx64: &'static [u8; 4usize] = b"llx\0";
pub const PRIX64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIXLEAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIXLEAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIXLEAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIXLEAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const PRIiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const PRIoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const PRIuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const PRIxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const PRIXFAST8: &'static [u8; 4usize] = b"hhX\0";
pub const PRIdFAST16: &'static [u8; 3usize] = b"hd\0";
pub const PRIiFAST16: &'static [u8; 3usize] = b"hi\0";
pub const PRIoFAST16: &'static [u8; 3usize] = b"ho\0";
pub const PRIuFAST16: &'static [u8; 3usize] = b"hu\0";
pub const PRIxFAST16: &'static [u8; 3usize] = b"hx\0";
pub const PRIXFAST16: &'static [u8; 3usize] = b"hX\0";
pub const PRIdFAST32: &'static [u8; 2usize] = b"d\0";
pub const PRIiFAST32: &'static [u8; 2usize] = b"i\0";
pub const PRIoFAST32: &'static [u8; 2usize] = b"o\0";
pub const PRIuFAST32: &'static [u8; 2usize] = b"u\0";
pub const PRIxFAST32: &'static [u8; 2usize] = b"x\0";
pub const PRIXFAST32: &'static [u8; 2usize] = b"X\0";
pub const PRIdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const PRIiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const PRIoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const PRIuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const PRIxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const PRIXFAST64: &'static [u8; 4usize] = b"llX\0";
pub const PRIdPTR: &'static [u8; 3usize] = b"ld\0";
pub const PRIiPTR: &'static [u8; 3usize] = b"li\0";
pub const PRIoPTR: &'static [u8; 3usize] = b"lo\0";
pub const PRIuPTR: &'static [u8; 3usize] = b"lu\0";
pub const PRIxPTR: &'static [u8; 3usize] = b"lx\0";
pub const PRIXPTR: &'static [u8; 3usize] = b"lX\0";
pub const PRIdMAX: &'static [u8; 3usize] = b"jd\0";
pub const PRIiMAX: &'static [u8; 3usize] = b"ji\0";
pub const PRIoMAX: &'static [u8; 3usize] = b"jo\0";
pub const PRIuMAX: &'static [u8; 3usize] = b"ju\0";
pub const PRIxMAX: &'static [u8; 3usize] = b"jx\0";
pub const PRIXMAX: &'static [u8; 3usize] = b"jX\0";
pub const SCNd8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNi8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNo8: &'static [u8; 4usize] = b"hho\0";
pub const SCNu8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNx8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNd16: &'static [u8; 3usize] = b"hd\0";
pub const SCNi16: &'static [u8; 3usize] = b"hi\0";
pub const SCNo16: &'static [u8; 3usize] = b"ho\0";
pub const SCNu16: &'static [u8; 3usize] = b"hu\0";
pub const SCNx16: &'static [u8; 3usize] = b"hx\0";
pub const SCNd32: &'static [u8; 2usize] = b"d\0";
pub const SCNi32: &'static [u8; 2usize] = b"i\0";
pub const SCNo32: &'static [u8; 2usize] = b"o\0";
pub const SCNu32: &'static [u8; 2usize] = b"u\0";
pub const SCNx32: &'static [u8; 2usize] = b"x\0";
pub const SCNd64: &'static [u8; 4usize] = b"lld\0";
pub const SCNi64: &'static [u8; 4usize] = b"lli\0";
pub const SCNo64: &'static [u8; 4usize] = b"llo\0";
pub const SCNu64: &'static [u8; 4usize] = b"llu\0";
pub const SCNx64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdLEAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNiLEAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNoLEAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNuLEAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNxLEAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNdLEAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNiLEAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNoLEAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNuLEAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNxLEAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNdLEAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNiLEAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNoLEAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNuLEAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNxLEAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNdLEAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNiLEAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNoLEAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNuLEAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNxLEAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdFAST8: &'static [u8; 4usize] = b"hhd\0";
pub const SCNiFAST8: &'static [u8; 4usize] = b"hhi\0";
pub const SCNoFAST8: &'static [u8; 4usize] = b"hho\0";
pub const SCNuFAST8: &'static [u8; 4usize] = b"hhu\0";
pub const SCNxFAST8: &'static [u8; 4usize] = b"hhx\0";
pub const SCNdFAST16: &'static [u8; 3usize] = b"hd\0";
pub const SCNiFAST16: &'static [u8; 3usize] = b"hi\0";
pub const SCNoFAST16: &'static [u8; 3usize] = b"ho\0";
pub const SCNuFAST16: &'static [u8; 3usize] = b"hu\0";
pub const SCNxFAST16: &'static [u8; 3usize] = b"hx\0";
pub const SCNdFAST32: &'static [u8; 2usize] = b"d\0";
pub const SCNiFAST32: &'static [u8; 2usize] = b"i\0";
pub const SCNoFAST32: &'static [u8; 2usize] = b"o\0";
pub const SCNuFAST32: &'static [u8; 2usize] = b"u\0";
pub const SCNxFAST32: &'static [u8; 2usize] = b"x\0";
pub const SCNdFAST64: &'static [u8; 4usize] = b"lld\0";
pub const SCNiFAST64: &'static [u8; 4usize] = b"lli\0";
pub const SCNoFAST64: &'static [u8; 4usize] = b"llo\0";
pub const SCNuFAST64: &'static [u8; 4usize] = b"llu\0";
pub const SCNxFAST64: &'static [u8; 4usize] = b"llx\0";
pub const SCNdPTR: &'static [u8; 3usize] = b"ld\0";
pub const SCNiPTR: &'static [u8; 3usize] = b"li\0";
pub const SCNoPTR: &'static [u8; 3usize] = b"lo\0";
pub const SCNuPTR: &'static [u8; 3usize] = b"lu\0";
pub const SCNxPTR: &'static [u8; 3usize] = b"lx\0";
pub const SCNdMAX: &'static [u8; 3usize] = b"jd\0";
pub const SCNiMAX: &'static [u8; 3usize] = b"ji\0";
pub const SCNoMAX: &'static [u8; 3usize] = b"jo\0";
pub const SCNuMAX: &'static [u8; 3usize] = b"ju\0";
pub const SCNxMAX: &'static [u8; 3usize] = b"jx\0";
pub const __MAC_10_0: libc::c_int = 1000;
pub const __MAC_10_1: libc::c_int = 1010;
pub const __MAC_10_2: libc::c_int = 1020;
pub const __MAC_10_3: libc::c_int = 1030;
pub const __MAC_10_4: libc::c_int = 1040;
pub const __MAC_10_5: libc::c_int = 1050;
pub const __MAC_10_6: libc::c_int = 1060;
pub const __MAC_10_7: libc::c_int = 1070;
pub const __MAC_10_8: libc::c_int = 1080;
pub const __MAC_10_9: libc::c_int = 1090;
pub const __MAC_10_10: libc::c_int = 101000;
pub const __MAC_10_10_2: libc::c_int = 101002;
pub const __MAC_10_10_3: libc::c_int = 101003;
pub const __MAC_10_11: libc::c_int = 101100;
pub const __MAC_10_11_2: libc::c_int = 101102;
pub const __MAC_10_11_3: libc::c_int = 101103;
pub const __MAC_10_11_4: libc::c_int = 101104;
pub const __MAC_10_12: libc::c_int = 101200;
pub const __MAC_10_12_1: libc::c_int = 101201;
pub const __MAC_10_12_2: libc::c_int = 101202;
pub const __MAC_10_12_4: libc::c_int = 101204;
pub const __MAC_10_13: libc::c_int = 101300;
pub const __MAC_10_13_1: libc::c_int = 101301;
pub const __MAC_10_13_2: libc::c_int = 101302;
pub const __MAC_10_13_4: libc::c_int = 101304;
pub const __IPHONE_2_0: libc::c_int = 20000;
pub const __IPHONE_2_1: libc::c_int = 20100;
pub const __IPHONE_2_2: libc::c_int = 20200;
pub const __IPHONE_3_0: libc::c_int = 30000;
pub const __IPHONE_3_1: libc::c_int = 30100;
pub const __IPHONE_3_2: libc::c_int = 30200;
pub const __IPHONE_4_0: libc::c_int = 40000;
pub const __IPHONE_4_1: libc::c_int = 40100;
pub const __IPHONE_4_2: libc::c_int = 40200;
pub const __IPHONE_4_3: libc::c_int = 40300;
pub const __IPHONE_5_0: libc::c_int = 50000;
pub const __IPHONE_5_1: libc::c_int = 50100;
pub const __IPHONE_6_0: libc::c_int = 60000;
pub const __IPHONE_6_1: libc::c_int = 60100;
pub const __IPHONE_7_0: libc::c_int = 70000;
pub const __IPHONE_7_1: libc::c_int = 70100;
pub const __IPHONE_8_0: libc::c_int = 80000;
pub const __IPHONE_8_1: libc::c_int = 80100;
pub const __IPHONE_8_2: libc::c_int = 80200;
pub const __IPHONE_8_3: libc::c_int = 80300;
pub const __IPHONE_8_4: libc::c_int = 80400;
pub const __IPHONE_9_0: libc::c_int = 90000;
pub const __IPHONE_9_1: libc::c_int = 90100;
pub const __IPHONE_9_2: libc::c_int = 90200;
pub const __IPHONE_9_3: libc::c_int = 90300;
pub const __IPHONE_10_0: libc::c_int = 100000;
pub const __IPHONE_10_1: libc::c_int = 100100;
pub const __IPHONE_10_2: libc::c_int = 100200;
pub const __IPHONE_10_3: libc::c_int = 100300;
pub const __IPHONE_11_0: libc::c_int = 110000;
pub const __IPHONE_11_1: libc::c_int = 110100;
pub const __IPHONE_11_2: libc::c_int = 110200;
pub const __IPHONE_11_3: libc::c_int = 110300;
pub const __TVOS_9_0: libc::c_int = 90000;
pub const __TVOS_9_1: libc::c_int = 90100;
pub const __TVOS_9_2: libc::c_int = 90200;
pub const __TVOS_10_0: libc::c_int = 100000;
pub const __TVOS_10_0_1: libc::c_int = 100001;
pub const __TVOS_10_1: libc::c_int = 100100;
pub const __TVOS_10_2: libc::c_int = 100200;
pub const __TVOS_11_0: libc::c_int = 110000;
pub const __TVOS_11_1: libc::c_int = 110100;
pub const __TVOS_11_2: libc::c_int = 110200;
pub const __TVOS_11_3: libc::c_int = 110300;
pub const __WATCHOS_1_0: libc::c_int = 10000;
pub const __WATCHOS_2_0: libc::c_int = 20000;
pub const __WATCHOS_2_1: libc::c_int = 20100;
pub const __WATCHOS_2_2: libc::c_int = 20200;
pub const __WATCHOS_3_0: libc::c_int = 30000;
pub const __WATCHOS_3_1: libc::c_int = 30100;
pub const __WATCHOS_3_1_1: libc::c_int = 30101;
pub const __WATCHOS_3_2: libc::c_int = 30200;
pub const __WATCHOS_4_0: libc::c_int = 40000;
pub const __WATCHOS_4_1: libc::c_int = 40100;
pub const __WATCHOS_4_2: libc::c_int = 40200;
pub const __WATCHOS_4_3: libc::c_int = 40300;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: libc::c_int = 101304;
pub const __DARWIN_WCHAR_MIN: libc::c_int = -2147483648;
pub const _FORTIFY_SOURCE: libc::c_int = 0;
pub const __DARWIN_CLK_TCK: libc::c_int = 100;
pub const CHAR_BIT: libc::c_int = 8;
pub const MB_LEN_MAX: libc::c_int = 6;
pub const CLK_TCK: libc::c_int = 100;
pub const SCHAR_MAX: libc::c_int = 127;
pub const SCHAR_MIN: libc::c_int = -128;
pub const UCHAR_MAX: libc::c_int = 255;
pub const CHAR_MAX: libc::c_int = 127;
pub const CHAR_MIN: libc::c_int = -128;
pub const USHRT_MAX: libc::c_int = 65535;
pub const SHRT_MAX: libc::c_int = 32767;
pub const SHRT_MIN: libc::c_int = -32768;
pub const UINT_MAX: libc::c_uint = 4294967295;
pub const INT_MAX: libc::c_int = 2147483647;
pub const INT_MIN: libc::c_int = -2147483648;
pub const ULONG_MAX: libc::c_int = -1;
pub const LONG_MAX: libc::c_ulonglong = 9223372036854775807;
pub const LONG_MIN: libc::c_longlong = -9223372036854775808;
pub const ULLONG_MAX: libc::c_int = -1;
pub const LLONG_MAX: libc::c_ulonglong = 9223372036854775807;
pub const LLONG_MIN: libc::c_longlong = -9223372036854775808;
pub const LONG_BIT: libc::c_int = 64;
pub const SSIZE_MAX: libc::c_ulonglong = 9223372036854775807;
pub const WORD_BIT: libc::c_int = 32;
pub const SIZE_T_MAX: libc::c_int = -1;
pub const UQUAD_MAX: libc::c_int = -1;
pub const QUAD_MAX: libc::c_ulonglong = 9223372036854775807;
pub const QUAD_MIN: libc::c_longlong = -9223372036854775808;
pub const ARG_MAX: libc::c_int = 262144;
pub const CHILD_MAX: libc::c_int = 266;
pub const GID_MAX: libc::c_int = 2147483647;
pub const LINK_MAX: libc::c_int = 32767;
pub const MAX_CANON: libc::c_int = 1024;
pub const MAX_INPUT: libc::c_int = 1024;
pub const NAME_MAX: libc::c_int = 255;
pub const NGROUPS_MAX: libc::c_int = 16;
pub const UID_MAX: libc::c_int = 2147483647;
pub const OPEN_MAX: libc::c_int = 10240;
pub const PATH_MAX: libc::c_int = 1024;
pub const PIPE_BUF: libc::c_int = 512;
pub const BC_BASE_MAX: libc::c_int = 99;
pub const BC_DIM_MAX: libc::c_int = 2048;
pub const BC_SCALE_MAX: libc::c_int = 99;
pub const BC_STRING_MAX: libc::c_int = 1000;
pub const CHARCLASS_NAME_MAX: libc::c_int = 14;
pub const COLL_WEIGHTS_MAX: libc::c_int = 2;
pub const EQUIV_CLASS_MAX: libc::c_int = 2;
pub const EXPR_NEST_MAX: libc::c_int = 32;
pub const LINE_MAX: libc::c_int = 2048;
pub const RE_DUP_MAX: libc::c_int = 255;
pub const NZERO: libc::c_int = 20;
pub const _POSIX_ARG_MAX: libc::c_int = 4096;
pub const _POSIX_CHILD_MAX: libc::c_int = 25;
pub const _POSIX_LINK_MAX: libc::c_int = 8;
pub const _POSIX_MAX_CANON: libc::c_int = 255;
pub const _POSIX_MAX_INPUT: libc::c_int = 255;
pub const _POSIX_NAME_MAX: libc::c_int = 14;
pub const _POSIX_NGROUPS_MAX: libc::c_int = 8;
pub const _POSIX_OPEN_MAX: libc::c_int = 20;
pub const _POSIX_PATH_MAX: libc::c_int = 256;
pub const _POSIX_PIPE_BUF: libc::c_int = 512;
pub const _POSIX_SSIZE_MAX: libc::c_int = 32767;
pub const _POSIX_STREAM_MAX: libc::c_int = 8;
pub const _POSIX_TZNAME_MAX: libc::c_int = 6;
pub const _POSIX2_BC_BASE_MAX: libc::c_int = 99;
pub const _POSIX2_BC_DIM_MAX: libc::c_int = 2048;
pub const _POSIX2_BC_SCALE_MAX: libc::c_int = 99;
pub const _POSIX2_BC_STRING_MAX: libc::c_int = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: libc::c_int = 2;
pub const _POSIX2_EXPR_NEST_MAX: libc::c_int = 32;
pub const _POSIX2_LINE_MAX: libc::c_int = 2048;
pub const _POSIX2_RE_DUP_MAX: libc::c_int = 255;
pub const _POSIX_AIO_LISTIO_MAX: libc::c_int = 2;
pub const _POSIX_AIO_MAX: libc::c_int = 1;
pub const _POSIX_DELAYTIMER_MAX: libc::c_int = 32;
pub const _POSIX_MQ_OPEN_MAX: libc::c_int = 8;
pub const _POSIX_MQ_PRIO_MAX: libc::c_int = 32;
pub const _POSIX_RTSIG_MAX: libc::c_int = 8;
pub const _POSIX_SEM_NSEMS_MAX: libc::c_int = 256;
pub const _POSIX_SEM_VALUE_MAX: libc::c_int = 32767;
pub const _POSIX_SIGQUEUE_MAX: libc::c_int = 32;
pub const _POSIX_TIMER_MAX: libc::c_int = 32;
pub const _POSIX_CLOCKRES_MIN: libc::c_int = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: libc::c_int = 4;
pub const _POSIX_THREAD_KEYS_MAX: libc::c_int = 128;
pub const _POSIX_THREAD_THREADS_MAX: libc::c_int = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: libc::c_int = 4;
pub const PTHREAD_KEYS_MAX: libc::c_int = 512;
pub const PTHREAD_STACK_MIN: libc::c_int = 8192;
pub const _POSIX_HOST_NAME_MAX: libc::c_int = 255;
pub const _POSIX_LOGIN_NAME_MAX: libc::c_int = 9;
pub const _POSIX_SS_REPL_MAX: libc::c_int = 4;
pub const _POSIX_SYMLINK_MAX: libc::c_int = 255;
pub const _POSIX_SYMLOOP_MAX: libc::c_int = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: libc::c_int = 30;
pub const _POSIX_TRACE_NAME_MAX: libc::c_int = 8;
pub const _POSIX_TRACE_SYS_MAX: libc::c_int = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: libc::c_int = 32;
pub const _POSIX_TTY_NAME_MAX: libc::c_int = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: libc::c_int = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: libc::c_int = 2;
pub const _POSIX_RE_DUP_MAX: libc::c_int = 255;
pub const OFF_MIN: libc::c_longlong = -9223372036854775808;
pub const OFF_MAX: libc::c_ulonglong = 9223372036854775807;
pub const PASS_MAX: libc::c_int = 128;
pub const NL_ARGMAX: libc::c_int = 9;
pub const NL_LANGMAX: libc::c_int = 14;
pub const NL_MSGMAX: libc::c_int = 32767;
pub const NL_NMAX: libc::c_int = 1;
pub const NL_SETMAX: libc::c_int = 255;
pub const NL_TEXTMAX: libc::c_int = 2048;
pub const _XOPEN_IOV_MAX: libc::c_int = 16;
pub const IOV_MAX: libc::c_int = 1024;
pub const _XOPEN_NAME_MAX: libc::c_int = 255;
pub const _XOPEN_PATH_MAX: libc::c_int = 1024;
pub const FP_SUPERNORMAL: libc::c_int = 6;
pub const FP_ILOGB0: libc::c_int = -2147483648;
pub const FP_ILOGBNAN: libc::c_int = -2147483648;
pub const MATH_ERRNO: libc::c_int = 1;
pub const MATH_ERREXCEPT: libc::c_int = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: libc::c_int = 1;
pub const FP_QNAN: libc::c_int = 1;
pub const DOMAIN: libc::c_int = 1;
pub const SING: libc::c_int = 2;
pub const OVERFLOW: libc::c_int = 3;
pub const UNDERFLOW: libc::c_int = 4;
pub const TLOSS: libc::c_int = 5;
pub const PLOSS: libc::c_int = 6;
pub const RENAME_SECLUDE: libc::c_int = 1;
pub const RENAME_SWAP: libc::c_int = 2;
pub const RENAME_EXCL: libc::c_int = 4;
pub const __SLBF: libc::c_int = 1;
pub const __SNBF: libc::c_int = 2;
pub const __SRD: libc::c_int = 4;
pub const __SWR: libc::c_int = 8;
pub const __SRW: libc::c_int = 16;
pub const __SEOF: libc::c_int = 32;
pub const __SERR: libc::c_int = 64;
pub const __SMBF: libc::c_int = 128;
pub const __SAPP: libc::c_int = 256;
pub const __SSTR: libc::c_int = 512;
pub const __SOPT: libc::c_int = 1024;
pub const __SNPT: libc::c_int = 2048;
pub const __SOFF: libc::c_int = 4096;
pub const __SMOD: libc::c_int = 8192;
pub const __SALC: libc::c_int = 16384;
pub const __SIGN: libc::c_int = 32768;
pub const _IOFBF: libc::c_int = 0;
pub const _IOLBF: libc::c_int = 1;
pub const _IONBF: libc::c_int = 2;
pub const BUFSIZ: libc::c_int = 1024;
pub const EOF: libc::c_int = -1;
pub const FOPEN_MAX: libc::c_int = 20;
pub const FILENAME_MAX: libc::c_int = 1024;
pub const P_tmpdir: &'static [u8; 10usize] = b"/var/tmp/\0";
pub const L_tmpnam: libc::c_int = 1024;
pub const TMP_MAX: libc::c_int = 308915776;
pub const SEEK_SET: libc::c_int = 0;
pub const SEEK_CUR: libc::c_int = 1;
pub const SEEK_END: libc::c_int = 2;
pub const L_ctermid: libc::c_int = 1024;
pub const __CTERMID_DEFINED: libc::c_int = 1;
pub const __DARWIN_NSIG: libc::c_int = 32;
pub const NSIG: libc::c_int = 32;
pub const _I386_SIGNAL_H_: libc::c_int = 1;
pub const SIGHUP: libc::c_int = 1;
pub const SIGINT: libc::c_int = 2;
pub const SIGQUIT: libc::c_int = 3;
pub const SIGILL: libc::c_int = 4;
pub const SIGTRAP: libc::c_int = 5;
pub const SIGABRT: libc::c_int = 6;
pub const SIGIOT: libc::c_int = 6;
pub const SIGEMT: libc::c_int = 7;
pub const SIGFPE: libc::c_int = 8;
pub const SIGKILL: libc::c_int = 9;
pub const SIGBUS: libc::c_int = 10;
pub const SIGSEGV: libc::c_int = 11;
pub const SIGSYS: libc::c_int = 12;
pub const SIGPIPE: libc::c_int = 13;
pub const SIGALRM: libc::c_int = 14;
pub const SIGTERM: libc::c_int = 15;
pub const SIGURG: libc::c_int = 16;
pub const SIGSTOP: libc::c_int = 17;
pub const SIGTSTP: libc::c_int = 18;
pub const SIGCONT: libc::c_int = 19;
pub const SIGCHLD: libc::c_int = 20;
pub const SIGTTIN: libc::c_int = 21;
pub const SIGTTOU: libc::c_int = 22;
pub const SIGIO: libc::c_int = 23;
pub const SIGXCPU: libc::c_int = 24;
pub const SIGXFSZ: libc::c_int = 25;
pub const SIGVTALRM: libc::c_int = 26;
pub const SIGPROF: libc::c_int = 27;
pub const SIGWINCH: libc::c_int = 28;
pub const SIGINFO: libc::c_int = 29;
pub const SIGUSR1: libc::c_int = 30;
pub const SIGUSR2: libc::c_int = 31;
pub const FP_PREC_24B: libc::c_int = 0;
pub const FP_PREC_53B: libc::c_int = 2;
pub const FP_PREC_64B: libc::c_int = 3;
pub const FP_RND_NEAR: libc::c_int = 0;
pub const FP_RND_DOWN: libc::c_int = 1;
pub const FP_RND_UP: libc::c_int = 2;
pub const FP_CHOP: libc::c_int = 3;
pub const FP_STATE_BYTES: libc::c_int = 512;
pub const SIGEV_NONE: libc::c_int = 0;
pub const SIGEV_SIGNAL: libc::c_int = 1;
pub const SIGEV_THREAD: libc::c_int = 3;
pub const ILL_NOOP: libc::c_int = 0;
pub const ILL_ILLOPC: libc::c_int = 1;
pub const ILL_ILLTRP: libc::c_int = 2;
pub const ILL_PRVOPC: libc::c_int = 3;
pub const ILL_ILLOPN: libc::c_int = 4;
pub const ILL_ILLADR: libc::c_int = 5;
pub const ILL_PRVREG: libc::c_int = 6;
pub const ILL_COPROC: libc::c_int = 7;
pub const ILL_BADSTK: libc::c_int = 8;
pub const FPE_NOOP: libc::c_int = 0;
pub const FPE_FLTDIV: libc::c_int = 1;
pub const FPE_FLTOVF: libc::c_int = 2;
pub const FPE_FLTUND: libc::c_int = 3;
pub const FPE_FLTRES: libc::c_int = 4;
pub const FPE_FLTINV: libc::c_int = 5;
pub const FPE_FLTSUB: libc::c_int = 6;
pub const FPE_INTDIV: libc::c_int = 7;
pub const FPE_INTOVF: libc::c_int = 8;
pub const SEGV_NOOP: libc::c_int = 0;
pub const SEGV_MAPERR: libc::c_int = 1;
pub const SEGV_ACCERR: libc::c_int = 2;
pub const BUS_NOOP: libc::c_int = 0;
pub const BUS_ADRALN: libc::c_int = 1;
pub const BUS_ADRERR: libc::c_int = 2;
pub const BUS_OBJERR: libc::c_int = 3;
pub const TRAP_BRKPT: libc::c_int = 1;
pub const TRAP_TRACE: libc::c_int = 2;
pub const CLD_NOOP: libc::c_int = 0;
pub const CLD_EXITED: libc::c_int = 1;
pub const CLD_KILLED: libc::c_int = 2;
pub const CLD_DUMPED: libc::c_int = 3;
pub const CLD_TRAPPED: libc::c_int = 4;
pub const CLD_STOPPED: libc::c_int = 5;
pub const CLD_CONTINUED: libc::c_int = 6;
pub const POLL_IN: libc::c_int = 1;
pub const POLL_OUT: libc::c_int = 2;
pub const POLL_MSG: libc::c_int = 3;
pub const POLL_ERR: libc::c_int = 4;
pub const POLL_PRI: libc::c_int = 5;
pub const POLL_HUP: libc::c_int = 6;
pub const SA_ONSTACK: libc::c_int = 1;
pub const SA_RESTART: libc::c_int = 2;
pub const SA_RESETHAND: libc::c_int = 4;
pub const SA_NOCLDSTOP: libc::c_int = 8;
pub const SA_NODEFER: libc::c_int = 16;
pub const SA_NOCLDWAIT: libc::c_int = 32;
pub const SA_SIGINFO: libc::c_int = 64;
pub const SA_USERTRAMP: libc::c_int = 256;
pub const SA_64REGSET: libc::c_int = 512;
pub const SA_USERSPACE_MASK: libc::c_int = 127;
pub const SIG_BLOCK: libc::c_int = 1;
pub const SIG_UNBLOCK: libc::c_int = 2;
pub const SIG_SETMASK: libc::c_int = 3;
pub const SI_USER: libc::c_int = 65537;
pub const SI_QUEUE: libc::c_int = 65538;
pub const SI_TIMER: libc::c_int = 65539;
pub const SI_ASYNCIO: libc::c_int = 65540;
pub const SI_MESGQ: libc::c_int = 65541;
pub const SS_ONSTACK: libc::c_int = 1;
pub const SS_DISABLE: libc::c_int = 4;
pub const MINSIGSTKSZ: libc::c_int = 32768;
pub const SIGSTKSZ: libc::c_int = 131072;
pub const SV_ONSTACK: libc::c_int = 1;
pub const SV_INTERRUPT: libc::c_int = 2;
pub const SV_RESETHAND: libc::c_int = 4;
pub const SV_NODEFER: libc::c_int = 16;
pub const SV_NOCLDSTOP: libc::c_int = 8;
pub const SV_SIGINFO: libc::c_int = 64;
pub const PRIO_PROCESS: libc::c_int = 0;
pub const PRIO_PGRP: libc::c_int = 1;
pub const PRIO_USER: libc::c_int = 2;
pub const PRIO_DARWIN_THREAD: libc::c_int = 3;
pub const PRIO_DARWIN_PROCESS: libc::c_int = 4;
pub const PRIO_MIN: libc::c_int = -20;
pub const PRIO_MAX: libc::c_int = 20;
pub const PRIO_DARWIN_BG: libc::c_int = 4096;
pub const PRIO_DARWIN_NONUI: libc::c_int = 4097;
pub const RUSAGE_SELF: libc::c_int = 0;
pub const RUSAGE_CHILDREN: libc::c_int = -1;
pub const RUSAGE_INFO_V0: libc::c_int = 0;
pub const RUSAGE_INFO_V1: libc::c_int = 1;
pub const RUSAGE_INFO_V2: libc::c_int = 2;
pub const RUSAGE_INFO_V3: libc::c_int = 3;
pub const RUSAGE_INFO_V4: libc::c_int = 4;
pub const RUSAGE_INFO_CURRENT: libc::c_int = 4;
pub const RLIMIT_CPU: libc::c_int = 0;
pub const RLIMIT_FSIZE: libc::c_int = 1;
pub const RLIMIT_DATA: libc::c_int = 2;
pub const RLIMIT_STACK: libc::c_int = 3;
pub const RLIMIT_CORE: libc::c_int = 4;
pub const RLIMIT_AS: libc::c_int = 5;
pub const RLIMIT_RSS: libc::c_int = 5;
pub const RLIMIT_MEMLOCK: libc::c_int = 6;
pub const RLIMIT_NPROC: libc::c_int = 7;
pub const RLIMIT_NOFILE: libc::c_int = 8;
pub const RLIM_NLIMITS: libc::c_int = 9;
pub const _RLIMIT_POSIX_FLAG: libc::c_int = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: libc::c_int = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: libc::c_int = 2;
pub const RLIMIT_THREAD_CPULIMITS: libc::c_int = 3;
pub const WAKEMON_ENABLE: libc::c_int = 1;
pub const WAKEMON_DISABLE: libc::c_int = 2;
pub const WAKEMON_GET_PARAMS: libc::c_int = 4;
pub const WAKEMON_SET_DEFAULTS: libc::c_int = 8;
pub const WAKEMON_MAKE_FATAL: libc::c_int = 16;
pub const CPUMON_MAKE_FATAL: libc::c_int = 4096;
pub const IOPOL_TYPE_DISK: libc::c_int = 0;
pub const IOPOL_SCOPE_PROCESS: libc::c_int = 0;
pub const IOPOL_SCOPE_THREAD: libc::c_int = 1;
pub const IOPOL_SCOPE_DARWIN_BG: libc::c_int = 2;
pub const IOPOL_DEFAULT: libc::c_int = 0;
pub const IOPOL_IMPORTANT: libc::c_int = 1;
pub const IOPOL_PASSIVE: libc::c_int = 2;
pub const IOPOL_THROTTLE: libc::c_int = 3;
pub const IOPOL_UTILITY: libc::c_int = 4;
pub const IOPOL_STANDARD: libc::c_int = 5;
pub const IOPOL_APPLICATION: libc::c_int = 5;
pub const IOPOL_NORMAL: libc::c_int = 1;
pub const WNOHANG: libc::c_int = 1;
pub const WUNTRACED: libc::c_int = 2;
pub const WCOREFLAG: libc::c_int = 128;
pub const _WSTOPPED: libc::c_int = 127;
pub const WEXITED: libc::c_int = 4;
pub const WSTOPPED: libc::c_int = 8;
pub const WCONTINUED: libc::c_int = 16;
pub const WNOWAIT: libc::c_int = 32;
pub const WAIT_ANY: libc::c_int = -1;
pub const WAIT_MYPGRP: libc::c_int = 0;
pub const _QUAD_HIGHWORD: libc::c_int = 1;
pub const _QUAD_LOWWORD: libc::c_int = 0;
pub const __DARWIN_LITTLE_ENDIAN: libc::c_int = 1234;
pub const __DARWIN_BIG_ENDIAN: libc::c_int = 4321;
pub const __DARWIN_PDP_ENDIAN: libc::c_int = 3412;
pub const __DARWIN_BYTE_ORDER: libc::c_int = 1234;
pub const LITTLE_ENDIAN: libc::c_int = 1234;
pub const BIG_ENDIAN: libc::c_int = 4321;
pub const PDP_ENDIAN: libc::c_int = 3412;
pub const BYTE_ORDER: libc::c_int = 1234;
pub const EXIT_FAILURE: libc::c_int = 1;
pub const EXIT_SUCCESS: libc::c_int = 0;
pub const RAND_MAX: libc::c_int = 2147483647;
pub const LIBAVUTIL_VERSION_MAJOR: libc::c_int = 55;
pub const LIBAVUTIL_VERSION_MINOR: libc::c_int = 78;
pub const LIBAVUTIL_VERSION_MICRO: libc::c_int = 100;
pub const AV_HAVE_BIGENDIAN: libc::c_int = 0;
pub const AV_HAVE_FAST_UNALIGNED: libc::c_int = 1;
pub const AVERROR_EXPERIMENTAL: libc::c_int = -733130664;
pub const AVERROR_INPUT_CHANGED: libc::c_int = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: libc::c_int = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: usize = 64;
pub const M_LOG2_10: f64 = 3.321928094887362;
pub const M_PHI: f64 = 1.618033988749895;
pub const __GNUC_VA_LIST: libc::c_int = 1;
pub const AV_LOG_QUIET: libc::c_int = -8;
pub const AV_LOG_PANIC: libc::c_int = 0;
pub const AV_LOG_FATAL: libc::c_int = 8;
pub const AV_LOG_ERROR: libc::c_int = 16;
pub const AV_LOG_WARNING: libc::c_int = 24;
pub const AV_LOG_INFO: libc::c_int = 32;
pub const AV_LOG_VERBOSE: libc::c_int = 40;
pub const AV_LOG_DEBUG: libc::c_int = 48;
pub const AV_LOG_TRACE: libc::c_int = 56;
pub const AV_LOG_MAX_OFFSET: libc::c_int = 64;
pub const AV_LOG_SKIP_REPEATED: libc::c_int = 1;
pub const AV_LOG_PRINT_LEVEL: libc::c_int = 2;
pub const AVPALETTE_SIZE: libc::c_int = 1024;
pub const AVPALETTE_COUNT: libc::c_int = 256;
pub const AV_FOURCC_MAX_STRING_SIZE: libc::c_int = 32;
pub const AV_BUFFER_FLAG_READONLY: libc::c_int = 1;
pub const AV_CPU_FLAG_FORCE: libc::c_uint = 2147483648;
pub const AV_CPU_FLAG_MMX: libc::c_int = 1;
pub const AV_CPU_FLAG_MMXEXT: libc::c_int = 2;
pub const AV_CPU_FLAG_MMX2: libc::c_int = 2;
pub const AV_CPU_FLAG_3DNOW: libc::c_int = 4;
pub const AV_CPU_FLAG_SSE: libc::c_int = 8;
pub const AV_CPU_FLAG_SSE2: libc::c_int = 16;
pub const AV_CPU_FLAG_SSE2SLOW: libc::c_int = 1073741824;
pub const AV_CPU_FLAG_3DNOWEXT: libc::c_int = 32;
pub const AV_CPU_FLAG_SSE3: libc::c_int = 64;
pub const AV_CPU_FLAG_SSE3SLOW: libc::c_int = 536870912;
pub const AV_CPU_FLAG_SSSE3: libc::c_int = 128;
pub const AV_CPU_FLAG_SSSE3SLOW: libc::c_int = 67108864;
pub const AV_CPU_FLAG_ATOM: libc::c_int = 268435456;
pub const AV_CPU_FLAG_SSE4: libc::c_int = 256;
pub const AV_CPU_FLAG_SSE42: libc::c_int = 512;
pub const AV_CPU_FLAG_AESNI: libc::c_int = 524288;
pub const AV_CPU_FLAG_AVX: libc::c_int = 16384;
pub const AV_CPU_FLAG_AVXSLOW: libc::c_int = 134217728;
pub const AV_CPU_FLAG_XOP: libc::c_int = 1024;
pub const AV_CPU_FLAG_FMA4: libc::c_int = 2048;
pub const AV_CPU_FLAG_CMOV: libc::c_int = 4096;
pub const AV_CPU_FLAG_AVX2: libc::c_int = 32768;
pub const AV_CPU_FLAG_FMA3: libc::c_int = 65536;
pub const AV_CPU_FLAG_BMI1: libc::c_int = 131072;
pub const AV_CPU_FLAG_BMI2: libc::c_int = 262144;
pub const AV_CPU_FLAG_ALTIVEC: libc::c_int = 1;
pub const AV_CPU_FLAG_VSX: libc::c_int = 2;
pub const AV_CPU_FLAG_POWER8: libc::c_int = 4;
pub const AV_CPU_FLAG_ARMV5TE: libc::c_int = 1;
pub const AV_CPU_FLAG_ARMV6: libc::c_int = 2;
pub const AV_CPU_FLAG_ARMV6T2: libc::c_int = 4;
pub const AV_CPU_FLAG_VFP: libc::c_int = 8;
pub const AV_CPU_FLAG_VFPV3: libc::c_int = 16;
pub const AV_CPU_FLAG_NEON: libc::c_int = 32;
pub const AV_CPU_FLAG_ARMV8: libc::c_int = 64;
pub const AV_CPU_FLAG_VFP_VM: libc::c_int = 128;
pub const AV_CPU_FLAG_SETEND: libc::c_int = 65536;
pub const AV_CH_FRONT_LEFT: libc::c_ulonglong = 1;
pub const AV_CH_FRONT_RIGHT: libc::c_ulonglong = 2;
pub const AV_CH_FRONT_CENTER: libc::c_ulonglong = 4;
pub const AV_CH_LOW_FREQUENCY: libc::c_ulonglong = 8;
pub const AV_CH_BACK_LEFT: libc::c_ulonglong = 16;
pub const AV_CH_BACK_RIGHT: libc::c_ulonglong = 32;
pub const AV_CH_FRONT_LEFT_OF_CENTER: libc::c_ulonglong = 64;
pub const AV_CH_FRONT_RIGHT_OF_CENTER: libc::c_ulonglong = 128;
pub const AV_CH_BACK_CENTER: libc::c_ulonglong = 256;
pub const AV_CH_SIDE_LEFT: libc::c_ulonglong = 512;
pub const AV_CH_SIDE_RIGHT: libc::c_ulonglong = 1024;
pub const AV_CH_TOP_CENTER: libc::c_ulonglong = 2048;
pub const AV_CH_TOP_FRONT_LEFT: libc::c_ulonglong = 4096;
pub const AV_CH_TOP_FRONT_CENTER: libc::c_ulonglong = 8192;
pub const AV_CH_TOP_FRONT_RIGHT: libc::c_ulonglong = 16384;
pub const AV_CH_TOP_BACK_LEFT: libc::c_ulonglong = 32768;
pub const AV_CH_TOP_BACK_CENTER: libc::c_ulonglong = 65536;
pub const AV_CH_TOP_BACK_RIGHT: libc::c_ulonglong = 131072;
pub const AV_CH_STEREO_LEFT: libc::c_ulonglong = 536870912;
pub const AV_CH_STEREO_RIGHT: libc::c_ulonglong = 1073741824;
pub const AV_CH_WIDE_LEFT: libc::c_ulonglong = 2147483648;
pub const AV_CH_WIDE_RIGHT: libc::c_ulonglong = 4294967296;
pub const AV_CH_SURROUND_DIRECT_LEFT: libc::c_ulonglong = 8589934592;
pub const AV_CH_SURROUND_DIRECT_RIGHT: libc::c_ulonglong = 17179869184;
pub const AV_CH_LOW_FREQUENCY_2: libc::c_ulonglong = 34359738368;
pub const AV_CH_LAYOUT_NATIVE: libc::c_ulonglong = 9223372036854775808;
pub const AV_CH_LAYOUT_MONO: libc::c_ulonglong = 4;
pub const AV_CH_LAYOUT_STEREO: libc::c_ulonglong = 3;
pub const AV_CH_LAYOUT_2POINT1: libc::c_ulonglong = 11;
pub const AV_CH_LAYOUT_2_1: libc::c_ulonglong = 259;
pub const AV_CH_LAYOUT_SURROUND: libc::c_ulonglong = 7;
pub const AV_CH_LAYOUT_3POINT1: libc::c_ulonglong = 15;
pub const AV_CH_LAYOUT_4POINT0: libc::c_ulonglong = 263;
pub const AV_CH_LAYOUT_4POINT1: libc::c_ulonglong = 271;
pub const AV_CH_LAYOUT_2_2: libc::c_ulonglong = 1539;
pub const AV_CH_LAYOUT_QUAD: libc::c_ulonglong = 51;
pub const AV_CH_LAYOUT_5POINT0: libc::c_ulonglong = 1543;
pub const AV_CH_LAYOUT_5POINT1: libc::c_ulonglong = 1551;
pub const AV_CH_LAYOUT_5POINT0_BACK: libc::c_ulonglong = 55;
pub const AV_CH_LAYOUT_5POINT1_BACK: libc::c_ulonglong = 63;
pub const AV_CH_LAYOUT_6POINT0: libc::c_ulonglong = 1799;
pub const AV_CH_LAYOUT_6POINT0_FRONT: libc::c_ulonglong = 1731;
pub const AV_CH_LAYOUT_HEXAGONAL: libc::c_ulonglong = 311;
pub const AV_CH_LAYOUT_6POINT1: libc::c_ulonglong = 1807;
pub const AV_CH_LAYOUT_6POINT1_BACK: libc::c_ulonglong = 319;
pub const AV_CH_LAYOUT_6POINT1_FRONT: libc::c_ulonglong = 1739;
pub const AV_CH_LAYOUT_7POINT0: libc::c_ulonglong = 1591;
pub const AV_CH_LAYOUT_7POINT0_FRONT: libc::c_ulonglong = 1735;
pub const AV_CH_LAYOUT_7POINT1: libc::c_ulonglong = 1599;
pub const AV_CH_LAYOUT_7POINT1_WIDE: libc::c_ulonglong = 1743;
pub const AV_CH_LAYOUT_7POINT1_WIDE_BACK: libc::c_ulonglong = 255;
pub const AV_CH_LAYOUT_OCTAGONAL: libc::c_ulonglong = 1847;
pub const AV_CH_LAYOUT_HEXADECAGONAL: libc::c_ulonglong = 6442710839;
pub const AV_CH_LAYOUT_STEREO_DOWNMIX: libc::c_ulonglong = 1610612736;
pub const AV_DICT_MATCH_CASE: libc::c_int = 1;
pub const AV_DICT_IGNORE_SUFFIX: libc::c_int = 2;
pub const AV_DICT_DONT_STRDUP_KEY: libc::c_int = 4;
pub const AV_DICT_DONT_STRDUP_VAL: libc::c_int = 8;
pub const AV_DICT_DONT_OVERWRITE: libc::c_int = 16;
pub const AV_DICT_APPEND: libc::c_int = 32;
pub const AV_DICT_MULTIKEY: libc::c_int = 64;
pub const AV_NUM_DATA_POINTERS: libc::c_int = 8;
pub const AV_FRAME_FLAG_CORRUPT: libc::c_int = 1;
pub const AV_FRAME_FLAG_DISCARD: libc::c_int = 4;
pub const FF_DECODE_ERROR_INVALID_BITSTREAM: libc::c_int = 1;
pub const FF_DECODE_ERROR_MISSING_REFERENCE: libc::c_int = 2;
pub const LIBAVCODEC_VERSION_MAJOR: libc::c_int = 57;
pub const LIBAVCODEC_VERSION_MINOR: libc::c_int = 107;
pub const LIBAVCODEC_VERSION_MICRO: libc::c_int = 100;
pub const AV_CODEC_PROP_INTRA_ONLY: libc::c_int = 1;
pub const AV_CODEC_PROP_LOSSY: libc::c_int = 2;
pub const AV_CODEC_PROP_LOSSLESS: libc::c_int = 4;
pub const AV_CODEC_PROP_REORDER: libc::c_int = 8;
pub const AV_CODEC_PROP_BITMAP_SUB: libc::c_int = 65536;
pub const AV_CODEC_PROP_TEXT_SUB: libc::c_int = 131072;
pub const AV_INPUT_BUFFER_PADDING_SIZE: libc::c_int = 32;
pub const AV_INPUT_BUFFER_MIN_SIZE: libc::c_int = 16384;
pub const FF_INPUT_BUFFER_PADDING_SIZE: libc::c_int = 32;
pub const FF_MIN_BUFFER_SIZE: libc::c_int = 16384;
pub const FF_MAX_B_FRAMES: libc::c_int = 16;
pub const AV_CODEC_FLAG_UNALIGNED: libc::c_uint = 1;
pub const AV_CODEC_FLAG_QSCALE: libc::c_uint = 2;
pub const AV_CODEC_FLAG_4MV: libc::c_uint = 4;
pub const AV_CODEC_FLAG_OUTPUT_CORRUPT: libc::c_uint = 8;
pub const AV_CODEC_FLAG_QPEL: libc::c_uint = 16;
pub const AV_CODEC_FLAG_PASS1: libc::c_uint = 512;
pub const AV_CODEC_FLAG_PASS2: libc::c_uint = 1024;
pub const AV_CODEC_FLAG_LOOP_FILTER: libc::c_uint = 2048;
pub const AV_CODEC_FLAG_GRAY: libc::c_uint = 8192;
pub const AV_CODEC_FLAG_PSNR: libc::c_uint = 32768;
pub const AV_CODEC_FLAG_TRUNCATED: libc::c_uint = 65536;
pub const AV_CODEC_FLAG_INTERLACED_DCT: libc::c_uint = 262144;
pub const AV_CODEC_FLAG_LOW_DELAY: libc::c_uint = 524288;
pub const AV_CODEC_FLAG_GLOBAL_HEADER: libc::c_uint = 4194304;
pub const AV_CODEC_FLAG_BITEXACT: libc::c_uint = 8388608;
pub const AV_CODEC_FLAG_AC_PRED: libc::c_uint = 16777216;
pub const AV_CODEC_FLAG_INTERLACED_ME: libc::c_uint = 536870912;
pub const AV_CODEC_FLAG_CLOSED_GOP: libc::c_uint = 2147483648;
pub const AV_CODEC_FLAG2_FAST: libc::c_uint = 1;
pub const AV_CODEC_FLAG2_NO_OUTPUT: libc::c_uint = 4;
pub const AV_CODEC_FLAG2_LOCAL_HEADER: libc::c_uint = 8;
pub const AV_CODEC_FLAG2_DROP_FRAME_TIMECODE: libc::c_uint = 8192;
pub const AV_CODEC_FLAG2_CHUNKS: libc::c_uint = 32768;
pub const AV_CODEC_FLAG2_IGNORE_CROP: libc::c_uint = 65536;
pub const AV_CODEC_FLAG2_SHOW_ALL: libc::c_uint = 4194304;
pub const AV_CODEC_FLAG2_EXPORT_MVS: libc::c_uint = 268435456;
pub const AV_CODEC_FLAG2_SKIP_MANUAL: libc::c_uint = 536870912;
pub const AV_CODEC_FLAG2_RO_FLUSH_NOOP: libc::c_uint = 1073741824;
pub const AV_CODEC_CAP_DRAW_HORIZ_BAND: libc::c_uint = 1;
pub const AV_CODEC_CAP_DR1: libc::c_uint = 2;
pub const AV_CODEC_CAP_TRUNCATED: libc::c_uint = 8;
pub const AV_CODEC_CAP_DELAY: libc::c_uint = 32;
pub const AV_CODEC_CAP_SMALL_LAST_FRAME: libc::c_uint = 64;
pub const AV_CODEC_CAP_HWACCEL_VDPAU: libc::c_uint = 128;
pub const AV_CODEC_CAP_SUBFRAMES: libc::c_uint = 256;
pub const AV_CODEC_CAP_EXPERIMENTAL: libc::c_uint = 512;
pub const AV_CODEC_CAP_CHANNEL_CONF: libc::c_uint = 1024;
pub const AV_CODEC_CAP_FRAME_THREADS: libc::c_uint = 4096;
pub const AV_CODEC_CAP_SLICE_THREADS: libc::c_uint = 8192;
pub const AV_CODEC_CAP_PARAM_CHANGE: libc::c_uint = 16384;
pub const AV_CODEC_CAP_AUTO_THREADS: libc::c_uint = 32768;
pub const AV_CODEC_CAP_VARIABLE_FRAME_SIZE: libc::c_uint = 65536;
pub const AV_CODEC_CAP_AVOID_PROBING: libc::c_uint = 131072;
pub const AV_CODEC_CAP_INTRA_ONLY: libc::c_uint = 1073741824;
pub const AV_CODEC_CAP_LOSSLESS: libc::c_uint = 2147483648;
pub const CODEC_FLAG_UNALIGNED: libc::c_int = 1;
pub const CODEC_FLAG_QSCALE: libc::c_int = 2;
pub const CODEC_FLAG_4MV: libc::c_int = 4;
pub const CODEC_FLAG_OUTPUT_CORRUPT: libc::c_int = 8;
pub const CODEC_FLAG_QPEL: libc::c_int = 16;
pub const CODEC_FLAG_GMC: libc::c_int = 32;
pub const CODEC_FLAG_MV0: libc::c_int = 64;
pub const CODEC_FLAG_INPUT_PRESERVED: libc::c_int = 256;
pub const CODEC_FLAG_PASS1: libc::c_int = 512;
pub const CODEC_FLAG_PASS2: libc::c_int = 1024;
pub const CODEC_FLAG_GRAY: libc::c_int = 8192;
pub const CODEC_FLAG_EMU_EDGE: libc::c_int = 16384;
pub const CODEC_FLAG_PSNR: libc::c_int = 32768;
pub const CODEC_FLAG_TRUNCATED: libc::c_int = 65536;
pub const CODEC_FLAG_NORMALIZE_AQP: libc::c_int = 131072;
pub const CODEC_FLAG_INTERLACED_DCT: libc::c_int = 262144;
pub const CODEC_FLAG_LOW_DELAY: libc::c_int = 524288;
pub const CODEC_FLAG_GLOBAL_HEADER: libc::c_int = 4194304;
pub const CODEC_FLAG_BITEXACT: libc::c_int = 8388608;
pub const CODEC_FLAG_AC_PRED: libc::c_int = 16777216;
pub const CODEC_FLAG_LOOP_FILTER: libc::c_int = 2048;
pub const CODEC_FLAG_INTERLACED_ME: libc::c_int = 536870912;
pub const CODEC_FLAG_CLOSED_GOP: libc::c_uint = 2147483648;
pub const CODEC_FLAG2_FAST: libc::c_int = 1;
pub const CODEC_FLAG2_NO_OUTPUT: libc::c_int = 4;
pub const CODEC_FLAG2_LOCAL_HEADER: libc::c_int = 8;
pub const CODEC_FLAG2_DROP_FRAME_TIMECODE: libc::c_int = 8192;
pub const CODEC_FLAG2_IGNORE_CROP: libc::c_int = 65536;
pub const CODEC_FLAG2_CHUNKS: libc::c_int = 32768;
pub const CODEC_FLAG2_SHOW_ALL: libc::c_int = 4194304;
pub const CODEC_FLAG2_EXPORT_MVS: libc::c_int = 268435456;
pub const CODEC_FLAG2_SKIP_MANUAL: libc::c_int = 536870912;
pub const CODEC_CAP_DRAW_HORIZ_BAND: libc::c_int = 1;
pub const CODEC_CAP_DR1: libc::c_int = 2;
pub const CODEC_CAP_TRUNCATED: libc::c_int = 8;
pub const CODEC_CAP_HWACCEL: libc::c_int = 16;
pub const CODEC_CAP_DELAY: libc::c_int = 32;
pub const CODEC_CAP_SMALL_LAST_FRAME: libc::c_int = 64;
pub const CODEC_CAP_HWACCEL_VDPAU: libc::c_int = 128;
pub const CODEC_CAP_SUBFRAMES: libc::c_int = 256;
pub const CODEC_CAP_EXPERIMENTAL: libc::c_int = 512;
pub const CODEC_CAP_CHANNEL_CONF: libc::c_int = 1024;
pub const CODEC_CAP_NEG_LINESIZES: libc::c_int = 2048;
pub const CODEC_CAP_FRAME_THREADS: libc::c_int = 4096;
pub const CODEC_CAP_SLICE_THREADS: libc::c_int = 8192;
pub const CODEC_CAP_PARAM_CHANGE: libc::c_int = 16384;
pub const CODEC_CAP_AUTO_THREADS: libc::c_int = 32768;
pub const CODEC_CAP_VARIABLE_FRAME_SIZE: libc::c_int = 65536;
pub const CODEC_CAP_INTRA_ONLY: libc::c_int = 1073741824;
pub const CODEC_CAP_LOSSLESS: libc::c_uint = 2147483648;
pub const HWACCEL_CODEC_CAP_EXPERIMENTAL: libc::c_int = 512;
pub const MB_TYPE_INTRA4x4: libc::c_int = 1;
pub const MB_TYPE_INTRA16x16: libc::c_int = 2;
pub const MB_TYPE_INTRA_PCM: libc::c_int = 4;
pub const MB_TYPE_16x16: libc::c_int = 8;
pub const MB_TYPE_16x8: libc::c_int = 16;
pub const MB_TYPE_8x16: libc::c_int = 32;
pub const MB_TYPE_8x8: libc::c_int = 64;
pub const MB_TYPE_INTERLACED: libc::c_int = 128;
pub const MB_TYPE_DIRECT2: libc::c_int = 256;
pub const MB_TYPE_ACPRED: libc::c_int = 512;
pub const MB_TYPE_GMC: libc::c_int = 1024;
pub const MB_TYPE_SKIP: libc::c_int = 2048;
pub const MB_TYPE_P0L0: libc::c_int = 4096;
pub const MB_TYPE_P1L0: libc::c_int = 8192;
pub const MB_TYPE_P0L1: libc::c_int = 16384;
pub const MB_TYPE_P1L1: libc::c_int = 32768;
pub const MB_TYPE_L0: libc::c_int = 12288;
pub const MB_TYPE_L1: libc::c_int = 49152;
pub const MB_TYPE_L0L1: libc::c_int = 61440;
pub const MB_TYPE_QUANT: libc::c_int = 65536;
pub const MB_TYPE_CBP: libc::c_int = 131072;
pub const FF_QSCALE_TYPE_MPEG1: libc::c_int = 0;
pub const FF_QSCALE_TYPE_MPEG2: libc::c_int = 1;
pub const FF_QSCALE_TYPE_H264: libc::c_int = 2;
pub const FF_QSCALE_TYPE_VP56: libc::c_int = 3;
pub const AV_GET_BUFFER_FLAG_REF: libc::c_int = 1;
pub const AV_PKT_FLAG_KEY: libc::c_int = 1;
pub const AV_PKT_FLAG_CORRUPT: libc::c_int = 2;
pub const AV_PKT_FLAG_DISCARD: libc::c_int = 4;
pub const AV_PKT_FLAG_TRUSTED: libc::c_int = 8;
pub const FF_COMPRESSION_DEFAULT: libc::c_int = -1;
pub const FF_ASPECT_EXTENDED: libc::c_int = 15;
pub const FF_RC_STRATEGY_XVID: libc::c_int = 1;
pub const FF_PRED_LEFT: libc::c_int = 0;
pub const FF_PRED_PLANE: libc::c_int = 1;
pub const FF_PRED_MEDIAN: libc::c_int = 2;
pub const FF_CMP_SAD: libc::c_int = 0;
pub const FF_CMP_SSE: libc::c_int = 1;
pub const FF_CMP_SATD: libc::c_int = 2;
pub const FF_CMP_DCT: libc::c_int = 3;
pub const FF_CMP_PSNR: libc::c_int = 4;
pub const FF_CMP_BIT: libc::c_int = 5;
pub const FF_CMP_RD: libc::c_int = 6;
pub const FF_CMP_ZERO: libc::c_int = 7;
pub const FF_CMP_VSAD: libc::c_int = 8;
pub const FF_CMP_VSSE: libc::c_int = 9;
pub const FF_CMP_NSSE: libc::c_int = 10;
pub const FF_CMP_W53: libc::c_int = 11;
pub const FF_CMP_W97: libc::c_int = 12;
pub const FF_CMP_DCTMAX: libc::c_int = 13;
pub const FF_CMP_DCT264: libc::c_int = 14;
pub const FF_CMP_MEDIAN_SAD: libc::c_int = 15;
pub const FF_CMP_CHROMA: libc::c_int = 256;
pub const FF_DTG_AFD_SAME: libc::c_int = 8;
pub const FF_DTG_AFD_4_3: libc::c_int = 9;
pub const FF_DTG_AFD_16_9: libc::c_int = 10;
pub const FF_DTG_AFD_14_9: libc::c_int = 11;
pub const FF_DTG_AFD_4_3_SP_14_9: libc::c_int = 13;
pub const FF_DTG_AFD_16_9_SP_14_9: libc::c_int = 14;
pub const FF_DTG_AFD_SP_4_3: libc::c_int = 15;
pub const FF_DEFAULT_QUANT_BIAS: libc::c_int = 999999;
pub const SLICE_FLAG_CODED_ORDER: libc::c_int = 1;
pub const SLICE_FLAG_ALLOW_FIELD: libc::c_int = 2;
pub const SLICE_FLAG_ALLOW_PLANE: libc::c_int = 4;
pub const FF_MB_DECISION_SIMPLE: libc::c_int = 0;
pub const FF_MB_DECISION_BITS: libc::c_int = 1;
pub const FF_MB_DECISION_RD: libc::c_int = 2;
pub const FF_CODER_TYPE_VLC: libc::c_int = 0;
pub const FF_CODER_TYPE_AC: libc::c_int = 1;
pub const FF_CODER_TYPE_RAW: libc::c_int = 2;
pub const FF_CODER_TYPE_RLE: libc::c_int = 3;
pub const FF_CODER_TYPE_DEFLATE: libc::c_int = 4;
pub const FF_BUG_AUTODETECT: libc::c_int = 1;
pub const FF_BUG_OLD_MSMPEG4: libc::c_int = 2;
pub const FF_BUG_XVID_ILACE: libc::c_int = 4;
pub const FF_BUG_UMP4: libc::c_int = 8;
pub const FF_BUG_NO_PADDING: libc::c_int = 16;
pub const FF_BUG_AMV: libc::c_int = 32;
pub const FF_BUG_AC_VLC: libc::c_int = 0;
pub const FF_BUG_QPEL_CHROMA: libc::c_int = 64;
pub const FF_BUG_STD_QPEL: libc::c_int = 128;
pub const FF_BUG_QPEL_CHROMA2: libc::c_int = 256;
pub const FF_BUG_DIRECT_BLOCKSIZE: libc::c_int = 512;
pub const FF_BUG_EDGE: libc::c_int = 1024;
pub const FF_BUG_HPEL_CHROMA: libc::c_int = 2048;
pub const FF_BUG_DC_CLIP: libc::c_int = 4096;
pub const FF_BUG_MS: libc::c_int = 8192;
pub const FF_BUG_TRUNCATED: libc::c_int = 16384;
pub const FF_BUG_IEDGE: libc::c_int = 32768;
pub const FF_COMPLIANCE_VERY_STRICT: libc::c_int = 2;
pub const FF_COMPLIANCE_STRICT: libc::c_int = 1;
pub const FF_COMPLIANCE_NORMAL: libc::c_int = 0;
pub const FF_COMPLIANCE_UNOFFICIAL: libc::c_int = -1;
pub const FF_COMPLIANCE_EXPERIMENTAL: libc::c_int = -2;
pub const FF_EC_GUESS_MVS: libc::c_int = 1;
pub const FF_EC_DEBLOCK: libc::c_int = 2;
pub const FF_EC_FAVOR_INTER: libc::c_int = 256;
pub const FF_DEBUG_PICT_INFO: libc::c_int = 1;
pub const FF_DEBUG_RC: libc::c_int = 2;
pub const FF_DEBUG_BITSTREAM: libc::c_int = 4;
pub const FF_DEBUG_MB_TYPE: libc::c_int = 8;
pub const FF_DEBUG_QP: libc::c_int = 16;
pub const FF_DEBUG_MV: libc::c_int = 32;
pub const FF_DEBUG_DCT_COEFF: libc::c_int = 64;
pub const FF_DEBUG_SKIP: libc::c_int = 128;
pub const FF_DEBUG_STARTCODE: libc::c_int = 256;
pub const FF_DEBUG_PTS: libc::c_int = 512;
pub const FF_DEBUG_ER: libc::c_int = 1024;
pub const FF_DEBUG_MMCO: libc::c_int = 2048;
pub const FF_DEBUG_BUGS: libc::c_int = 4096;
pub const FF_DEBUG_VIS_QP: libc::c_int = 8192;
pub const FF_DEBUG_VIS_MB_TYPE: libc::c_int = 16384;
pub const FF_DEBUG_BUFFERS: libc::c_int = 32768;
pub const FF_DEBUG_THREADS: libc::c_int = 65536;
pub const FF_DEBUG_GREEN_MD: libc::c_int = 8388608;
pub const FF_DEBUG_NOMC: libc::c_int = 16777216;
pub const FF_DEBUG_VIS_MV_P_FOR: libc::c_int = 1;
pub const FF_DEBUG_VIS_MV_B_FOR: libc::c_int = 2;
pub const FF_DEBUG_VIS_MV_B_BACK: libc::c_int = 4;
pub const AV_EF_CRCCHECK: libc::c_int = 1;
pub const AV_EF_BITSTREAM: libc::c_int = 2;
pub const AV_EF_BUFFER: libc::c_int = 4;
pub const AV_EF_EXPLODE: libc::c_int = 8;
pub const AV_EF_IGNORE_ERR: libc::c_int = 32768;
pub const AV_EF_CAREFUL: libc::c_int = 65536;
pub const AV_EF_COMPLIANT: libc::c_int = 131072;
pub const AV_EF_AGGRESSIVE: libc::c_int = 262144;
pub const FF_DCT_AUTO: libc::c_int = 0;
pub const FF_DCT_FASTINT: libc::c_int = 1;
pub const FF_DCT_INT: libc::c_int = 2;
pub const FF_DCT_MMX: libc::c_int = 3;
pub const FF_DCT_ALTIVEC: libc::c_int = 5;
pub const FF_DCT_FAAN: libc::c_int = 6;
pub const FF_IDCT_AUTO: libc::c_int = 0;
pub const FF_IDCT_INT: libc::c_int = 1;
pub const FF_IDCT_SIMPLE: libc::c_int = 2;
pub const FF_IDCT_SIMPLEMMX: libc::c_int = 3;
pub const FF_IDCT_ARM: libc::c_int = 7;
pub const FF_IDCT_ALTIVEC: libc::c_int = 8;
pub const FF_IDCT_SH4: libc::c_int = 9;
pub const FF_IDCT_SIMPLEARM: libc::c_int = 10;
pub const FF_IDCT_IPP: libc::c_int = 13;
pub const FF_IDCT_XVID: libc::c_int = 14;
pub const FF_IDCT_XVIDMMX: libc::c_int = 14;
pub const FF_IDCT_SIMPLEARMV5TE: libc::c_int = 16;
pub const FF_IDCT_SIMPLEARMV6: libc::c_int = 17;
pub const FF_IDCT_SIMPLEVIS: libc::c_int = 18;
pub const FF_IDCT_FAAN: libc::c_int = 20;
pub const FF_IDCT_SIMPLENEON: libc::c_int = 22;
pub const FF_IDCT_SIMPLEALPHA: libc::c_int = 23;
pub const FF_IDCT_NONE: libc::c_int = 24;
pub const FF_IDCT_SIMPLEAUTO: libc::c_int = 128;
pub const FF_THREAD_FRAME: libc::c_int = 1;
pub const FF_THREAD_SLICE: libc::c_int = 2;
pub const FF_PROFILE_UNKNOWN: libc::c_int = -99;
pub const FF_PROFILE_RESERVED: libc::c_int = -100;
pub const FF_PROFILE_AAC_MAIN: libc::c_int = 0;
pub const FF_PROFILE_AAC_LOW: libc::c_int = 1;
pub const FF_PROFILE_AAC_SSR: libc::c_int = 2;
pub const FF_PROFILE_AAC_LTP: libc::c_int = 3;
pub const FF_PROFILE_AAC_HE: libc::c_int = 4;
pub const FF_PROFILE_AAC_HE_V2: libc::c_int = 28;
pub const FF_PROFILE_AAC_LD: libc::c_int = 22;
pub const FF_PROFILE_AAC_ELD: libc::c_int = 38;
pub const FF_PROFILE_MPEG2_AAC_LOW: libc::c_int = 128;
pub const FF_PROFILE_MPEG2_AAC_HE: libc::c_int = 131;
pub const FF_PROFILE_DNXHD: libc::c_int = 0;
pub const FF_PROFILE_DNXHR_LB: libc::c_int = 1;
pub const FF_PROFILE_DNXHR_SQ: libc::c_int = 2;
pub const FF_PROFILE_DNXHR_HQ: libc::c_int = 3;
pub const FF_PROFILE_DNXHR_HQX: libc::c_int = 4;
pub const FF_PROFILE_DNXHR_444: libc::c_int = 5;
pub const FF_PROFILE_DTS: libc::c_int = 20;
pub const FF_PROFILE_DTS_ES: libc::c_int = 30;
pub const FF_PROFILE_DTS_96_24: libc::c_int = 40;
pub const FF_PROFILE_DTS_HD_HRA: libc::c_int = 50;
pub const FF_PROFILE_DTS_HD_MA: libc::c_int = 60;
pub const FF_PROFILE_DTS_EXPRESS: libc::c_int = 70;
pub const FF_PROFILE_MPEG2_422: libc::c_int = 0;
pub const FF_PROFILE_MPEG2_HIGH: libc::c_int = 1;
pub const FF_PROFILE_MPEG2_SS: libc::c_int = 2;
pub const FF_PROFILE_MPEG2_SNR_SCALABLE: libc::c_int = 3;
pub const FF_PROFILE_MPEG2_MAIN: libc::c_int = 4;
pub const FF_PROFILE_MPEG2_SIMPLE: libc::c_int = 5;
pub const FF_PROFILE_H264_CONSTRAINED: libc::c_int = 512;
pub const FF_PROFILE_H264_INTRA: libc::c_int = 2048;
pub const FF_PROFILE_H264_BASELINE: libc::c_int = 66;
pub const FF_PROFILE_H264_CONSTRAINED_BASELINE: libc::c_int = 578;
pub const FF_PROFILE_H264_MAIN: libc::c_int = 77;
pub const FF_PROFILE_H264_EXTENDED: libc::c_int = 88;
pub const FF_PROFILE_H264_HIGH: libc::c_int = 100;
pub const FF_PROFILE_H264_HIGH_10: libc::c_int = 110;
pub const FF_PROFILE_H264_HIGH_10_INTRA: libc::c_int = 2158;
pub const FF_PROFILE_H264_MULTIVIEW_HIGH: libc::c_int = 118;
pub const FF_PROFILE_H264_HIGH_422: libc::c_int = 122;
pub const FF_PROFILE_H264_HIGH_422_INTRA: libc::c_int = 2170;
pub const FF_PROFILE_H264_STEREO_HIGH: libc::c_int = 128;
pub const FF_PROFILE_H264_HIGH_444: libc::c_int = 144;
pub const FF_PROFILE_H264_HIGH_444_PREDICTIVE: libc::c_int = 244;
pub const FF_PROFILE_H264_HIGH_444_INTRA: libc::c_int = 2292;
pub const FF_PROFILE_H264_CAVLC_444: libc::c_int = 44;
pub const FF_PROFILE_VC1_SIMPLE: libc::c_int = 0;
pub const FF_PROFILE_VC1_MAIN: libc::c_int = 1;
pub const FF_PROFILE_VC1_COMPLEX: libc::c_int = 2;
pub const FF_PROFILE_VC1_ADVANCED: libc::c_int = 3;
pub const FF_PROFILE_MPEG4_SIMPLE: libc::c_int = 0;
pub const FF_PROFILE_MPEG4_SIMPLE_SCALABLE: libc::c_int = 1;
pub const FF_PROFILE_MPEG4_CORE: libc::c_int = 2;
pub const FF_PROFILE_MPEG4_MAIN: libc::c_int = 3;
pub const FF_PROFILE_MPEG4_N_BIT: libc::c_int = 4;
pub const FF_PROFILE_MPEG4_SCALABLE_TEXTURE: libc::c_int = 5;
pub const FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION: libc::c_int = 6;
pub const FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE: libc::c_int = 7;
pub const FF_PROFILE_MPEG4_HYBRID: libc::c_int = 8;
pub const FF_PROFILE_MPEG4_ADVANCED_REAL_TIME: libc::c_int = 9;
pub const FF_PROFILE_MPEG4_CORE_SCALABLE: libc::c_int = 10;
pub const FF_PROFILE_MPEG4_ADVANCED_CODING: libc::c_int = 11;
pub const FF_PROFILE_MPEG4_ADVANCED_CORE: libc::c_int = 12;
pub const FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE: libc::c_int = 13;
pub const FF_PROFILE_MPEG4_SIMPLE_STUDIO: libc::c_int = 14;
pub const FF_PROFILE_MPEG4_ADVANCED_SIMPLE: libc::c_int = 15;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0: libc::c_int = 1;
pub const FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1: libc::c_int = 2;
pub const FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION: libc::c_int = 32768;
pub const FF_PROFILE_JPEG2000_DCINEMA_2K: libc::c_int = 3;
pub const FF_PROFILE_JPEG2000_DCINEMA_4K: libc::c_int = 4;
pub const FF_PROFILE_VP9_0: libc::c_int = 0;
pub const FF_PROFILE_VP9_1: libc::c_int = 1;
pub const FF_PROFILE_VP9_2: libc::c_int = 2;
pub const FF_PROFILE_VP9_3: libc::c_int = 3;
pub const FF_PROFILE_HEVC_MAIN: libc::c_int = 1;
pub const FF_PROFILE_HEVC_MAIN_10: libc::c_int = 2;
pub const FF_PROFILE_HEVC_MAIN_STILL_PICTURE: libc::c_int = 3;
pub const FF_PROFILE_HEVC_REXT: libc::c_int = 4;
pub const FF_LEVEL_UNKNOWN: libc::c_int = -99;
pub const FF_SUB_CHARENC_MODE_DO_NOTHING: libc::c_int = -1;
pub const FF_SUB_CHARENC_MODE_AUTOMATIC: libc::c_int = 0;
pub const FF_SUB_CHARENC_MODE_PRE_DECODER: libc::c_int = 1;
pub const FF_CODEC_PROPERTY_LOSSLESS: libc::c_int = 1;
pub const FF_CODEC_PROPERTY_CLOSED_CAPTIONS: libc::c_int = 2;
pub const FF_SUB_TEXT_FMT_ASS: libc::c_int = 0;
pub const FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS: libc::c_int = 1;
pub const AV_HWACCEL_CODEC_CAP_EXPERIMENTAL: libc::c_int = 512;
pub const AV_HWACCEL_FLAG_IGNORE_LEVEL: libc::c_int = 1;
pub const AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH: libc::c_int = 2;
pub const AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH: libc::c_int = 4;
pub const AV_SUBTITLE_FLAG_FORCED: libc::c_int = 1;
pub const AV_PARSER_PTS_NB: libc::c_int = 4;
pub const PARSER_FLAG_COMPLETE_FRAMES: libc::c_int = 1;
pub const PARSER_FLAG_ONCE: libc::c_int = 2;
pub const PARSER_FLAG_FETCHED_OFFSET: libc::c_int = 4;
pub const PARSER_FLAG_USE_CODEC_TS: libc::c_int = 4096;
pub const DV_PROFILE_BYTES: libc::c_int = 480;
pub const VORBIS_FLAG_HEADER: libc::c_int = 1;
pub const VORBIS_FLAG_COMMENT: libc::c_int = 2;
pub const VORBIS_FLAG_SETUP: libc::c_int = 4;
pub const LIBAVDEVICE_VERSION_MAJOR: libc::c_int = 57;
pub const LIBAVDEVICE_VERSION_MINOR: libc::c_int = 10;
pub const LIBAVDEVICE_VERSION_MICRO: libc::c_int = 100;
pub const AV_OPT_FLAG_ENCODING_PARAM: libc::c_int = 1;
pub const AV_OPT_FLAG_DECODING_PARAM: libc::c_int = 2;
pub const AV_OPT_FLAG_METADATA: libc::c_int = 4;
pub const AV_OPT_FLAG_AUDIO_PARAM: libc::c_int = 8;
pub const AV_OPT_FLAG_VIDEO_PARAM: libc::c_int = 16;
pub const AV_OPT_FLAG_SUBTITLE_PARAM: libc::c_int = 32;
pub const AV_OPT_FLAG_EXPORT: libc::c_int = 64;
pub const AV_OPT_FLAG_READONLY: libc::c_int = 128;
pub const AV_OPT_FLAG_FILTERING_PARAM: libc::c_int = 65536;
pub const AV_OPT_SEARCH_CHILDREN: libc::c_int = 1;
pub const AV_OPT_SEARCH_FAKE_OBJ: libc::c_int = 2;
pub const AV_OPT_ALLOW_NULL: libc::c_int = 4;
pub const AV_OPT_MULTI_COMPONENT_RANGE: libc::c_int = 4096;
pub const AV_OPT_SERIALIZE_SKIP_DEFAULTS: libc::c_int = 1;
pub const AV_OPT_SERIALIZE_OPT_FLAGS_EXACT: libc::c_int = 2;
pub const CLOCKS_PER_SEC: libc::c_int = 1000000;
pub const LIBAVFORMAT_VERSION_MAJOR: libc::c_int = 57;
pub const LIBAVFORMAT_VERSION_MINOR: libc::c_int = 83;
pub const LIBAVFORMAT_VERSION_MICRO: libc::c_int = 100;
pub const FF_API_R_FRAME_RATE: libc::c_int = 1;
pub const AVIO_SEEKABLE_NORMAL: libc::c_int = 1;
pub const AVIO_SEEKABLE_TIME: libc::c_int = 2;
pub const AVSEEK_SIZE: libc::c_int = 65536;
pub const AVSEEK_FORCE: libc::c_int = 131072;
pub const AVIO_FLAG_READ: libc::c_int = 1;
pub const AVIO_FLAG_WRITE: libc::c_int = 2;
pub const AVIO_FLAG_READ_WRITE: libc::c_int = 3;
pub const AVIO_FLAG_NONBLOCK: libc::c_int = 8;
pub const AVIO_FLAG_DIRECT: libc::c_int = 32768;
pub const AVPROBE_SCORE_EXTENSION: libc::c_int = 50;
pub const AVPROBE_SCORE_MIME: libc::c_int = 75;
pub const AVPROBE_SCORE_MAX: libc::c_int = 100;
pub const AVPROBE_PADDING_SIZE: libc::c_int = 32;
pub const AVFMT_NOFILE: libc::c_int = 1;
pub const AVFMT_NEEDNUMBER: libc::c_int = 2;
pub const AVFMT_SHOW_IDS: libc::c_int = 8;
pub const AVFMT_RAWPICTURE: libc::c_int = 32;
pub const AVFMT_GLOBALHEADER: libc::c_int = 64;
pub const AVFMT_NOTIMESTAMPS: libc::c_int = 128;
pub const AVFMT_GENERIC_INDEX: libc::c_int = 256;
pub const AVFMT_TS_DISCONT: libc::c_int = 512;
pub const AVFMT_VARIABLE_FPS: libc::c_int = 1024;
pub const AVFMT_NODIMENSIONS: libc::c_int = 2048;
pub const AVFMT_NOSTREAMS: libc::c_int = 4096;
pub const AVFMT_NOBINSEARCH: libc::c_int = 8192;
pub const AVFMT_NOGENSEARCH: libc::c_int = 16384;
pub const AVFMT_NO_BYTE_SEEK: libc::c_int = 32768;
pub const AVFMT_ALLOW_FLUSH: libc::c_int = 65536;
pub const AVFMT_TS_NONSTRICT: libc::c_int = 131072;
pub const AVFMT_TS_NEGATIVE: libc::c_int = 262144;
pub const AVFMT_SEEK_TO_PTS: libc::c_int = 67108864;
pub const AVINDEX_KEYFRAME: libc::c_int = 1;
pub const AVINDEX_DISCARD_FRAME: libc::c_int = 2;
pub const AV_DISPOSITION_DEFAULT: libc::c_int = 1;
pub const AV_DISPOSITION_DUB: libc::c_int = 2;
pub const AV_DISPOSITION_ORIGINAL: libc::c_int = 4;
pub const AV_DISPOSITION_COMMENT: libc::c_int = 8;
pub const AV_DISPOSITION_LYRICS: libc::c_int = 16;
pub const AV_DISPOSITION_KARAOKE: libc::c_int = 32;
pub const AV_DISPOSITION_FORCED: libc::c_int = 64;
pub const AV_DISPOSITION_HEARING_IMPAIRED: libc::c_int = 128;
pub const AV_DISPOSITION_VISUAL_IMPAIRED: libc::c_int = 256;
pub const AV_DISPOSITION_CLEAN_EFFECTS: libc::c_int = 512;
pub const AV_DISPOSITION_ATTACHED_PIC: libc::c_int = 1024;
pub const AV_DISPOSITION_TIMED_THUMBNAILS: libc::c_int = 2048;
pub const AV_DISPOSITION_CAPTIONS: libc::c_int = 65536;
pub const AV_DISPOSITION_DESCRIPTIONS: libc::c_int = 131072;
pub const AV_DISPOSITION_METADATA: libc::c_int = 262144;
pub const AV_PTS_WRAP_IGNORE: libc::c_int = 0;
pub const AV_PTS_WRAP_ADD_OFFSET: libc::c_int = 1;
pub const AV_PTS_WRAP_SUB_OFFSET: libc::c_int = -1;
pub const AVSTREAM_EVENT_FLAG_METADATA_UPDATED: libc::c_int = 1;
pub const MAX_STD_TIMEBASES: libc::c_int = 399;
pub const MAX_REORDER_DELAY: libc::c_int = 16;
pub const AV_PROGRAM_RUNNING: libc::c_int = 1;
pub const AVFMTCTX_NOHEADER: libc::c_int = 1;
pub const AVFMT_FLAG_GENPTS: libc::c_int = 1;
pub const AVFMT_FLAG_IGNIDX: libc::c_int = 2;
pub const AVFMT_FLAG_NONBLOCK: libc::c_int = 4;
pub const AVFMT_FLAG_IGNDTS: libc::c_int = 8;
pub const AVFMT_FLAG_NOFILLIN: libc::c_int = 16;
pub const AVFMT_FLAG_NOPARSE: libc::c_int = 32;
pub const AVFMT_FLAG_NOBUFFER: libc::c_int = 64;
pub const AVFMT_FLAG_CUSTOM_IO: libc::c_int = 128;
pub const AVFMT_FLAG_DISCARD_CORRUPT: libc::c_int = 256;
pub const AVFMT_FLAG_FLUSH_PACKETS: libc::c_int = 512;
pub const AVFMT_FLAG_BITEXACT: libc::c_int = 1024;
pub const AVFMT_FLAG_MP4A_LATM: libc::c_int = 32768;
pub const AVFMT_FLAG_SORT_DTS: libc::c_int = 65536;
pub const AVFMT_FLAG_PRIV_OPT: libc::c_int = 131072;
pub const AVFMT_FLAG_KEEP_SIDE_DATA: libc::c_int = 262144;
pub const AVFMT_FLAG_FAST_SEEK: libc::c_int = 524288;
pub const AVFMT_FLAG_SHORTEST: libc::c_int = 1048576;
pub const AVFMT_FLAG_AUTO_BSF: libc::c_int = 2097152;
pub const FF_FDEBUG_TS: libc::c_int = 1;
pub const AVFMT_EVENT_FLAG_METADATA_UPDATED: libc::c_int = 1;
pub const AVFMT_AVOID_NEG_TS_AUTO: libc::c_int = -1;
pub const AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE: libc::c_int = 1;
pub const AVFMT_AVOID_NEG_TS_MAKE_ZERO: libc::c_int = 2;
pub const AVSEEK_FLAG_BACKWARD: libc::c_int = 1;
pub const AVSEEK_FLAG_BYTE: libc::c_int = 2;
pub const AVSEEK_FLAG_ANY: libc::c_int = 4;
pub const AVSEEK_FLAG_FRAME: libc::c_int = 8;
pub const AVSTREAM_INIT_IN_WRITE_HEADER: libc::c_int = 0;
pub const AVSTREAM_INIT_IN_INIT_OUTPUT: libc::c_int = 1;
pub const AV_FRAME_FILENAME_FLAGS_MULTIPLE: libc::c_int = 1;
pub const LIBAVFILTER_VERSION_MAJOR: libc::c_int = 6;
pub const LIBAVFILTER_VERSION_MINOR: libc::c_int = 107;
pub const LIBAVFILTER_VERSION_MICRO: libc::c_int = 100;
pub const AVFILTER_FLAG_DYNAMIC_INPUTS: libc::c_int = 1;
pub const AVFILTER_FLAG_DYNAMIC_OUTPUTS: libc::c_int = 2;
pub const AVFILTER_FLAG_SLICE_THREADS: libc::c_int = 4;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC: libc::c_int = 65536;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL: libc::c_int = 131072;
pub const AVFILTER_FLAG_SUPPORT_TIMELINE: libc::c_int = 196608;
pub const AVFILTER_THREAD_SLICE: libc::c_int = 1;
pub const AVFILTER_CMD_FLAG_ONE: libc::c_int = 1;
pub const AVFILTER_CMD_FLAG_FAST: libc::c_int = 2;
pub const AV_BUFFERSINK_FLAG_PEEK: libc::c_int = 1;
pub const AV_BUFFERSINK_FLAG_NO_REQUEST: libc::c_int = 2;
pub const LIBAVRESAMPLE_VERSION_MAJOR: libc::c_int = 3;
pub const LIBAVRESAMPLE_VERSION_MINOR: libc::c_int = 7;
pub const LIBAVRESAMPLE_VERSION_MICRO: libc::c_int = 0;
pub const AVRESAMPLE_MAX_CHANNELS: libc::c_int = 32;
pub const AV_BF_ROUNDS: libc::c_int = 16;
pub const AV_ESCAPE_FLAG_WHITESPACE: libc::c_int = 1;
pub const AV_ESCAPE_FLAG_STRICT: libc::c_int = 2;
pub const AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES: libc::c_int = 1;
pub const AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS: libc::c_int = 2;
pub const AV_UTF8_FLAG_ACCEPT_SURROGATES: libc::c_int = 4;
pub const AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES: libc::c_int = 8;
pub const AV_UTF8_FLAG_ACCEPT_ALL: libc::c_int = 7;
pub const AV_BPRINT_SIZE_AUTOMATIC: libc::c_int = 1;
pub const AV_BPRINT_SIZE_COUNT_ONLY: libc::c_int = 0;
pub const AV_HASH_MAX_SIZE: libc::c_int = 64;
pub const AV_PIX_FMT_FLAG_BE: libc::c_int = 1;
pub const AV_PIX_FMT_FLAG_PAL: libc::c_int = 2;
pub const AV_PIX_FMT_FLAG_BITSTREAM: libc::c_int = 4;
pub const AV_PIX_FMT_FLAG_HWACCEL: libc::c_int = 8;
pub const AV_PIX_FMT_FLAG_PLANAR: libc::c_int = 16;
pub const AV_PIX_FMT_FLAG_RGB: libc::c_int = 32;
pub const AV_PIX_FMT_FLAG_PSEUDOPAL: libc::c_int = 64;
pub const AV_PIX_FMT_FLAG_ALPHA: libc::c_int = 128;
pub const AV_PIX_FMT_FLAG_BAYER: libc::c_int = 256;
pub const AV_PIX_FMT_FLAG_FLOAT: libc::c_int = 512;
pub const FF_LOSS_RESOLUTION: libc::c_int = 1;
pub const FF_LOSS_DEPTH: libc::c_int = 2;
pub const FF_LOSS_COLORSPACE: libc::c_int = 4;
pub const FF_LOSS_ALPHA: libc::c_int = 8;
pub const FF_LOSS_COLORQUANT: libc::c_int = 16;
pub const FF_LOSS_CHROMA: libc::c_int = 32;
pub const AV_LZO_INPUT_DEPLETED: libc::c_int = 1;
pub const AV_LZO_OUTPUT_FULL: libc::c_int = 2;
pub const AV_LZO_INVALID_BACKPTR: libc::c_int = 4;
pub const AV_LZO_ERROR: libc::c_int = 8;
pub const AV_LZO_INPUT_PADDING: libc::c_int = 8;
pub const AV_LZO_OUTPUT_PADDING: libc::c_int = 12;
pub const AV_STEREO3D_FLAG_INVERT: libc::c_int = 1;
pub const AV_TIMECODE_STR_SIZE: libc::c_int = 23;
pub const LIBSWRESAMPLE_VERSION_MAJOR: libc::c_int = 2;
pub const LIBSWRESAMPLE_VERSION_MINOR: libc::c_int = 9;
pub const LIBSWRESAMPLE_VERSION_MICRO: libc::c_int = 100;
pub const SWR_FLAG_RESAMPLE: libc::c_int = 1;
pub const LIBSWSCALE_VERSION_MAJOR: libc::c_int = 4;
pub const LIBSWSCALE_VERSION_MINOR: libc::c_int = 8;
pub const LIBSWSCALE_VERSION_MICRO: libc::c_int = 100;
pub const SWS_FAST_BILINEAR: libc::c_int = 1;
pub const SWS_BILINEAR: libc::c_int = 2;
pub const SWS_BICUBIC: libc::c_int = 4;
pub const SWS_X: libc::c_int = 8;
pub const SWS_POINT: libc::c_int = 16;
pub const SWS_AREA: libc::c_int = 32;
pub const SWS_BICUBLIN: libc::c_int = 64;
pub const SWS_GAUSS: libc::c_int = 128;
pub const SWS_SINC: libc::c_int = 256;
pub const SWS_LANCZOS: libc::c_int = 512;
pub const SWS_SPLINE: libc::c_int = 1024;
pub const SWS_SRC_V_CHR_DROP_MASK: libc::c_int = 196608;
pub const SWS_SRC_V_CHR_DROP_SHIFT: libc::c_int = 16;
pub const SWS_PARAM_DEFAULT: libc::c_int = 123456;
pub const SWS_PRINT_INFO: libc::c_int = 4096;
pub const SWS_FULL_CHR_H_INT: libc::c_int = 8192;
pub const SWS_FULL_CHR_H_INP: libc::c_int = 16384;
pub const SWS_DIRECT_BGR: libc::c_int = 32768;
pub const SWS_ACCURATE_RND: libc::c_int = 262144;
pub const SWS_BITEXACT: libc::c_int = 524288;
pub const SWS_ERROR_DIFFUSION: libc::c_int = 8388608;
pub const SWS_MAX_REDUCE_CUTOFF: f64 = 0.002;
pub const SWS_CS_ITU709: libc::c_int = 1;
pub const SWS_CS_FCC: libc::c_int = 4;
pub const SWS_CS_ITU601: libc::c_int = 5;
pub const SWS_CS_ITU624: libc::c_int = 5;
pub const SWS_CS_SMPTE170M: libc::c_int = 5;
pub const SWS_CS_SMPTE240M: libc::c_int = 7;
pub const SWS_CS_DEFAULT: libc::c_int = 5;
pub const SWS_CS_BT2020: libc::c_int = 9;
pub type errno_t = libc::c_int;
extern "C" {
    pub fn __error() -> *mut libc::c_int;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_longlong;
pub type __uint64_t = libc::c_ulonglong;
pub type __darwin_intptr_t = libc::c_long;
pub type __darwin_natural_t = libc::c_uint;
pub type __darwin_ct_rune_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [libc::c_char; 128usize],
    pub _mbstateL: libc::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = libc::c_long;
pub type __darwin_size_t = libc::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = libc::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = libc::c_int;
pub type __darwin_clock_t = libc::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = libc::c_long;
pub type __darwin_time_t = libc::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = libc::c_uint;
pub type __darwin_fsfilcnt_t = libc::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __uint32_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [libc::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [libc::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    pub __arg: *mut libc::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_once_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: libc::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [libc::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = libc::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = libc::c_uchar;
pub type u_int16_t = libc::c_ushort;
pub type u_int32_t = libc::c_uint;
pub type u_int64_t = libc::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = libc::c_long;
pub type uintmax_t = libc::c_ulong;
extern "C" {
    /// Return the LIBAVUTIL_VERSION_INT constant.
    pub fn avutil_version() -> libc::c_uint;
}
extern "C" {
    /// Return an informative version string. This usually is the actual release
    /// version number or a git commit description. This string has no fixed format
    /// and can change any time. It should never be parsed by code.
    pub fn av_version_info() -> *const libc::c_char;
}
extern "C" {
    /// Return the libavutil build-time configuration.
    pub fn avutil_configuration() -> *const libc::c_char;
}
extern "C" {
    /// Return the libavutil license.
    pub fn avutil_license() -> *const libc::c_char;
}
#[repr(i32)]
/// @addtogroup lavu_media Media Type
/// @brief Media Type
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVMediaType {
    AVMEDIA_TYPE_UNKNOWN = -1,
    AVMEDIA_TYPE_VIDEO = 0,
    AVMEDIA_TYPE_AUDIO = 1,
    AVMEDIA_TYPE_DATA = 2,
    AVMEDIA_TYPE_SUBTITLE = 3,
    AVMEDIA_TYPE_ATTACHMENT = 4,
    AVMEDIA_TYPE_NB = 5,
}
extern "C" {
    /// Return a string describing the media_type enum, NULL if media_type
    /// is unknown.
    pub fn av_get_media_type_string(media_type: AVMediaType) -> *const libc::c_char;
}
#[repr(u32)]
/// @}
/// @}
/// @defgroup lavu_picture Image related
///
/// AVPicture types, pixel formats and basic image planes manipulation.
///
/// @{
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVPictureType {
    AV_PICTURE_TYPE_NONE = 0,
    AV_PICTURE_TYPE_I = 1,
    AV_PICTURE_TYPE_P = 2,
    AV_PICTURE_TYPE_B = 3,
    AV_PICTURE_TYPE_S = 4,
    AV_PICTURE_TYPE_SI = 5,
    AV_PICTURE_TYPE_SP = 6,
    AV_PICTURE_TYPE_BI = 7,
}
extern "C" {
    /// Return a single letter to describe the given picture type
    /// pict_type.
    ///
    /// @param[in] pict_type the picture type @return a single character
    /// representing the picture type, '?' if pict_type is unknown
    pub fn av_get_picture_type_char(pict_type: AVPictureType) -> libc::c_char;
}
pub type __darwin_nl_item = libc::c_int;
pub type __darwin_wctrans_t = libc::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type wchar_t = __darwin_wchar_t;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<imaxdiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: libc::c_int,
    ) -> uintmax_t;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __math_errhandling() -> libc::c_int;
}
extern "C" {
    pub fn __fpclassifyf(arg1: f32) -> libc::c_int;
}
extern "C" {
    pub fn __fpclassifyd(arg1: f64) -> libc::c_int;
}
extern "C" {
    pub fn __fpclassify(arg1: f64) -> libc::c_int;
}
extern "C" {
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    pub fn ldexpf(arg1: f32, arg2: libc::c_int) -> f32;
}
extern "C" {
    pub fn ldexp(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(arg1: f32, arg2: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn frexp(arg1: f64, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn frexpl(arg1: f64, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogbf(arg1: f32) -> libc::c_int;
}
extern "C" {
    pub fn ilogb(arg1: f64) -> libc::c_int;
}
extern "C" {
    pub fn ilogbl(arg1: f64) -> libc::c_int;
}
extern "C" {
    pub fn scalbnf(arg1: f32, arg2: libc::c_int) -> f32;
}
extern "C" {
    pub fn scalbn(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn scalbnl(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    pub fn scalblnf(arg1: f32, arg2: libc::c_long) -> f32;
}
extern "C" {
    pub fn scalbln(arg1: f64, arg2: libc::c_long) -> f64;
}
extern "C" {
    pub fn scalblnl(arg1: f64, arg2: libc::c_long) -> f64;
}
extern "C" {
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lrintf(arg1: f32) -> libc::c_long;
}
extern "C" {
    pub fn lrint(arg1: f64) -> libc::c_long;
}
extern "C" {
    pub fn lrintl(arg1: f64) -> libc::c_long;
}
extern "C" {
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lroundf(arg1: f32) -> libc::c_long;
}
extern "C" {
    pub fn lround(arg1: f64) -> libc::c_long;
}
extern "C" {
    pub fn lroundl(arg1: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrintf(arg1: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn llrint(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn llrintl(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn llroundf(arg1: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn llround(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn llroundl(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nanf(arg1: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn nan(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn nanl(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    pub fn __inff() -> f32;
}
extern "C" {
    pub fn __inf() -> f64;
}
extern "C" {
    pub fn __infl() -> f64;
}
extern "C" {
    pub fn __nan() -> f32;
}
extern "C" {
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tanpi(arg1: f64) -> f64;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub static mut signgam: libc::c_int;
}
extern "C" {
    pub fn rinttol(arg1: f64) -> libc::c_long;
}
extern "C" {
    pub fn roundtol(arg1: f64) -> libc::c_long;
}
extern "C" {
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    pub fn finite(arg1: f64) -> libc::c_int;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn significand(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct exception {
    pub type_: libc::c_int,
    pub name: *mut libc::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(
        ::std::mem::size_of::<exception>(),
        40usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::std::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).arg1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).arg2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<exception>())).retval as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    pub fn matherr(arg1: *mut exception) -> libc::c_int;
}
pub type va_list = __darwin_va_list;
extern "C" {
    pub fn renameat(
        arg1: libc::c_int,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn renamex_np(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn renameatx_np(
        arg1: libc::c_int,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
        arg4: *const libc::c_char,
        arg5: libc::c_uint,
    ) -> libc::c_int;
}
pub type fpos_t = __darwin_off_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __sbuf {
    pub _base: *mut libc::c_uchar,
    pub _size: libc::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    assert_eq!(
        ::std::mem::size_of::<__sbuf>(),
        16usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::std::mem::align_of::<__sbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sbuf>()))._size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sFILEX {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __sFILE {
    pub _p: *mut libc::c_uchar,
    pub _r: libc::c_int,
    pub _w: libc::c_int,
    pub _flags: libc::c_short,
    pub _file: libc::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: libc::c_int,
    pub _cookie: *mut libc::c_void,
    pub _close: ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_int>,
    pub _read: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: *mut libc::c_char, arg3: libc::c_int)
            -> libc::c_int,
    >,
    pub _seek: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: fpos_t, arg3: libc::c_int) -> fpos_t,
    >,
    pub _write: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: *const libc::c_char, arg3: libc::c_int)
            -> libc::c_int,
    >,
    pub _ub: __sbuf,
    pub _extra: *mut __sFILEX,
    pub _ur: libc::c_int,
    pub _ubuf: [libc::c_uchar; 3usize],
    pub _nbuf: [libc::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: libc::c_int,
    pub _offset: fpos_t,
}
#[test]
fn bindgen_test_layout___sFILE() {
    assert_eq!(
        ::std::mem::size_of::<__sFILE>(),
        152usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<__sFILE>(),
        8usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._r as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._w as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._file as *const _ as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._bf as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lbfsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._cookie as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._close as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._read as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._seek as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._write as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ub as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._extra as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ur as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._ubuf as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._nbuf as *const _ as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._lb as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._blksize as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sFILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
}
pub type FILE = __sFILE;
extern "C" {
    pub static mut __stdinp: *mut FILE;
}
extern "C" {
    pub static mut __stdoutp: *mut FILE;
}
extern "C" {
    pub static mut __stderrp: *mut FILE;
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut libc::c_char, arg2: libc::c_int, arg3: *mut FILE) -> *mut libc::c_char;
}
extern "C" {
    pub fn fopen(__filename: *const libc::c_char, __mode: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn fputc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const libc::c_char, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut libc::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn freopen(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: libc::c_long, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const libc::c_void,
        __size: usize,
        __nitems: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar() -> libc::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn perror(arg1: *const libc::c_char);
}
extern "C" {
    pub fn printf(arg1: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn putc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn puts(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn remove(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn rename(__old: *const libc::c_char, __new: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn scanf(arg1: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut libc::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut libc::c_char,
        arg3: libc::c_int,
        arg4: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn sprintf(arg1: *mut libc::c_char, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const libc::c_char, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn ungetc(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const libc::c_char,
        arg3: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const libc::c_char, arg2: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ctermid(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn fdopen(arg1: libc::c_int, arg2: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn popen(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn __srget(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn __svfscanf(
        arg1: *mut FILE,
        arg2: *const libc::c_char,
        arg3: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn __swbuf(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> libc::c_int;
}
extern "C" {
    pub fn putc_unlocked(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putw(arg1: libc::c_int, arg2: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn tempnam(__dir: *const libc::c_char, __prefix: *const libc::c_char) -> *mut libc::c_char;
}
pub type off_t = __darwin_off_t;
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __offset: off_t, __whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        __str: *mut libc::c_char,
        __size: usize,
        __format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn vfscanf(
        __stream: *mut FILE,
        __format: *const libc::c_char,
        arg1: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const libc::c_char, arg1: *mut __va_list_tag) -> libc::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __str: *mut libc::c_char,
        __size: usize,
        __format: *const libc::c_char,
        arg1: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vsscanf(
        __str: *const libc::c_char,
        __format: *const libc::c_char,
        arg1: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn dprintf(arg1: libc::c_int, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vdprintf(
        arg1: libc::c_int,
        arg2: *const libc::c_char,
        arg3: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn getdelim(
        __linep: *mut *mut libc::c_char,
        __linecapp: *mut usize,
        __delimiter: libc::c_int,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn getline(
        __linep: *mut *mut libc::c_char,
        __linecapp: *mut usize,
        __stream: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn fmemopen(
        __buf: *mut libc::c_void,
        __size: usize,
        __mode: *const libc::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufp: *mut *mut libc::c_char, __sizep: *mut usize) -> *mut FILE;
}
extern "C" {
    pub static mut sys_nerr: libc::c_int;
}
extern "C" {
    pub static mut sys_errlist: [*const libc::c_char; 0usize];
}
extern "C" {
    pub fn asprintf(arg1: *mut *mut libc::c_char, arg2: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn ctermid_r(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn fgetln(arg1: *mut FILE, arg2: *mut usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn fmtcheck(arg1: *const libc::c_char, arg2: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut libc::c_char, arg3: libc::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut __va_list_tag,
    ) -> libc::c_int;
}
extern "C" {
    pub fn zopen(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> *mut FILE;
}
extern "C" {
    pub fn funopen(
        arg1: *const libc::c_void,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_char,
                arg3: libc::c_int,
            ) -> libc::c_int,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *const libc::c_char,
                arg3: libc::c_int,
            ) -> libc::c_int,
        >,
        arg4: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: fpos_t, arg3: libc::c_int)
                -> fpos_t,
        >,
        arg5: ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_int>,
    ) -> *mut FILE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum idtype_t {
    P_ALL = 0,
    P_PID = 1,
    P_PGID = 2,
}
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_i386_thread_state {
    pub __eax: libc::c_uint,
    pub __ebx: libc::c_uint,
    pub __ecx: libc::c_uint,
    pub __edx: libc::c_uint,
    pub __edi: libc::c_uint,
    pub __esi: libc::c_uint,
    pub __ebp: libc::c_uint,
    pub __esp: libc::c_uint,
    pub __ss: libc::c_uint,
    pub __eflags: libc::c_uint,
    pub __eip: libc::c_uint,
    pub __cs: libc::c_uint,
    pub __ds: libc::c_uint,
    pub __es: libc::c_uint,
    pub __fs: libc::c_uint,
    pub __gs: libc::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_i386_thread_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_thread_state>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_thread_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebx as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ecx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ecx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edx as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__edi as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__edi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esi as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ebp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ebp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__esp as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__esp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eflags as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__eip as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__cs as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__ds as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__ds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__es as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__fs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_i386_thread_state>())).__gs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_thread_state),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_fp_control {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_control() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_control>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_control))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_control>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_control))
    );
}
impl __darwin_fp_control {
    #[inline]
    pub fn __invalid(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __pc(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___pc(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn __rc(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set___rc(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: libc::c_ushort,
        __denorm: libc::c_ushort,
        __zdiv: libc::c_ushort,
        __ovrfl: libc::c_ushort,
        __undfl: libc::c_ushort,
        __precis: libc::c_ushort,
        __pc: libc::c_ushort,
        __rc: libc::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(8usize, 2u8, {
            let __pc: u16 = unsafe { ::std::mem::transmute(__pc) };
            __pc as u64
        });
        __bindgen_bitfield_unit.set(10usize, 2u8, {
            let __rc: u16 = unsafe { ::std::mem::transmute(__rc) };
            __rc as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_control_t = __darwin_fp_control;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_fp_status {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout___darwin_fp_status() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_fp_status>(),
        2usize,
        concat!("Size of: ", stringify!(__darwin_fp_status))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_fp_status>(),
        2usize,
        concat!("Alignment of ", stringify!(__darwin_fp_status))
    );
}
impl __darwin_fp_status {
    #[inline]
    pub fn __invalid(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___invalid(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __denorm(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___denorm(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __zdiv(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___zdiv(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __ovrfl(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___ovrfl(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __undfl(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___undfl(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __precis(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___precis(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __stkflt(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___stkflt(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __errsumm(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___errsumm(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c0(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c0(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c1(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c1(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __c2(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c2(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __tos(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set___tos(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn __c3(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___c3(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn __busy(&self) -> libc::c_ushort {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set___busy(&mut self, val: libc::c_ushort) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        __invalid: libc::c_ushort,
        __denorm: libc::c_ushort,
        __zdiv: libc::c_ushort,
        __ovrfl: libc::c_ushort,
        __undfl: libc::c_ushort,
        __precis: libc::c_ushort,
        __stkflt: libc::c_ushort,
        __errsumm: libc::c_ushort,
        __c0: libc::c_ushort,
        __c1: libc::c_ushort,
        __c2: libc::c_ushort,
        __tos: libc::c_ushort,
        __c3: libc::c_ushort,
        __busy: libc::c_ushort,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let __invalid: u16 = unsafe { ::std::mem::transmute(__invalid) };
            __invalid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let __denorm: u16 = unsafe { ::std::mem::transmute(__denorm) };
            __denorm as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let __zdiv: u16 = unsafe { ::std::mem::transmute(__zdiv) };
            __zdiv as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let __ovrfl: u16 = unsafe { ::std::mem::transmute(__ovrfl) };
            __ovrfl as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let __undfl: u16 = unsafe { ::std::mem::transmute(__undfl) };
            __undfl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let __precis: u16 = unsafe { ::std::mem::transmute(__precis) };
            __precis as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let __stkflt: u16 = unsafe { ::std::mem::transmute(__stkflt) };
            __stkflt as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let __errsumm: u16 = unsafe { ::std::mem::transmute(__errsumm) };
            __errsumm as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let __c0: u16 = unsafe { ::std::mem::transmute(__c0) };
            __c0 as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let __c1: u16 = unsafe { ::std::mem::transmute(__c1) };
            __c1 as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let __c2: u16 = unsafe { ::std::mem::transmute(__c2) };
            __c2 as u64
        });
        __bindgen_bitfield_unit.set(11usize, 3u8, {
            let __tos: u16 = unsafe { ::std::mem::transmute(__tos) };
            __tos as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let __c3: u16 = unsafe { ::std::mem::transmute(__c3) };
            __c3 as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let __busy: u16 = unsafe { ::std::mem::transmute(__busy) };
            __busy as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type __darwin_fp_status_t = __darwin_fp_status;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_mmst_reg {
    pub __mmst_reg: [libc::c_char; 10usize],
    pub __mmst_rsrv: [libc::c_char; 6usize],
}
#[test]
fn bindgen_test_layout___darwin_mmst_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mmst_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mmst_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_mmst_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_reg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mmst_reg>())).__mmst_rsrv as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mmst_reg),
            "::",
            stringify!(__mmst_rsrv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_xmm_reg {
    pub __xmm_reg: [libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_xmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_xmm_reg>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_xmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_xmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_xmm_reg>())).__xmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_xmm_reg),
            "::",
            stringify!(__xmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_ymm_reg {
    pub __ymm_reg: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout___darwin_ymm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ymm_reg>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ymm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_ymm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ymm_reg>())).__ymm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ymm_reg),
            "::",
            stringify!(__ymm_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_zmm_reg {
    pub __zmm_reg: [libc::c_char; 64usize],
}
#[test]
fn bindgen_test_layout___darwin_zmm_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_zmm_reg>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_zmm_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_zmm_reg))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_zmm_reg>())).__zmm_reg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_zmm_reg),
            "::",
            stringify!(__zmm_reg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_opmask_reg {
    pub __opmask_reg: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout___darwin_opmask_reg() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_opmask_reg>(),
        8usize,
        concat!("Size of: ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_opmask_reg>(),
        1usize,
        concat!("Alignment of ", stringify!(__darwin_opmask_reg))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_opmask_reg>())).__opmask_reg as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_opmask_reg),
            "::",
            stringify!(__opmask_reg)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_float_state {
    pub __fpu_reserved: [libc::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [libc::c_char; 224usize],
    pub __fpu_reserved1: libc::c_int,
}
#[test]
fn bindgen_test_layout___darwin_i386_float_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_float_state>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_float_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_float_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_float_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_float_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx_state {
    pub __fpu_reserved: [libc::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [libc::c_char; 224usize],
    pub __fpu_reserved1: libc::c_int,
    pub __avx_reserved1: [libc::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx_state>(),
        716usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_mxcsrmask as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_reserved1 as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__avx_reserved1 as *const _ as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_i386_avx512_state {
    pub __fpu_reserved: [libc::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_rsrv4: [libc::c_char; 224usize],
    pub __fpu_reserved1: libc::c_int,
    pub __avx_reserved1: [libc::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
}
#[test]
fn bindgen_test_layout___darwin_i386_avx512_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_avx512_state>(),
        1036usize,
        concat!("Size of: ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_avx512_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_avx512_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_rsrv4 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k0 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k1 as *const _ as usize
        },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k2 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k3 as *const _ as usize
        },
        740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k4 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k5 as *const _ as usize
        },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k6 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_k7 as *const _ as usize
        },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh0 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh1 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh2 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh3 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh4 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh5 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh6 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_avx512_state>())).__fpu_zmmh7 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_avx512_state),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_i386_exception_state {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_i386_exception_state() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_i386_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_i386_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_i386_exception_state))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_i386_exception_state>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_i386_exception_state),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_x86_debug_state32 {
    pub __dr0: libc::c_uint,
    pub __dr1: libc::c_uint,
    pub __dr2: libc::c_uint,
    pub __dr3: libc::c_uint,
    pub __dr4: libc::c_uint,
    pub __dr5: libc::c_uint,
    pub __dr6: libc::c_uint,
    pub __dr7: libc::c_uint,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state32>(),
        32usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr1 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr3 as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr4 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr5 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr6 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state32>())).__dr7 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state32),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_x86_thread_state64 {
    pub __rax: __uint64_t,
    pub __rbx: __uint64_t,
    pub __rcx: __uint64_t,
    pub __rdx: __uint64_t,
    pub __rdi: __uint64_t,
    pub __rsi: __uint64_t,
    pub __rbp: __uint64_t,
    pub __rsp: __uint64_t,
    pub __r8: __uint64_t,
    pub __r9: __uint64_t,
    pub __r10: __uint64_t,
    pub __r11: __uint64_t,
    pub __r12: __uint64_t,
    pub __r13: __uint64_t,
    pub __r14: __uint64_t,
    pub __r15: __uint64_t,
    pub __rip: __uint64_t,
    pub __rflags: __uint64_t,
    pub __cs: __uint64_t,
    pub __fs: __uint64_t,
    pub __gs: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_thread_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_thread_state64>(),
        168usize,
        concat!("Size of: ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_thread_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rcx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rdi as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsi as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rbp as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rsp as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r8 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r9 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r10 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r11 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r12 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r13 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r14 as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__r15 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__r15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rip as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__rflags as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__rflags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__cs as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__fs as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__fs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_thread_state64>())).__gs as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_thread_state64),
            "::",
            stringify!(__gs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_float_state64 {
    pub __fpu_reserved: [libc::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [libc::c_char; 96usize],
    pub __fpu_reserved1: libc::c_int,
}
#[test]
fn bindgen_test_layout___darwin_x86_float_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_float_state64>(),
        524usize,
        concat!("Size of: ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_float_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_float_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_float_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_float_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx_state64 {
    pub __fpu_reserved: [libc::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [libc::c_char; 96usize],
    pub __fpu_reserved1: libc::c_int,
    pub __avx_reserved1: [libc::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx_state64>(),
        844usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh10 as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh11 as *const _ as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh12 as *const _ as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh13 as *const _ as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh14 as *const _ as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx_state64>())).__fpu_ymmh15 as *const _ as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_x86_avx512_state64 {
    pub __fpu_reserved: [libc::c_int; 2usize],
    pub __fpu_fcw: __darwin_fp_control,
    pub __fpu_fsw: __darwin_fp_status,
    pub __fpu_ftw: __uint8_t,
    pub __fpu_rsrv1: __uint8_t,
    pub __fpu_fop: __uint16_t,
    pub __fpu_ip: __uint32_t,
    pub __fpu_cs: __uint16_t,
    pub __fpu_rsrv2: __uint16_t,
    pub __fpu_dp: __uint32_t,
    pub __fpu_ds: __uint16_t,
    pub __fpu_rsrv3: __uint16_t,
    pub __fpu_mxcsr: __uint32_t,
    pub __fpu_mxcsrmask: __uint32_t,
    pub __fpu_stmm0: __darwin_mmst_reg,
    pub __fpu_stmm1: __darwin_mmst_reg,
    pub __fpu_stmm2: __darwin_mmst_reg,
    pub __fpu_stmm3: __darwin_mmst_reg,
    pub __fpu_stmm4: __darwin_mmst_reg,
    pub __fpu_stmm5: __darwin_mmst_reg,
    pub __fpu_stmm6: __darwin_mmst_reg,
    pub __fpu_stmm7: __darwin_mmst_reg,
    pub __fpu_xmm0: __darwin_xmm_reg,
    pub __fpu_xmm1: __darwin_xmm_reg,
    pub __fpu_xmm2: __darwin_xmm_reg,
    pub __fpu_xmm3: __darwin_xmm_reg,
    pub __fpu_xmm4: __darwin_xmm_reg,
    pub __fpu_xmm5: __darwin_xmm_reg,
    pub __fpu_xmm6: __darwin_xmm_reg,
    pub __fpu_xmm7: __darwin_xmm_reg,
    pub __fpu_xmm8: __darwin_xmm_reg,
    pub __fpu_xmm9: __darwin_xmm_reg,
    pub __fpu_xmm10: __darwin_xmm_reg,
    pub __fpu_xmm11: __darwin_xmm_reg,
    pub __fpu_xmm12: __darwin_xmm_reg,
    pub __fpu_xmm13: __darwin_xmm_reg,
    pub __fpu_xmm14: __darwin_xmm_reg,
    pub __fpu_xmm15: __darwin_xmm_reg,
    pub __fpu_rsrv4: [libc::c_char; 96usize],
    pub __fpu_reserved1: libc::c_int,
    pub __avx_reserved1: [libc::c_char; 64usize],
    pub __fpu_ymmh0: __darwin_xmm_reg,
    pub __fpu_ymmh1: __darwin_xmm_reg,
    pub __fpu_ymmh2: __darwin_xmm_reg,
    pub __fpu_ymmh3: __darwin_xmm_reg,
    pub __fpu_ymmh4: __darwin_xmm_reg,
    pub __fpu_ymmh5: __darwin_xmm_reg,
    pub __fpu_ymmh6: __darwin_xmm_reg,
    pub __fpu_ymmh7: __darwin_xmm_reg,
    pub __fpu_ymmh8: __darwin_xmm_reg,
    pub __fpu_ymmh9: __darwin_xmm_reg,
    pub __fpu_ymmh10: __darwin_xmm_reg,
    pub __fpu_ymmh11: __darwin_xmm_reg,
    pub __fpu_ymmh12: __darwin_xmm_reg,
    pub __fpu_ymmh13: __darwin_xmm_reg,
    pub __fpu_ymmh14: __darwin_xmm_reg,
    pub __fpu_ymmh15: __darwin_xmm_reg,
    pub __fpu_k0: __darwin_opmask_reg,
    pub __fpu_k1: __darwin_opmask_reg,
    pub __fpu_k2: __darwin_opmask_reg,
    pub __fpu_k3: __darwin_opmask_reg,
    pub __fpu_k4: __darwin_opmask_reg,
    pub __fpu_k5: __darwin_opmask_reg,
    pub __fpu_k6: __darwin_opmask_reg,
    pub __fpu_k7: __darwin_opmask_reg,
    pub __fpu_zmmh0: __darwin_ymm_reg,
    pub __fpu_zmmh1: __darwin_ymm_reg,
    pub __fpu_zmmh2: __darwin_ymm_reg,
    pub __fpu_zmmh3: __darwin_ymm_reg,
    pub __fpu_zmmh4: __darwin_ymm_reg,
    pub __fpu_zmmh5: __darwin_ymm_reg,
    pub __fpu_zmmh6: __darwin_ymm_reg,
    pub __fpu_zmmh7: __darwin_ymm_reg,
    pub __fpu_zmmh8: __darwin_ymm_reg,
    pub __fpu_zmmh9: __darwin_ymm_reg,
    pub __fpu_zmmh10: __darwin_ymm_reg,
    pub __fpu_zmmh11: __darwin_ymm_reg,
    pub __fpu_zmmh12: __darwin_ymm_reg,
    pub __fpu_zmmh13: __darwin_ymm_reg,
    pub __fpu_zmmh14: __darwin_ymm_reg,
    pub __fpu_zmmh15: __darwin_ymm_reg,
    pub __fpu_zmm16: __darwin_zmm_reg,
    pub __fpu_zmm17: __darwin_zmm_reg,
    pub __fpu_zmm18: __darwin_zmm_reg,
    pub __fpu_zmm19: __darwin_zmm_reg,
    pub __fpu_zmm20: __darwin_zmm_reg,
    pub __fpu_zmm21: __darwin_zmm_reg,
    pub __fpu_zmm22: __darwin_zmm_reg,
    pub __fpu_zmm23: __darwin_zmm_reg,
    pub __fpu_zmm24: __darwin_zmm_reg,
    pub __fpu_zmm25: __darwin_zmm_reg,
    pub __fpu_zmm26: __darwin_zmm_reg,
    pub __fpu_zmm27: __darwin_zmm_reg,
    pub __fpu_zmm28: __darwin_zmm_reg,
    pub __fpu_zmm29: __darwin_zmm_reg,
    pub __fpu_zmm30: __darwin_zmm_reg,
    pub __fpu_zmm31: __darwin_zmm_reg,
}
#[test]
fn bindgen_test_layout___darwin_x86_avx512_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_avx512_state64>(),
        2444usize,
        concat!("Size of: ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_avx512_state64>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_x86_avx512_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fcw as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fcw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fsw as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fsw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ftw as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ftw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv1 as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_fop as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_fop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ip as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_cs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_cs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv2 as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_dp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_dp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ds as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv3 as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_mxcsrmask as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_mxcsrmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm0 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm1 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm3 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm4 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm5 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm6 as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_stmm7 as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_stmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm0 as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm1 as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm2 as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm3 as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm4 as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm5 as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm6 as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm7 as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm8 as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm9 as *const _ as usize
        },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm10 as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm11 as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm12 as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm13 as *const _ as usize
        },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm14 as *const _ as usize
        },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_xmm15 as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_xmm15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_rsrv4 as *const _ as usize
        },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_rsrv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_reserved1 as *const _
                as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__avx_reserved1 as *const _
                as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__avx_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh0 as *const _ as usize
        },
        588usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh1 as *const _ as usize
        },
        604usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh2 as *const _ as usize
        },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh3 as *const _ as usize
        },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh4 as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh5 as *const _ as usize
        },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh6 as *const _ as usize
        },
        684usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh7 as *const _ as usize
        },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh8 as *const _ as usize
        },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh9 as *const _ as usize
        },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh10 as *const _
                as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh11 as *const _
                as usize
        },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh12 as *const _
                as usize
        },
        780usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh13 as *const _
                as usize
        },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh14 as *const _
                as usize
        },
        812usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_ymmh15 as *const _
                as usize
        },
        828usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_ymmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k0 as *const _ as usize
        },
        844usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k1 as *const _ as usize
        },
        852usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k2 as *const _ as usize
        },
        860usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k3 as *const _ as usize
        },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k4 as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k5 as *const _ as usize
        },
        884usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k6 as *const _ as usize
        },
        892usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_k7 as *const _ as usize
        },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_k7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh0 as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh1 as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh2 as *const _ as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh3 as *const _ as usize
        },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh4 as *const _ as usize
        },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh5 as *const _ as usize
        },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh6 as *const _ as usize
        },
        1100usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh7 as *const _ as usize
        },
        1132usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh8 as *const _ as usize
        },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh9 as *const _ as usize
        },
        1196usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh10 as *const _
                as usize
        },
        1228usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh11 as *const _
                as usize
        },
        1260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh12 as *const _
                as usize
        },
        1292usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh13 as *const _
                as usize
        },
        1324usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh14 as *const _
                as usize
        },
        1356usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmmh15 as *const _
                as usize
        },
        1388usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmmh15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm16 as *const _ as usize
        },
        1420usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm17 as *const _ as usize
        },
        1484usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm17)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm18 as *const _ as usize
        },
        1548usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm18)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm19 as *const _ as usize
        },
        1612usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm20 as *const _ as usize
        },
        1676usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm21 as *const _ as usize
        },
        1740usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm22 as *const _ as usize
        },
        1804usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm23 as *const _ as usize
        },
        1868usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm24 as *const _ as usize
        },
        1932usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm25 as *const _ as usize
        },
        1996usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm26 as *const _ as usize
        },
        2060usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm27 as *const _ as usize
        },
        2124usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm27)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm28 as *const _ as usize
        },
        2188usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm28)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm29 as *const _ as usize
        },
        2252usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm29)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm30 as *const _ as usize
        },
        2316usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm30)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_avx512_state64>())).__fpu_zmm31 as *const _ as usize
        },
        2380usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_avx512_state64),
            "::",
            stringify!(__fpu_zmm31)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_x86_exception_state64 {
    pub __trapno: __uint16_t,
    pub __cpu: __uint16_t,
    pub __err: __uint32_t,
    pub __faultvaddr: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_exception_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_exception_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__trapno as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__trapno)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__cpu as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__cpu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__err as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__err)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_exception_state64>())).__faultvaddr as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_exception_state64),
            "::",
            stringify!(__faultvaddr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_x86_debug_state64 {
    pub __dr0: __uint64_t,
    pub __dr1: __uint64_t,
    pub __dr2: __uint64_t,
    pub __dr3: __uint64_t,
    pub __dr4: __uint64_t,
    pub __dr5: __uint64_t,
    pub __dr6: __uint64_t,
    pub __dr7: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_x86_debug_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_debug_state64>(),
        64usize,
        concat!("Size of: ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_debug_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr3 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr4 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr5 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr6 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_debug_state64>())).__dr7 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_debug_state64),
            "::",
            stringify!(__dr7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_x86_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_x86_cpmu_state64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_x86_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_x86_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_x86_cpmu_state64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_x86_cpmu_state64>())).__ctrs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_x86_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_float_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        600usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx32>(),
        792usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__ss as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx32>())).__fs as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_32 {
    pub __es: __darwin_i386_exception_state,
    pub __ss: __darwin_i386_thread_state,
    pub __fs: __darwin_i386_avx512_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_32() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_32>(),
        1112usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__ss as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_32>())).__fs as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_float_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        712usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx64>(),
        1032usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__es as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__ss as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_mcontext_avx64>())).__fs as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx64),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __darwin_mcontext_avx512_64 {
    pub __es: __darwin_x86_exception_state64,
    pub __ss: __darwin_x86_thread_state64,
    pub __fs: __darwin_x86_avx512_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext_avx512_64() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext_avx512_64>(),
        2632usize,
        concat!("Size of: ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext_avx512_64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext_avx512_64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__es as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__ss as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_mcontext_avx512_64>())).__fs as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext_avx512_64),
            "::",
            stringify!(__fs)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut libc::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: libc::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_sigaltstack>())).ss_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __darwin_ucontext {
    pub uc_onstack: libc::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_onstack as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_sigmask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_stack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_link as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcsize as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__darwin_ucontext>())).uc_mcontext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: libc::c_int,
    pub sival_ptr: *mut libc::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_sigval() {
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_int as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigval>())).sival_ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: libc::c_int,
    pub sigev_signo: libc::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_signo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigevent>())).sigev_notify_function as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<sigevent>())).sigev_notify_attributes as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: libc::c_int,
    pub si_errno: libc::c_int,
    pub si_code: libc::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: libc::c_int,
    pub si_addr: *mut libc::c_void,
    pub si_value: sigval,
    pub si_band: libc::c_long,
    pub __pad: [libc::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_signo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_errno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_code as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_pid as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_uid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_value as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).si_band as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__siginfo>())).__pad as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(arg1: libc::c_int, arg2: *mut __siginfo, arg3: *mut libc::c_void),
    >,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction_u>())).__sa_sigaction as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut libc::c_void,
            arg2: libc::c_int,
            arg3: libc::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut libc::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: libc::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_tramp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigaction>())).sa_flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: libc::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).__sigaction_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigaction>())).sa_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>,
    pub sv_mask: libc::c_int,
    pub sv_flags: libc::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_handler as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigvec>())).sv_flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct sigstack {
    pub ss_sp: *mut libc::c_char,
    pub ss_onstack: libc::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_sp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sigstack>())).ss_onstack as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: libc::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: libc::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: libc::c_int)>,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: libc::c_long,
    pub ru_ixrss: libc::c_long,
    pub ru_idrss: libc::c_long,
    pub ru_isrss: libc::c_long,
    pub ru_minflt: libc::c_long,
    pub ru_majflt: libc::c_long,
    pub ru_nswap: libc::c_long,
    pub ru_inblock: libc::c_long,
    pub ru_oublock: libc::c_long,
    pub ru_msgsnd: libc::c_long,
    pub ru_msgrcv: libc::c_long,
    pub ru_nsignals: libc::c_long,
    pub ru_nvcsw: libc::c_long,
    pub ru_nivcsw: libc::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v0>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v0>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v1>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v2>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v3>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_unused: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_uuid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_user_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_system_time as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_pkg_idle_wkups as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_interrupt_wkups as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_pageins as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_wired_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_resident_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_phys_footprint as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_start_abstime as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_proc_exit_abstime as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_user_time as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_system_time as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pkg_idle_wkups as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_interrupt_wkups as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_pageins as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_child_elapsed_abstime as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_bytesread as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_diskio_byteswritten as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_default as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_maintenance as *const _
                as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_background as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_utility as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_legacy as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_initiated as *const _
                as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_cpu_time_qos_user_interactive as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_system_time as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_system_time as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_logical_writes as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_lifetime_max_phys_footprint as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_instructions as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_cycles as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_billed_energy as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rusage_info_v4>())).ri_serviced_energy as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rusage_info_v4>())).ri_unused as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_unused)
        )
    );
}
pub type rusage_info_current = rusage_info_v4;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<proc_rlimit_control_wakeupmon>())).wm_rate as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: libc::c_int, arg2: id_t) -> libc::c_int;
}
extern "C" {
    pub fn getiopolicy_np(arg1: libc::c_int, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: libc::c_int, arg2: *mut rlimit) -> libc::c_int;
}
extern "C" {
    pub fn getrusage(arg1: libc::c_int, arg2: *mut rusage) -> libc::c_int;
}
extern "C" {
    pub fn setpriority(arg1: libc::c_int, arg2: id_t, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn setiopolicy_np(arg1: libc::c_int, arg2: libc::c_int, arg3: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: libc::c_int, arg2: *const rlimit) -> libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: libc::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: libc::c_uint,
        w_Coredump: libc::c_uint,
        w_Retcode: libc::c_uint,
        w_Filler: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: libc::c_uint,
        w_Stopsig: libc::c_uint,
        w_Filler: libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_status as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_T as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<wait>())).w_S as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    pub fn wait(arg1: *mut libc::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(arg1: pid_t, arg2: *mut libc::c_int, arg3: libc::c_int) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn wait3(arg1: *mut libc::c_int, arg2: libc::c_int, arg3: *mut rusage) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut libc::c_int,
        arg3: libc::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: usize) -> *mut libc::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: libc::c_int;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn abs(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn atof(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn atol(arg1: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const libc::c_void,
        __base: *const libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void)
                -> libc::c_int,
        >,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn calloc(__count: usize, __size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn div(arg1: libc::c_int, arg2: libc::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: libc::c_int);
}
extern "C" {
    pub fn free(arg1: *mut libc::c_void);
}
extern "C" {
    pub fn getenv(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn labs(arg1: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn ldiv(arg1: libc::c_long, arg2: libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: libc::c_longlong) -> libc::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: libc::c_longlong, arg2: libc::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn mblen(__s: *const libc::c_char, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const libc::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const libc::c_char, arg3: usize) -> libc::c_int;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut libc::c_void,
        __alignment: usize,
        __size: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void)
                -> libc::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> libc::c_int;
}
extern "C" {
    pub fn realloc(__ptr: *mut libc::c_void, __size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn srand(arg1: libc::c_uint);
}
extern "C" {
    pub fn strtod(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn strtold(arg1: *const libc::c_char, arg2: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut libc::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut libc::c_char, arg2: wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn _Exit(arg1: libc::c_int);
}
extern "C" {
    pub fn a64l(arg1: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut libc::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: libc::c_int,
        arg3: *mut libc::c_int,
        arg4: *mut libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn gcvt(arg1: f64, arg2: libc::c_int, arg3: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut libc::c_char,
        arg2: *const *const libc::c_char,
        arg3: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn grantpt(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn initstate(arg1: libc::c_uint, arg2: *mut libc::c_char, arg3: usize)
        -> *mut libc::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn l64a(arg1: libc::c_long) -> *mut libc::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut libc::c_ushort);
}
extern "C" {
    pub fn lrand48() -> libc::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn mrand48() -> libc::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut libc::c_ushort) -> libc::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ptsname(arg1: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn ptsname_r(fildes: libc::c_int, buffer: *mut libc::c_char, buflen: usize) -> libc::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn random() -> libc::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn realpath(arg1: *const libc::c_char, arg2: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const libc::c_char,
        __value: *const libc::c_char,
        __overwrite: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const libc::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn srand48(arg1: libc::c_long);
}
extern "C" {
    pub fn srandom(arg1: libc::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const libc::c_char) -> libc::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut libc::c_uchar, arg2: libc::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut libc::c_void, __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut libc::c_void) -> libc::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const libc::c_void,
        __base: *const libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn cgetclose() -> libc::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut libc::c_char,
        arg2: *mut *mut libc::c_char,
        arg3: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn cgetfirst(arg1: *mut *mut libc::c_char, arg2: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn cgetmatch(arg1: *const libc::c_char, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn cgetnext(arg1: *mut *mut libc::c_char, arg2: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut libc::c_long,
    ) -> libc::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn daemon(arg1: libc::c_int, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut libc::c_char,
        len: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn getbsize(arg1: *mut libc::c_int, arg2: *mut libc::c_long) -> *mut libc::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn getprogname() -> *const libc::c_char;
}
extern "C" {
    pub fn heapsort(
        __base: *mut libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void)
                -> libc::c_int,
        >,
    ) -> libc::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void)
                -> libc::c_int,
        >,
    ) -> libc::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(arg1: *const libc::c_void, arg2: *const libc::c_void)
                -> libc::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut libc::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut libc::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut libc::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *const libc::c_void,
                arg3: *const libc::c_void,
            ) -> libc::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut libc::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut libc::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut libc::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *const libc::c_void,
                arg3: *const libc::c_void,
            ) -> libc::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const libc::c_uchar,
        __nel: libc::c_int,
        __table: *const libc::c_uchar,
        __endbyte: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn setprogname(arg1: *const libc::c_char);
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const libc::c_uchar,
        __nel: libc::c_int,
        __table: *const libc::c_uchar,
        __endbyte: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(__ptr: *mut libc::c_void, __size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn strtoq(
        __str: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const libc::c_char,
        __endptr: *mut *mut libc::c_char,
        __base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut libc::c_char;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memchr(__s: *const libc::c_void, __c: libc::c_int, __n: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const libc::c_void, __s2: *const libc::c_void, __n: usize) -> libc::c_int;
}
extern "C" {
    pub fn memcpy(
        __dst: *mut libc::c_void,
        __src: *const libc::c_void,
        __n: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmove(
        __dst: *mut libc::c_void,
        __src: *const libc::c_void,
        __len: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memset(__b: *mut libc::c_void, __c: libc::c_int, __len: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn strcat(__s1: *mut libc::c_char, __s2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const libc::c_char, __s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strcpy(__dst: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const libc::c_char, __charset: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strerror(__errnum: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strlen(__s: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strncat(
        __s1: *mut libc::c_char,
        __s2: *const libc::c_char,
        __n: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncmp(__s1: *const libc::c_char, __s2: *const libc::c_char, __n: usize)
        -> libc::c_int;
}
extern "C" {
    pub fn strncpy(
        __dst: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strpbrk(__s: *const libc::c_char, __charset: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const libc::c_char, __c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strspn(__s: *const libc::c_char, __charset: *const libc::c_char) -> libc::c_ulong;
}
extern "C" {
    pub fn strstr(__big: *const libc::c_char, __little: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok(__str: *mut libc::c_char, __sep: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strxfrm(__s1: *mut libc::c_char, __s2: *const libc::c_char, __n: usize)
        -> libc::c_ulong;
}
extern "C" {
    pub fn strtok_r(
        __str: *mut libc::c_char,
        __sep: *const libc::c_char,
        __lasts: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strerror_r(
        __errnum: libc::c_int,
        __strerrbuf: *mut libc::c_char,
        __buflen: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strdup(__s1: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn memccpy(
        __dst: *mut libc::c_void,
        __src: *const libc::c_void,
        __c: libc::c_int,
        __n: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn stpcpy(__dst: *mut libc::c_char, __src: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dst: *mut libc::c_char,
        __src: *const libc::c_char,
        __n: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strndup(__s1: *const libc::c_char, __n: usize) -> *mut libc::c_char;
}
extern "C" {
    pub fn strnlen(__s1: *const libc::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn strsignal(__sig: libc::c_int) -> *mut libc::c_char;
}
pub type rsize_t = __darwin_size_t;
extern "C" {
    pub fn memset_s(
        __s: *mut libc::c_void,
        __smax: rsize_t,
        __c: libc::c_int,
        __n: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn memmem(
        __big: *const libc::c_void,
        __big_len: usize,
        __little: *const libc::c_void,
        __little_len: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memset_pattern4(__b: *mut libc::c_void, __pattern4: *const libc::c_void, __len: usize);
}
extern "C" {
    pub fn memset_pattern8(__b: *mut libc::c_void, __pattern8: *const libc::c_void, __len: usize);
}
extern "C" {
    pub fn memset_pattern16(__b: *mut libc::c_void, __pattern16: *const libc::c_void, __len: usize);
}
extern "C" {
    pub fn strcasestr(
        __big: *const libc::c_char,
        __little: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strnstr(
        __big: *const libc::c_char,
        __little: *const libc::c_char,
        __len: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strlcat(
        __dst: *mut libc::c_char,
        __source: *const libc::c_char,
        __size: usize,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strlcpy(
        __dst: *mut libc::c_char,
        __source: *const libc::c_char,
        __size: usize,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strmode(__mode: libc::c_int, __bp: *mut libc::c_char);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut libc::c_char,
        __delim: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn swab(arg1: *const libc::c_void, arg2: *mut libc::c_void, arg3: isize);
}
extern "C" {
    pub fn timingsafe_bcmp(
        __b1: *const libc::c_void,
        __b2: *const libc::c_void,
        __len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn bcmp(arg1: *const libc::c_void, arg2: *const libc::c_void, arg3: usize) -> libc::c_int;
}
extern "C" {
    pub fn bcopy(arg1: *const libc::c_void, arg2: *mut libc::c_void, arg3: usize);
}
extern "C" {
    pub fn bzero(arg1: *mut libc::c_void, arg2: usize);
}
extern "C" {
    pub fn index(arg1: *const libc::c_char, arg2: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn rindex(arg1: *const libc::c_char, arg2: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn ffs(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn strcasecmp(arg1: *const libc::c_char, arg2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn ffsl(arg1: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn ffsll(arg1: libc::c_longlong) -> libc::c_int;
}
extern "C" {
    pub fn fls(arg1: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn flsl(arg1: libc::c_long) -> libc::c_int;
}
extern "C" {
    pub fn flsll(arg1: libc::c_longlong) -> libc::c_int;
}
extern "C" {
    pub fn av_log2(v: libc::c_uint) -> libc::c_int;
}
extern "C" {
    pub fn av_log2_16bit(v: libc::c_uint) -> libc::c_int;
}
extern "C" {
    /// Put a description of the AVERROR code errnum in errbuf.
    /// In case of failure the global variable errno is set to indicate the
    /// error. Even in case of failure av_strerror() will print a generic
    /// error message indicating the errnum provided to errbuf.
    ///
    /// @param errnum      error code to describe
    /// @param errbuf      buffer to which description is written
    /// @param errbuf_size the size in bytes of errbuf
    /// @return 0 on success, a negative value if a description for errnum
    /// cannot be found
    pub fn av_strerror(
        errnum: libc::c_int,
        errbuf: *mut libc::c_char,
        errbuf_size: usize,
    ) -> libc::c_int;
}
extern "C" {
    /// Allocate a memory block with alignment suitable for all memory accesses
    /// (including vectors if available on the CPU).
    ///
    /// @param size Size in bytes for the memory block to be allocated
    /// @return Pointer to the allocated block, or `NULL` if the block cannot
    /// be allocated
    /// @see av_mallocz()
    pub fn av_malloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    /// Allocate a memory block with alignment suitable for all memory accesses
    /// (including vectors if available on the CPU) and zero all the bytes of the
    /// block.
    ///
    /// @param size Size in bytes for the memory block to be allocated
    /// @return Pointer to the allocated block, or `NULL` if it cannot be allocated
    /// @see av_malloc()
    pub fn av_mallocz(size: usize) -> *mut libc::c_void;
}
extern "C" {
    /// Non-inlined equivalent of av_mallocz_array().
    ///
    /// Created for symmetry with the calloc() C function.
    pub fn av_calloc(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    /// Allocate, reallocate, or free a block of memory.
    ///
    /// If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
    /// zero, free the memory block pointed to by `ptr`. Otherwise, expand or
    /// shrink that block of memory according to `size`.
    ///
    /// @param ptr  Pointer to a memory block already allocated with
    /// av_realloc() or `NULL`
    /// @param size Size in bytes of the memory block to be allocated or
    /// reallocated
    ///
    /// @return Pointer to a newly-reallocated block or `NULL` if the block
    /// cannot be reallocated or the function is used to free the memory block
    ///
    /// @warning Unlike av_malloc(), the returned pointer is not guaranteed to be
    /// correctly aligned.
    /// @see av_fast_realloc()
    /// @see av_reallocp()
    pub fn av_realloc(ptr: *mut libc::c_void, size: usize) -> *mut libc::c_void;
}
extern "C" {
    /// Allocate, reallocate, or free a block of memory through a pointer to a
    /// pointer.
    ///
    /// If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
    /// zero, free the memory block pointed to by `*ptr`. Otherwise, expand or
    /// shrink that block of memory according to `size`.
    ///
    /// @param[in,out] ptr  Pointer to a pointer to a memory block already allocated
    /// with av_realloc(), or a pointer to `NULL`. The pointer
    /// is updated on success, or freed on failure.
    /// @param[in]     size Size in bytes for the memory block to be allocated or
    /// reallocated
    ///
    /// @return Zero on success, an AVERROR error code on failure
    ///
    /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
    /// correctly aligned.
    pub fn av_reallocp(ptr: *mut libc::c_void, size: usize) -> libc::c_int;
}
extern "C" {
    /// Allocate, reallocate, or free a block of memory.
    ///
    /// This function does the same thing as av_realloc(), except:
    /// - It takes two size arguments and allocates `nelem * elsize` bytes,
    /// after checking the result of the multiplication for integer overflow.
    /// - It frees the input block in case of failure, thus avoiding the memory
    /// leak with the classic
    /// @code{.c}
    /// buf = realloc(buf);
    /// if (!buf)
    /// return -1;
    /// @endcode
    /// pattern.
    pub fn av_realloc_f(ptr: *mut libc::c_void, nelem: usize, elsize: usize) -> *mut libc::c_void;
}
extern "C" {
    /// Allocate, reallocate, or free an array.
    ///
    /// If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If
    /// `nmemb` is zero, free the memory block pointed to by `ptr`.
    ///
    /// @param ptr   Pointer to a memory block already allocated with
    /// av_realloc() or `NULL`
    /// @param nmemb Number of elements in the array
    /// @param size  Size of the single element of the array
    ///
    /// @return Pointer to a newly-reallocated block or NULL if the block
    /// cannot be reallocated or the function is used to free the memory block
    ///
    /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
    /// correctly aligned.
    /// @see av_reallocp_array()
    pub fn av_realloc_array(ptr: *mut libc::c_void, nmemb: usize, size: usize)
        -> *mut libc::c_void;
}
extern "C" {
    /// Allocate, reallocate, or free an array through a pointer to a pointer.
    ///
    /// If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is
    /// zero, free the memory block pointed to by `*ptr`.
    ///
    /// @param[in,out] ptr   Pointer to a pointer to a memory block already
    /// allocated with av_realloc(), or a pointer to `NULL`.
    /// The pointer is updated on success, or freed on failure.
    /// @param[in]     nmemb Number of elements
    /// @param[in]     size  Size of the single element
    ///
    /// @return Zero on success, an AVERROR error code on failure
    ///
    /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
    /// correctly aligned.
    pub fn av_reallocp_array(ptr: *mut libc::c_void, nmemb: usize, size: usize) -> libc::c_int;
}
extern "C" {
    /// Reallocate the given buffer if it is not large enough, otherwise do nothing.
    ///
    /// If the given buffer is `NULL`, then a new uninitialized buffer is allocated.
    ///
    /// If the given buffer is not large enough, and reallocation fails, `NULL` is
    /// returned and `*size` is set to 0, but the original buffer is not changed or
    /// freed.
    ///
    /// A typical use pattern follows:
    ///
    /// @code{.c}
    /// uint8_t *buf = ...;
    /// uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);
    /// if (!new_buf) {
    /// // Allocation failed; clean up original buffer
    /// av_freep(&buf);
    /// return AVERROR(ENOMEM);
    /// }
    /// @endcode
    ///
    /// @param[in,out] ptr      Already allocated buffer, or `NULL`
    /// @param[in,out] size     Pointer to current size of buffer `ptr`. `*size` is
    /// changed to `min_size` in case of success or 0 in
    /// case of failure
    /// @param[in]     min_size New size of buffer `ptr`
    /// @return `ptr` if the buffer is large enough, a pointer to newly reallocated
    /// buffer if the buffer was not large enough, or `NULL` in case of
    /// error
    /// @see av_realloc()
    /// @see av_fast_malloc()
    pub fn av_fast_realloc(
        ptr: *mut libc::c_void,
        size: *mut libc::c_uint,
        min_size: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    /// Allocate a buffer, reusing the given one if large enough.
    ///
    /// Contrary to av_fast_realloc(), the current buffer contents might not be
    /// preserved and on error the old buffer is freed, thus no special handling to
    /// avoid memleaks is necessary.
    ///
    /// `*ptr` is allowed to be `NULL`, in which case allocation always happens if
    /// `size_needed` is greater than 0.
    ///
    /// @code{.c}
    /// uint8_t *buf = ...;
    /// av_fast_malloc(&buf, &current_size, size_needed);
    /// if (!buf) {
    /// // Allocation failed; buf already freed
    /// return AVERROR(ENOMEM);
    /// }
    /// @endcode
    ///
    /// @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
    /// `*ptr` will be overwritten with pointer to new
    /// buffer on success or `NULL` on failure
    /// @param[in,out] size     Pointer to current size of buffer `*ptr`. `*size` is
    /// changed to `min_size` in case of success or 0 in
    /// case of failure
    /// @param[in]     min_size New size of buffer `*ptr`
    /// @see av_realloc()
    /// @see av_fast_mallocz()
    pub fn av_fast_malloc(ptr: *mut libc::c_void, size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    /// Allocate and clear a buffer, reusing the given one if large enough.
    ///
    /// Like av_fast_malloc(), but all newly allocated space is initially cleared.
    /// Reused buffer is not cleared.
    ///
    /// `*ptr` is allowed to be `NULL`, in which case allocation always happens if
    /// `size_needed` is greater than 0.
    ///
    /// @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
    /// `*ptr` will be overwritten with pointer to new
    /// buffer on success or `NULL` on failure
    /// @param[in,out] size     Pointer to current size of buffer `*ptr`. `*size` is
    /// changed to `min_size` in case of success or 0 in
    /// case of failure
    /// @param[in]     min_size New size of buffer `*ptr`
    /// @see av_fast_malloc()
    pub fn av_fast_mallocz(ptr: *mut libc::c_void, size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    /// Free a memory block which has been allocated with a function of av_malloc()
    /// or av_realloc() family.
    ///
    /// @param ptr Pointer to the memory block which should be freed.
    ///
    /// @note `ptr = NULL` is explicitly allowed.
    /// @note It is recommended that you use av_freep() instead, to prevent leaving
    /// behind dangling pointers.
    /// @see av_freep()
    pub fn av_free(ptr: *mut libc::c_void);
}
extern "C" {
    /// Free a memory block which has been allocated with a function of av_malloc()
    /// or av_realloc() family, and set the pointer pointing to it to `NULL`.
    ///
    /// @code{.c}
    /// uint8_t *buf = av_malloc(16);
    /// av_free(buf);
    /// // buf now contains a dangling pointer to freed memory, and accidental
    /// // dereference of buf will result in a use-after-free, which may be a
    /// // security risk.
    ///
    /// uint8_t *buf = av_malloc(16);
    /// av_freep(&buf);
    /// // buf is now NULL, and accidental dereference will only result in a
    /// // NULL-pointer dereference.
    /// @endcode
    ///
    /// @param ptr Pointer to the pointer to the memory block which should be freed
    /// @note `*ptr = NULL` is safe and leads to no action.
    /// @see av_free()
    pub fn av_freep(ptr: *mut libc::c_void);
}
extern "C" {
    /// Duplicate a string.
    ///
    /// @param s String to be duplicated
    /// @return Pointer to a newly-allocated string containing a
    /// copy of `s` or `NULL` if the string cannot be allocated
    /// @see av_strndup()
    pub fn av_strdup(s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    /// Duplicate a substring of a string.
    ///
    /// @param s   String to be duplicated
    /// @param len Maximum length of the resulting string (not counting the
    /// terminating byte)
    /// @return Pointer to a newly-allocated string containing a
    /// substring of `s` or `NULL` if the string cannot be allocated
    pub fn av_strndup(s: *const libc::c_char, len: usize) -> *mut libc::c_char;
}
extern "C" {
    /// Duplicate a buffer with av_malloc().
    ///
    /// @param p    Buffer to be duplicated
    /// @param size Size in bytes of the buffer copied
    /// @return Pointer to a newly allocated buffer containing a
    /// copy of `p` or `NULL` if the buffer cannot be allocated
    pub fn av_memdup(p: *const libc::c_void, size: usize) -> *mut libc::c_void;
}
extern "C" {
    /// Overlapping memcpy() implementation.
    ///
    /// @param dst  Destination buffer
    /// @param back Number of bytes back to start copying (i.e. the initial size of
    /// the overlapping window); must be > 0
    /// @param cnt  Number of bytes to copy; must be >= 0
    ///
    /// @note `cnt > back` is valid, this will copy the bytes we just copied,
    /// thus creating a repeating pattern with a period length of `back`.
    pub fn av_memcpy_backptr(dst: *mut u8, back: libc::c_int, cnt: libc::c_int);
}
extern "C" {
    /// Add the pointer to an element to a dynamic array.
    ///
    /// The array to grow is supposed to be an array of pointers to
    /// structures, and the element to add must be a pointer to an already
    /// allocated structure.
    ///
    /// The array is reallocated when its size reaches powers of 2.
    /// Therefore, the amortized cost of adding an element is constant.
    ///
    /// In case of success, the pointer to the array is updated in order to
    /// point to the new grown array, and the number pointed to by `nb_ptr`
    /// is incremented.
    /// In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
    /// `*nb_ptr` is set to 0.
    ///
    /// @param[in,out] tab_ptr Pointer to the array to grow
    /// @param[in,out] nb_ptr  Pointer to the number of elements in the array
    /// @param[in]     elem    Element to add
    /// @see av_dynarray_add_nofree(), av_dynarray2_add()
    pub fn av_dynarray_add(
        tab_ptr: *mut libc::c_void,
        nb_ptr: *mut libc::c_int,
        elem: *mut libc::c_void,
    );
}
extern "C" {
    /// Add an element to a dynamic array.
    ///
    /// Function has the same functionality as av_dynarray_add(),
    /// but it doesn't free memory on fails. It returns error code
    /// instead and leave current buffer untouched.
    ///
    /// @return >=0 on success, negative otherwise
    /// @see av_dynarray_add(), av_dynarray2_add()
    pub fn av_dynarray_add_nofree(
        tab_ptr: *mut libc::c_void,
        nb_ptr: *mut libc::c_int,
        elem: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Add an element of size `elem_size` to a dynamic array.
    ///
    /// The array is reallocated when its number of elements reaches powers of 2.
    /// Therefore, the amortized cost of adding an element is constant.
    ///
    /// In case of success, the pointer to the array is updated in order to
    /// point to the new grown array, and the number pointed to by `nb_ptr`
    /// is incremented.
    /// In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
    /// `*nb_ptr` is set to 0.
    ///
    /// @param[in,out] tab_ptr   Pointer to the array to grow
    /// @param[in,out] nb_ptr    Pointer to the number of elements in the array
    /// @param[in]     elem_size Size in bytes of an element in the array
    /// @param[in]     elem_data Pointer to the data of the element to add. If
    /// `NULL`, the space of the newly added element is
    /// allocated but left uninitialized.
    ///
    /// @return Pointer to the data of the element to copy in the newly allocated
    /// space
    /// @see av_dynarray_add(), av_dynarray_add_nofree()
    pub fn av_dynarray2_add(
        tab_ptr: *mut *mut libc::c_void,
        nb_ptr: *mut libc::c_int,
        elem_size: usize,
        elem_data: *const u8,
    ) -> *mut libc::c_void;
}
extern "C" {
    /// Set the maximum size that may be allocated in one block.
    ///
    /// The value specified with this function is effective for all libavutil's @ref
    /// lavu_mem_funcs "heap management functions."
    ///
    /// By default, the max value is defined as `INT_MAX`.
    ///
    /// @param max Value to be set as the new maximum size
    ///
    /// @warning Exercise extreme caution when using this function. Don't touch
    /// this if you do not understand the full consequence of doing so.
    pub fn av_max_alloc(max: usize);
}
/// Rational number (pair of numerator and denominator).
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVRational {
    /// < Numerator
    pub num: libc::c_int,
    /// < Denominator
    pub den: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVRational() {
    assert_eq!(
        ::std::mem::size_of::<AVRational>(),
        8usize,
        concat!("Size of: ", stringify!(AVRational))
    );
    assert_eq!(
        ::std::mem::align_of::<AVRational>(),
        4usize,
        concat!("Alignment of ", stringify!(AVRational))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRational>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRational),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVRational>())).den as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVRational),
            "::",
            stringify!(den)
        )
    );
}
extern "C" {
    /// Reduce a fraction.
    ///
    /// This is useful for framerate calculations.
    ///
    /// @param[out] dst_num Destination numerator
    /// @param[out] dst_den Destination denominator
    /// @param[in]      num Source numerator
    /// @param[in]      den Source denominator
    /// @param[in]      max Maximum allowed values for `dst_num` & `dst_den`
    /// @return 1 if the operation is exact, 0 otherwise
    pub fn av_reduce(
        dst_num: *mut libc::c_int,
        dst_den: *mut libc::c_int,
        num: i64,
        den: i64,
        max: i64,
    ) -> libc::c_int;
}
extern "C" {
    /// Multiply two rationals.
    /// @param b First rational
    /// @param c Second rational
    /// @return b*c
    pub fn av_mul_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    /// Divide one rational by another.
    /// @param b First rational
    /// @param c Second rational
    /// @return b/c
    pub fn av_div_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    /// Add two rationals.
    /// @param b First rational
    /// @param c Second rational
    /// @return b+c
    pub fn av_add_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    /// Subtract one rational from another.
    /// @param b First rational
    /// @param c Second rational
    /// @return b-c
    pub fn av_sub_q(b: AVRational, c: AVRational) -> AVRational;
}
extern "C" {
    /// Convert a double precision floating point number to a rational.
    ///
    /// In case of infinity, the returned value is expressed as `{1, 0}` or
    /// `{-1, 0}` depending on the sign.
    ///
    /// @param d   `double` to convert
    /// @param max Maximum allowed numerator and denominator
    /// @return `d` in AVRational form
    /// @see av_q2d()
    pub fn av_d2q(d: f64, max: libc::c_int) -> AVRational;
}
extern "C" {
    /// Find which of the two rationals is closer to another rational.
    ///
    /// @param q     Rational to be compared against
    /// @param q1,q2 Rationals to be tested
    /// @return One of the following values:
    /// - 1 if `q1` is nearer to `q` than `q2`
    /// - -1 if `q2` is nearer to `q` than `q1`
    /// - 0 if they have the same distance
    pub fn av_nearer_q(q: AVRational, q1: AVRational, q2: AVRational) -> libc::c_int;
}
extern "C" {
    /// Find the value in a list of rationals nearest a given reference rational.
    ///
    /// @param q      Reference rational
    /// @param q_list Array of rationals terminated by `{0, 0}`
    /// @return Index of the nearest value found in the array
    pub fn av_find_nearest_q_idx(q: AVRational, q_list: *const AVRational) -> libc::c_int;
}
extern "C" {
    /// Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point
    /// format.
    ///
    /// @param q Rational to be converted
    /// @return Equivalent floating-point value, expressed as an unsigned 32-bit
    /// integer.
    /// @note The returned value is platform-indepedant.
    pub fn av_q2intfloat(q: AVRational) -> u32;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat32 {
    pub i: u32,
    pub f: f32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_av_intfloat32() {
    assert_eq!(
        ::std::mem::size_of::<av_intfloat32>(),
        4usize,
        concat!("Size of: ", stringify!(av_intfloat32))
    );
    assert_eq!(
        ::std::mem::align_of::<av_intfloat32>(),
        4usize,
        concat!("Alignment of ", stringify!(av_intfloat32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat32>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat32),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat32>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat32),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union av_intfloat64 {
    pub i: u64,
    pub f: f64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_av_intfloat64() {
    assert_eq!(
        ::std::mem::size_of::<av_intfloat64>(),
        8usize,
        concat!("Size of: ", stringify!(av_intfloat64))
    );
    assert_eq!(
        ::std::mem::align_of::<av_intfloat64>(),
        8usize,
        concat!("Alignment of ", stringify!(av_intfloat64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat64>())).i as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat64),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<av_intfloat64>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(av_intfloat64),
            "::",
            stringify!(f)
        )
    );
}
#[repr(u32)]
/// Rounding methods.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVRounding {
    AV_ROUND_ZERO = 0,
    AV_ROUND_INF = 1,
    AV_ROUND_DOWN = 2,
    AV_ROUND_UP = 3,
    AV_ROUND_NEAR_INF = 5,
    AV_ROUND_PASS_MINMAX = 8192,
}
extern "C" {
    /// Compute the greatest common divisor of two integer operands.
    ///
    /// @param a,b Operands
    /// @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;
    /// if a == 0 and b == 0, returns 0.
    pub fn av_gcd(a: i64, b: i64) -> i64;
}
extern "C" {
    /// Rescale a 64-bit integer with rounding to nearest.
    ///
    /// The operation is mathematically equivalent to `a * b / c`, but writing that
    /// directly can overflow.
    ///
    /// This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.
    ///
    /// @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()
    pub fn av_rescale(a: i64, b: i64, c: i64) -> i64;
}
extern "C" {
    /// Rescale a 64-bit integer with specified rounding.
    ///
    /// The operation is mathematically equivalent to `a * b / c`, but writing that
    /// directly can overflow, and does not support different rounding methods.
    ///
    /// @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()
    pub fn av_rescale_rnd(a: i64, b: i64, c: i64, rnd: AVRounding) -> i64;
}
extern "C" {
    /// Rescale a 64-bit integer by 2 rational numbers.
    ///
    /// The operation is mathematically equivalent to `a * bq / cq`.
    ///
    /// This function is equivalent to av_rescale_q_rnd() with #AV_ROUND_NEAR_INF.
    ///
    /// @see av_rescale(), av_rescale_rnd(), av_rescale_q_rnd()
    pub fn av_rescale_q(a: i64, bq: AVRational, cq: AVRational) -> i64;
}
extern "C" {
    /// Rescale a 64-bit integer by 2 rational numbers with specified rounding.
    ///
    /// The operation is mathematically equivalent to `a * bq / cq`.
    ///
    /// @see av_rescale(), av_rescale_rnd(), av_rescale_q()
    pub fn av_rescale_q_rnd(a: i64, bq: AVRational, cq: AVRational, rnd: AVRounding) -> i64;
}
extern "C" {
    /// Compare two timestamps each in its own time base.
    ///
    /// @return One of the following values:
    /// - -1 if `ts_a` is before `ts_b`
    /// - 1 if `ts_a` is after `ts_b`
    /// - 0 if they represent the same position
    ///
    /// @warning
    /// The result of the function is undefined if one of the timestamps is outside
    /// the `int64_t` range when represented in the other's timebase.
    pub fn av_compare_ts(ts_a: i64, tb_a: AVRational, ts_b: i64, tb_b: AVRational) -> libc::c_int;
}
extern "C" {
    /// Compare the remainders of two integer operands divided by a common divisor.
    ///
    /// In other words, compare the least significant `log2(mod)` bits of integers
    /// `a` and `b`.
    ///
    /// @code{.c}
    /// av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)
    /// av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)
    /// @endcode
    ///
    /// @param a,b Operands
    /// @param mod Divisor; must be a power of 2
    /// @return
    /// - a negative value if `a % mod < b % mod`
    /// - a positive value if `a % mod > b % mod`
    /// - zero             if `a % mod == b % mod`
    pub fn av_compare_mod(a: u64, b: u64, mod_: u64) -> i64;
}
extern "C" {
    /// Rescale a timestamp while preserving known durations.
    ///
    /// This function is designed to be called per audio packet to scale the input
    /// timestamp to a different time base. Compared to a simple av_rescale_q()
    /// call, this function is robust against possible inconsistent frame durations.
    ///
    /// The `last` parameter is a state variable that must be preserved for all
    /// subsequent calls for the same stream. For the first call, `*last` should be
    /// initialized to #AV_NOPTS_VALUE.
    ///
    /// @param[in]     in_tb    Input time base
    /// @param[in]     in_ts    Input timestamp
    /// @param[in]     fs_tb    Duration time base; typically this is finer-grained
    /// (greater) than `in_tb` and `out_tb`
    /// @param[in]     duration Duration till the next call to this function (i.e.
    /// duration of the current packet/frame)
    /// @param[in,out] last     Pointer to a timestamp expressed in terms of
    /// `fs_tb`, acting as a state variable
    /// @param[in]     out_tb   Output timebase
    /// @return        Timestamp expressed in terms of `out_tb`
    ///
    /// @note In the context of this function, "duration" is in term of samples, not
    /// seconds.
    pub fn av_rescale_delta(
        in_tb: AVRational,
        in_ts: i64,
        fs_tb: AVRational,
        duration: libc::c_int,
        last: *mut i64,
        out_tb: AVRational,
    ) -> i64;
}
extern "C" {
    /// Add a value to a timestamp.
    ///
    /// This function guarantees that when the same value is repeatly added that
    /// no accumulation of rounding errors occurs.
    ///
    /// @param[in] ts     Input timestamp
    /// @param[in] ts_tb  Input timestamp time base
    /// @param[in] inc    Value to be added
    /// @param[in] inc_tb Time base of `inc`
    pub fn av_add_stable(ts_tb: AVRational, ts: i64, inc_tb: AVRational, inc: i64) -> i64;
}
pub type __gnuc_va_list = __builtin_va_list;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVClassCategory {
    AV_CLASS_CATEGORY_NA = 0,
    AV_CLASS_CATEGORY_INPUT = 1,
    AV_CLASS_CATEGORY_OUTPUT = 2,
    AV_CLASS_CATEGORY_MUXER = 3,
    AV_CLASS_CATEGORY_DEMUXER = 4,
    AV_CLASS_CATEGORY_ENCODER = 5,
    AV_CLASS_CATEGORY_DECODER = 6,
    AV_CLASS_CATEGORY_FILTER = 7,
    AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8,
    AV_CLASS_CATEGORY_SWSCALER = 9,
    AV_CLASS_CATEGORY_SWRESAMPLER = 10,
    AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40,
    AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41,
    AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42,
    AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43,
    AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44,
    AV_CLASS_CATEGORY_DEVICE_INPUT = 45,
    AV_CLASS_CATEGORY_NB = 46,
}
/// Describe the class of an AVClass context structure. That is an
/// arbitrary struct of which the first field is a pointer to an
/// AVClass struct (e.g. AVCodecContext, AVFormatContext etc.).
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVClass {
    /// The name of the class; usually it is the same name as the
    /// context structure type to which the AVClass is associated.
    pub class_name: *const libc::c_char,
    /// A pointer to a function which returns the name of a context
    /// instance ctx associated with the class.
    pub item_name:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut libc::c_void) -> *const libc::c_char>,
    /// a pointer to the first option specified in the class if any or NULL
    ///
    /// @see av_set_default_options()
    pub option: *const AVOption,
    /// LIBAVUTIL_VERSION with which this structure was created.
    /// This is used to allow fields to be added without requiring major
    /// version bumps everywhere.
    pub version: libc::c_int,
    /// Offset in the structure where log_level_offset is stored.
    /// 0 means there is no such variable
    pub log_level_offset_offset: libc::c_int,
    /// Offset in the structure where a pointer to the parent context for
    /// logging is stored. For example a decoder could pass its AVCodecContext
    /// to eval as such a parent context, which an av_log() implementation
    /// could then leverage to display the parent context.
    /// The offset can be NULL.
    pub parent_log_context_offset: libc::c_int,
    /// Return next AVOptions-enabled child or NULL
    pub child_next: ::std::option::Option<
        unsafe extern "C" fn(obj: *mut libc::c_void, prev: *mut libc::c_void) -> *mut libc::c_void,
    >,
    /// Return an AVClass corresponding to the next potential
    /// AVOptions-enabled child.
    ///
    /// The difference between child_next and this is that
    /// child_next iterates over _already existing_ objects, while
    /// child_class_next iterates over _all possible_ children.
    pub child_class_next:
        ::std::option::Option<unsafe extern "C" fn(prev: *const AVClass) -> *const AVClass>,
    /// Category used for visualization (like color)
    /// This is only set if the category is equal for all objects using this class.
    /// available since version (51 << 16 | 56 << 8 | 100)
    pub category: AVClassCategory,
    /// Callback to return the category.
    /// available since version (51 << 16 | 59 << 8 | 100)
    pub get_category:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut libc::c_void) -> AVClassCategory>,
    /// Callback to return the supported/allowed ranges.
    /// available since version (52.12)
    pub query_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut *mut AVOptionRanges,
            obj: *mut libc::c_void,
            key: *const libc::c_char,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVClass() {
    assert_eq!(
        ::std::mem::size_of::<AVClass>(),
        80usize,
        concat!("Size of: ", stringify!(AVClass))
    );
    assert_eq!(
        ::std::mem::align_of::<AVClass>(),
        8usize,
        concat!("Alignment of ", stringify!(AVClass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).class_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(class_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).item_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(item_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).option as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(option)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).version as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).log_level_offset_offset as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(log_level_offset_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVClass>())).parent_log_context_offset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(parent_log_context_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).child_next as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(child_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).child_class_next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(child_class_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).category as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(category)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).get_category as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(get_category)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVClass>())).query_ranges as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVClass),
            "::",
            stringify!(query_ranges)
        )
    );
}
extern "C" {
    /// Send the specified message to the log if the level is less than or equal
    /// to the current av_log_level. By default, all logging messages are sent to
    /// stderr. This behavior can be altered by setting a different logging callback
    /// function.
    /// @see av_log_set_callback
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    /// pointer to an AVClass struct or NULL if general log.
    /// @param level The importance level of the message expressed using a @ref
    /// lavu_log_constants "Logging Constant".
    /// @param fmt The format string (printf-compatible) that specifies how
    /// subsequent arguments are converted to output.
    pub fn av_log(avcl: *mut libc::c_void, level: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    /// Send the specified message to the log if the level is less than or equal
    /// to the current av_log_level. By default, all logging messages are sent to
    /// stderr. This behavior can be altered by setting a different logging callback
    /// function.
    /// @see av_log_set_callback
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    /// pointer to an AVClass struct.
    /// @param level The importance level of the message expressed using a @ref
    /// lavu_log_constants "Logging Constant".
    /// @param fmt The format string (printf-compatible) that specifies how
    /// subsequent arguments are converted to output.
    /// @param vl The arguments referenced by the format string.
    pub fn av_vlog(
        avcl: *mut libc::c_void,
        level: libc::c_int,
        fmt: *const libc::c_char,
        vl: *mut __va_list_tag,
    );
}
extern "C" {
    /// Get the current log level
    ///
    /// @see lavu_log_constants
    ///
    /// @return Current log level
    pub fn av_log_get_level() -> libc::c_int;
}
extern "C" {
    /// Set the log level
    ///
    /// @see lavu_log_constants
    ///
    /// @param level Logging level
    pub fn av_log_set_level(level: libc::c_int);
}
extern "C" {
    /// Set the logging callback
    ///
    /// @note The callback must be thread safe, even if the application does not use
    /// threads itself as some codecs are multithreaded.
    ///
    /// @see av_log_default_callback
    ///
    /// @param callback A logging function with a compatible signature.
    pub fn av_log_set_callback(
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: libc::c_int,
                arg3: *const libc::c_char,
                arg4: *mut __va_list_tag,
            ),
        >,
    );
}
extern "C" {
    /// Default logging callback
    ///
    /// It prints the message to stderr, optionally colorizing it.
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    /// pointer to an AVClass struct.
    /// @param level The importance level of the message expressed using a @ref
    /// lavu_log_constants "Logging Constant".
    /// @param fmt The format string (printf-compatible) that specifies how
    /// subsequent arguments are converted to output.
    /// @param vl The arguments referenced by the format string.
    pub fn av_log_default_callback(
        avcl: *mut libc::c_void,
        level: libc::c_int,
        fmt: *const libc::c_char,
        vl: *mut __va_list_tag,
    );
}
extern "C" {
    /// Return the context name
    ///
    /// @param  ctx The AVClass context
    ///
    /// @return The AVClass class_name
    pub fn av_default_item_name(ctx: *mut libc::c_void) -> *const libc::c_char;
}
extern "C" {
    pub fn av_default_get_category(ptr: *mut libc::c_void) -> AVClassCategory;
}
extern "C" {
    /// Format a line of log the same way as the default callback.
    /// @param line          buffer to receive the formatted line
    /// @param line_size     size of the buffer
    /// @param print_prefix  used to store whether the prefix must be printed;
    /// must point to a persistent integer initially set to 1
    pub fn av_log_format_line(
        ptr: *mut libc::c_void,
        level: libc::c_int,
        fmt: *const libc::c_char,
        vl: *mut __va_list_tag,
        line: *mut libc::c_char,
        line_size: libc::c_int,
        print_prefix: *mut libc::c_int,
    );
}
extern "C" {
    /// Format a line of log the same way as the default callback.
    /// @param line          buffer to receive the formatted line;
    /// may be NULL if line_size is 0
    /// @param line_size     size of the buffer; at most line_size-1 characters will
    /// be written to the buffer, plus one null terminator
    /// @param print_prefix  used to store whether the prefix must be printed;
    /// must point to a persistent integer initially set to 1
    /// @return Returns a negative value if an error occurred, otherwise returns
    /// the number of characters that would have been written for a
    /// sufficiently large buffer, not including the terminating null
    /// character. If the return value is not less than line_size, it means
    /// that the log message was truncated to fit the buffer.
    pub fn av_log_format_line2(
        ptr: *mut libc::c_void,
        level: libc::c_int,
        fmt: *const libc::c_char,
        vl: *mut __va_list_tag,
        line: *mut libc::c_char,
        line_size: libc::c_int,
        print_prefix: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_log_set_flags(arg: libc::c_int);
}
extern "C" {
    pub fn av_log_get_flags() -> libc::c_int;
}
pub const AV_PIX_FMT_XVMC: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_XVMC_MPEG2_IDCT;
pub const AV_PIX_FMT_VAAPI: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_VAAPI_VLD;
pub const AV_PIX_FMT_Y400A: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_YA8;
pub const AV_PIX_FMT_GRAY8A: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_YA8;
pub const AV_PIX_FMT_GBR24P: AVPixelFormat = AVPixelFormat::AV_PIX_FMT_GBRP;
#[repr(i32)]
/// Pixel format.
///
/// @note
/// AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA
/// color is put together as:
/// (A << 24) | (R << 16) | (G << 8) | B
/// This is stored as BGRA on little-endian CPU architectures and ARGB on
/// big-endian CPUs.
///
/// @par
/// When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized
/// image data is stored in AVFrame.data[0]. The palette is transported in
/// AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is
/// formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is
/// also endian-specific). Note also that the individual RGB32 palette
/// components stored in AVFrame.data[1] should be in the range 0..255.
/// This is important as many custom PAL8 video codecs that were designed
/// to run on the IBM VGA graphics adapter use 6-bit palette components.
///
/// @par
/// For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like
/// for pal8. This palette is filled in automatically by the function
/// allocating the picture.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVPixelFormat {
    AV_PIX_FMT_NONE = -1,
    AV_PIX_FMT_YUV420P = 0,
    AV_PIX_FMT_YUYV422 = 1,
    AV_PIX_FMT_RGB24 = 2,
    AV_PIX_FMT_BGR24 = 3,
    AV_PIX_FMT_YUV422P = 4,
    AV_PIX_FMT_YUV444P = 5,
    AV_PIX_FMT_YUV410P = 6,
    AV_PIX_FMT_YUV411P = 7,
    AV_PIX_FMT_GRAY8 = 8,
    AV_PIX_FMT_MONOWHITE = 9,
    AV_PIX_FMT_MONOBLACK = 10,
    AV_PIX_FMT_PAL8 = 11,
    AV_PIX_FMT_YUVJ420P = 12,
    AV_PIX_FMT_YUVJ422P = 13,
    AV_PIX_FMT_YUVJ444P = 14,
    AV_PIX_FMT_XVMC_MPEG2_MC = 15,
    AV_PIX_FMT_XVMC_MPEG2_IDCT = 16,
    AV_PIX_FMT_UYVY422 = 17,
    AV_PIX_FMT_UYYVYY411 = 18,
    AV_PIX_FMT_BGR8 = 19,
    AV_PIX_FMT_BGR4 = 20,
    AV_PIX_FMT_BGR4_BYTE = 21,
    AV_PIX_FMT_RGB8 = 22,
    AV_PIX_FMT_RGB4 = 23,
    AV_PIX_FMT_RGB4_BYTE = 24,
    AV_PIX_FMT_NV12 = 25,
    AV_PIX_FMT_NV21 = 26,
    AV_PIX_FMT_ARGB = 27,
    AV_PIX_FMT_RGBA = 28,
    AV_PIX_FMT_ABGR = 29,
    AV_PIX_FMT_BGRA = 30,
    AV_PIX_FMT_GRAY16BE = 31,
    AV_PIX_FMT_GRAY16LE = 32,
    AV_PIX_FMT_YUV440P = 33,
    AV_PIX_FMT_YUVJ440P = 34,
    AV_PIX_FMT_YUVA420P = 35,
    AV_PIX_FMT_VDPAU_H264 = 36,
    AV_PIX_FMT_VDPAU_MPEG1 = 37,
    AV_PIX_FMT_VDPAU_MPEG2 = 38,
    AV_PIX_FMT_VDPAU_WMV3 = 39,
    AV_PIX_FMT_VDPAU_VC1 = 40,
    AV_PIX_FMT_RGB48BE = 41,
    AV_PIX_FMT_RGB48LE = 42,
    AV_PIX_FMT_RGB565BE = 43,
    AV_PIX_FMT_RGB565LE = 44,
    AV_PIX_FMT_RGB555BE = 45,
    AV_PIX_FMT_RGB555LE = 46,
    AV_PIX_FMT_BGR565BE = 47,
    AV_PIX_FMT_BGR565LE = 48,
    AV_PIX_FMT_BGR555BE = 49,
    AV_PIX_FMT_BGR555LE = 50,
    AV_PIX_FMT_VAAPI_MOCO = 51,
    AV_PIX_FMT_VAAPI_IDCT = 52,
    AV_PIX_FMT_VAAPI_VLD = 53,
    AV_PIX_FMT_YUV420P16LE = 54,
    AV_PIX_FMT_YUV420P16BE = 55,
    AV_PIX_FMT_YUV422P16LE = 56,
    AV_PIX_FMT_YUV422P16BE = 57,
    AV_PIX_FMT_YUV444P16LE = 58,
    AV_PIX_FMT_YUV444P16BE = 59,
    AV_PIX_FMT_VDPAU_MPEG4 = 60,
    AV_PIX_FMT_DXVA2_VLD = 61,
    AV_PIX_FMT_RGB444LE = 62,
    AV_PIX_FMT_RGB444BE = 63,
    AV_PIX_FMT_BGR444LE = 64,
    AV_PIX_FMT_BGR444BE = 65,
    AV_PIX_FMT_YA8 = 66,
    AV_PIX_FMT_BGR48BE = 67,
    AV_PIX_FMT_BGR48LE = 68,
    AV_PIX_FMT_YUV420P9BE = 69,
    AV_PIX_FMT_YUV420P9LE = 70,
    AV_PIX_FMT_YUV420P10BE = 71,
    AV_PIX_FMT_YUV420P10LE = 72,
    AV_PIX_FMT_YUV422P10BE = 73,
    AV_PIX_FMT_YUV422P10LE = 74,
    AV_PIX_FMT_YUV444P9BE = 75,
    AV_PIX_FMT_YUV444P9LE = 76,
    AV_PIX_FMT_YUV444P10BE = 77,
    AV_PIX_FMT_YUV444P10LE = 78,
    AV_PIX_FMT_YUV422P9BE = 79,
    AV_PIX_FMT_YUV422P9LE = 80,
    AV_PIX_FMT_VDA_VLD = 81,
    AV_PIX_FMT_GBRP = 82,
    AV_PIX_FMT_GBRP9BE = 83,
    AV_PIX_FMT_GBRP9LE = 84,
    AV_PIX_FMT_GBRP10BE = 85,
    AV_PIX_FMT_GBRP10LE = 86,
    AV_PIX_FMT_GBRP16BE = 87,
    AV_PIX_FMT_GBRP16LE = 88,
    AV_PIX_FMT_YUVA422P = 89,
    AV_PIX_FMT_YUVA444P = 90,
    AV_PIX_FMT_YUVA420P9BE = 91,
    AV_PIX_FMT_YUVA420P9LE = 92,
    AV_PIX_FMT_YUVA422P9BE = 93,
    AV_PIX_FMT_YUVA422P9LE = 94,
    AV_PIX_FMT_YUVA444P9BE = 95,
    AV_PIX_FMT_YUVA444P9LE = 96,
    AV_PIX_FMT_YUVA420P10BE = 97,
    AV_PIX_FMT_YUVA420P10LE = 98,
    AV_PIX_FMT_YUVA422P10BE = 99,
    AV_PIX_FMT_YUVA422P10LE = 100,
    AV_PIX_FMT_YUVA444P10BE = 101,
    AV_PIX_FMT_YUVA444P10LE = 102,
    AV_PIX_FMT_YUVA420P16BE = 103,
    AV_PIX_FMT_YUVA420P16LE = 104,
    AV_PIX_FMT_YUVA422P16BE = 105,
    AV_PIX_FMT_YUVA422P16LE = 106,
    AV_PIX_FMT_YUVA444P16BE = 107,
    AV_PIX_FMT_YUVA444P16LE = 108,
    AV_PIX_FMT_VDPAU = 109,
    AV_PIX_FMT_XYZ12LE = 110,
    AV_PIX_FMT_XYZ12BE = 111,
    AV_PIX_FMT_NV16 = 112,
    AV_PIX_FMT_NV20LE = 113,
    AV_PIX_FMT_NV20BE = 114,
    AV_PIX_FMT_RGBA64BE = 115,
    AV_PIX_FMT_RGBA64LE = 116,
    AV_PIX_FMT_BGRA64BE = 117,
    AV_PIX_FMT_BGRA64LE = 118,
    AV_PIX_FMT_YVYU422 = 119,
    AV_PIX_FMT_VDA = 120,
    AV_PIX_FMT_YA16BE = 121,
    AV_PIX_FMT_YA16LE = 122,
    AV_PIX_FMT_GBRAP = 123,
    AV_PIX_FMT_GBRAP16BE = 124,
    AV_PIX_FMT_GBRAP16LE = 125,
    AV_PIX_FMT_QSV = 126,
    AV_PIX_FMT_MMAL = 127,
    AV_PIX_FMT_D3D11VA_VLD = 128,
    AV_PIX_FMT_CUDA = 129,
    AV_PIX_FMT_0RGB = 295,
    AV_PIX_FMT_RGB0 = 296,
    AV_PIX_FMT_0BGR = 297,
    AV_PIX_FMT_BGR0 = 298,
    AV_PIX_FMT_YUV420P12BE = 299,
    AV_PIX_FMT_YUV420P12LE = 300,
    AV_PIX_FMT_YUV420P14BE = 301,
    AV_PIX_FMT_YUV420P14LE = 302,
    AV_PIX_FMT_YUV422P12BE = 303,
    AV_PIX_FMT_YUV422P12LE = 304,
    AV_PIX_FMT_YUV422P14BE = 305,
    AV_PIX_FMT_YUV422P14LE = 306,
    AV_PIX_FMT_YUV444P12BE = 307,
    AV_PIX_FMT_YUV444P12LE = 308,
    AV_PIX_FMT_YUV444P14BE = 309,
    AV_PIX_FMT_YUV444P14LE = 310,
    AV_PIX_FMT_GBRP12BE = 311,
    AV_PIX_FMT_GBRP12LE = 312,
    AV_PIX_FMT_GBRP14BE = 313,
    AV_PIX_FMT_GBRP14LE = 314,
    AV_PIX_FMT_YUVJ411P = 315,
    AV_PIX_FMT_BAYER_BGGR8 = 316,
    AV_PIX_FMT_BAYER_RGGB8 = 317,
    AV_PIX_FMT_BAYER_GBRG8 = 318,
    AV_PIX_FMT_BAYER_GRBG8 = 319,
    AV_PIX_FMT_BAYER_BGGR16LE = 320,
    AV_PIX_FMT_BAYER_BGGR16BE = 321,
    AV_PIX_FMT_BAYER_RGGB16LE = 322,
    AV_PIX_FMT_BAYER_RGGB16BE = 323,
    AV_PIX_FMT_BAYER_GBRG16LE = 324,
    AV_PIX_FMT_BAYER_GBRG16BE = 325,
    AV_PIX_FMT_BAYER_GRBG16LE = 326,
    AV_PIX_FMT_BAYER_GRBG16BE = 327,
    AV_PIX_FMT_YUV440P10LE = 328,
    AV_PIX_FMT_YUV440P10BE = 329,
    AV_PIX_FMT_YUV440P12LE = 330,
    AV_PIX_FMT_YUV440P12BE = 331,
    AV_PIX_FMT_AYUV64LE = 332,
    AV_PIX_FMT_AYUV64BE = 333,
    AV_PIX_FMT_VIDEOTOOLBOX = 334,
    AV_PIX_FMT_P010LE = 335,
    AV_PIX_FMT_P010BE = 336,
    AV_PIX_FMT_GBRAP12BE = 337,
    AV_PIX_FMT_GBRAP12LE = 338,
    AV_PIX_FMT_GBRAP10BE = 339,
    AV_PIX_FMT_GBRAP10LE = 340,
    AV_PIX_FMT_MEDIACODEC = 341,
    AV_PIX_FMT_GRAY12BE = 342,
    AV_PIX_FMT_GRAY12LE = 343,
    AV_PIX_FMT_GRAY10BE = 344,
    AV_PIX_FMT_GRAY10LE = 345,
    AV_PIX_FMT_P016LE = 346,
    AV_PIX_FMT_P016BE = 347,
    AV_PIX_FMT_D3D11 = 348,
    AV_PIX_FMT_GRAY9BE = 349,
    AV_PIX_FMT_GRAY9LE = 350,
    AV_PIX_FMT_GBRPF32BE = 351,
    AV_PIX_FMT_GBRPF32LE = 352,
    AV_PIX_FMT_GBRAPF32BE = 353,
    AV_PIX_FMT_GBRAPF32LE = 354,
    AV_PIX_FMT_DRM_PRIME = 355,
    AV_PIX_FMT_NB = 356,
}
pub const AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = AVColorPrimaries::AVCOL_PRI_SMPTE428;
#[repr(u32)]
/// Chromaticity coordinates of the source primaries.
/// These values match the ones defined by ISO/IEC 23001-8_2013 § 7.1.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVColorPrimaries {
    AVCOL_PRI_RESERVED0 = 0,
    AVCOL_PRI_BT709 = 1,
    AVCOL_PRI_UNSPECIFIED = 2,
    AVCOL_PRI_RESERVED = 3,
    AVCOL_PRI_BT470M = 4,
    AVCOL_PRI_BT470BG = 5,
    AVCOL_PRI_SMPTE170M = 6,
    AVCOL_PRI_SMPTE240M = 7,
    AVCOL_PRI_FILM = 8,
    AVCOL_PRI_BT2020 = 9,
    AVCOL_PRI_SMPTE428 = 10,
    AVCOL_PRI_SMPTE431 = 11,
    AVCOL_PRI_SMPTE432 = 12,
    AVCOL_PRI_JEDEC_P22 = 22,
    AVCOL_PRI_NB = 23,
}
pub const AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic =
    AVColorTransferCharacteristic::AVCOL_TRC_SMPTE2084;
pub const AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic =
    AVColorTransferCharacteristic::AVCOL_TRC_SMPTE428;
#[repr(u32)]
/// Color Transfer Characteristic.
/// These values match the ones defined by ISO/IEC 23001-8_2013 § 7.2.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVColorTransferCharacteristic {
    AVCOL_TRC_RESERVED0 = 0,
    AVCOL_TRC_BT709 = 1,
    AVCOL_TRC_UNSPECIFIED = 2,
    AVCOL_TRC_RESERVED = 3,
    AVCOL_TRC_GAMMA22 = 4,
    AVCOL_TRC_GAMMA28 = 5,
    AVCOL_TRC_SMPTE170M = 6,
    AVCOL_TRC_SMPTE240M = 7,
    AVCOL_TRC_LINEAR = 8,
    AVCOL_TRC_LOG = 9,
    AVCOL_TRC_LOG_SQRT = 10,
    AVCOL_TRC_IEC61966_2_4 = 11,
    AVCOL_TRC_BT1361_ECG = 12,
    AVCOL_TRC_IEC61966_2_1 = 13,
    AVCOL_TRC_BT2020_10 = 14,
    AVCOL_TRC_BT2020_12 = 15,
    AVCOL_TRC_SMPTE2084 = 16,
    AVCOL_TRC_SMPTE428 = 17,
    AVCOL_TRC_ARIB_STD_B67 = 18,
    AVCOL_TRC_NB = 19,
}
pub const AVCOL_SPC_YCOCG: AVColorSpace = AVColorSpace::AVCOL_SPC_YCGCO;
#[repr(u32)]
/// YUV colorspace type.
/// These values match the ones defined by ISO/IEC 23001-8_2013 § 7.3.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVColorSpace {
    AVCOL_SPC_RGB = 0,
    AVCOL_SPC_BT709 = 1,
    AVCOL_SPC_UNSPECIFIED = 2,
    AVCOL_SPC_RESERVED = 3,
    AVCOL_SPC_FCC = 4,
    AVCOL_SPC_BT470BG = 5,
    AVCOL_SPC_SMPTE170M = 6,
    AVCOL_SPC_SMPTE240M = 7,
    AVCOL_SPC_YCGCO = 8,
    AVCOL_SPC_BT2020_NCL = 9,
    AVCOL_SPC_BT2020_CL = 10,
    AVCOL_SPC_SMPTE2085 = 11,
    AVCOL_SPC_CHROMA_DERIVED_NCL = 12,
    AVCOL_SPC_CHROMA_DERIVED_CL = 13,
    AVCOL_SPC_ICTCP = 14,
    AVCOL_SPC_NB = 15,
}
#[repr(u32)]
/// MPEG vs JPEG YUV range.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVColorRange {
    AVCOL_RANGE_UNSPECIFIED = 0,
    AVCOL_RANGE_MPEG = 1,
    AVCOL_RANGE_JPEG = 2,
    AVCOL_RANGE_NB = 3,
}
#[repr(u32)]
/// Location of chroma samples.
///
/// Illustration showing the location of the first (top left) chroma sample of the
/// image, the left shows only luma, the right
/// shows the location of the chroma sample, the 2 could be imagined to overlay
/// each other but are drawn separately due to limitations of ASCII
///
/// 1st 2nd       1st 2nd horizontal luma sample positions
/// v   v         v   v
/// ______        ______
/// 1st luma line > |X   X ...    |3 4 X ...     X are luma samples,
/// |             |1 2           1-6 are possible chroma positions
/// 2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVChromaLocation {
    AVCHROMA_LOC_UNSPECIFIED = 0,
    AVCHROMA_LOC_LEFT = 1,
    AVCHROMA_LOC_CENTER = 2,
    AVCHROMA_LOC_TOPLEFT = 3,
    AVCHROMA_LOC_TOP = 4,
    AVCHROMA_LOC_BOTTOMLEFT = 5,
    AVCHROMA_LOC_BOTTOM = 6,
    AVCHROMA_LOC_NB = 7,
}
extern "C" {
    /// Compute the length of an integer list.
    ///
    /// @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)
    /// @param term    list terminator (usually 0 or -1)
    /// @param list    pointer to the list
    /// @return  length of the list, in elements, not counting the terminator
    pub fn av_int_list_length_for_size(
        elsize: libc::c_uint,
        list: *const libc::c_void,
        term: u64,
    ) -> libc::c_uint;
}
extern "C" {
    /// Open a file using a UTF-8 filename.
    /// The API of this function matches POSIX fopen(), errors are returned through
    /// errno.
    pub fn av_fopen_utf8(path: *const libc::c_char, mode: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    /// Return the fractional representation of the internal time base.
    pub fn av_get_time_base_q() -> AVRational;
}
extern "C" {
    /// Fill the provided buffer with a string containing a FourCC (four-character
    /// code) representation.
    ///
    /// @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE
    /// @param fourcc the fourcc to represent
    /// @return the buffer in input
    pub fn av_fourcc_make_string(buf: *mut libc::c_char, fourcc: u32) -> *mut libc::c_char;
}
#[repr(i32)]
/// Audio sample formats
///
/// - The data described by the sample format is always in native-endian order.
/// Sample values can be expressed by native C types, hence the lack of a signed
/// 24-bit sample format even though it is a common raw audio data format.
///
/// - The floating-point formats are based on full volume being in the range
/// [-1.0, 1.0]. Any values outside this range are beyond full volume level.
///
/// - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg
/// (such as AVFrame in libavcodec) is as follows:
///
/// @par
/// For planar sample formats, each audio channel is in a separate data plane,
/// and linesize is the buffer size, in bytes, for a single plane. All data
/// planes must be the same size. For packed sample formats, only the first data
/// plane is used, and samples for each channel are interleaved. In this case,
/// linesize is the buffer size, in bytes, for the 1 plane.
///
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVSampleFormat {
    AV_SAMPLE_FMT_NONE = -1,
    AV_SAMPLE_FMT_U8 = 0,
    AV_SAMPLE_FMT_S16 = 1,
    AV_SAMPLE_FMT_S32 = 2,
    AV_SAMPLE_FMT_FLT = 3,
    AV_SAMPLE_FMT_DBL = 4,
    AV_SAMPLE_FMT_U8P = 5,
    AV_SAMPLE_FMT_S16P = 6,
    AV_SAMPLE_FMT_S32P = 7,
    AV_SAMPLE_FMT_FLTP = 8,
    AV_SAMPLE_FMT_DBLP = 9,
    AV_SAMPLE_FMT_S64 = 10,
    AV_SAMPLE_FMT_S64P = 11,
    AV_SAMPLE_FMT_NB = 12,
}
extern "C" {
    /// Return the name of sample_fmt, or NULL if sample_fmt is not
    /// recognized.
    pub fn av_get_sample_fmt_name(sample_fmt: AVSampleFormat) -> *const libc::c_char;
}
extern "C" {
    /// Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE
    /// on error.
    pub fn av_get_sample_fmt(name: *const libc::c_char) -> AVSampleFormat;
}
extern "C" {
    /// Return the planar<->packed alternative form of the given sample format, or
    /// AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the
    /// requested planar/packed format, the format returned is the same as the
    /// input.
    pub fn av_get_alt_sample_fmt(sample_fmt: AVSampleFormat, planar: libc::c_int)
        -> AVSampleFormat;
}
extern "C" {
    /// Get the packed alternative form of the given sample format.
    ///
    /// If the passed sample_fmt is already in packed format, the format returned is
    /// the same as the input.
    ///
    /// @return  the packed alternative form of the given sample format or
    /// AV_SAMPLE_FMT_NONE on error.
    pub fn av_get_packed_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    /// Get the planar alternative form of the given sample format.
    ///
    /// If the passed sample_fmt is already in planar format, the format returned is
    /// the same as the input.
    ///
    /// @return  the planar alternative form of the given sample format or
    /// AV_SAMPLE_FMT_NONE on error.
    pub fn av_get_planar_sample_fmt(sample_fmt: AVSampleFormat) -> AVSampleFormat;
}
extern "C" {
    /// Generate a string corresponding to the sample format with
    /// sample_fmt, or a header if sample_fmt is negative.
    ///
    /// @param buf the buffer where to write the string
    /// @param buf_size the size of buf
    /// @param sample_fmt the number of the sample format to print the
    /// corresponding info string, or a negative value to print the
    /// corresponding header.
    /// @return the pointer to the filled buffer or NULL if sample_fmt is
    /// unknown or in case of other errors
    pub fn av_get_sample_fmt_string(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        sample_fmt: AVSampleFormat,
    ) -> *mut libc::c_char;
}
extern "C" {
    /// Return number of bytes per sample.
    ///
    /// @param sample_fmt the sample format
    /// @return number of bytes per sample or zero if unknown for the given
    /// sample format
    pub fn av_get_bytes_per_sample(sample_fmt: AVSampleFormat) -> libc::c_int;
}
extern "C" {
    /// Check if the sample format is planar.
    ///
    /// @param sample_fmt the sample format to inspect
    /// @return 1 if the sample format is planar, 0 if it is interleaved
    pub fn av_sample_fmt_is_planar(sample_fmt: AVSampleFormat) -> libc::c_int;
}
extern "C" {
    /// Get the required buffer size for the given audio parameters.
    ///
    /// @param[out] linesize calculated linesize, may be NULL
    /// @param nb_channels   the number of channels
    /// @param nb_samples    the number of samples in a single channel
    /// @param sample_fmt    the sample format
    /// @param align         buffer size alignment (0 = default, 1 = no alignment)
    /// @return              required buffer size, or negative error code on failure
    pub fn av_samples_get_buffer_size(
        linesize: *mut libc::c_int,
        nb_channels: libc::c_int,
        nb_samples: libc::c_int,
        sample_fmt: AVSampleFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Fill plane data pointers and linesize for samples with sample
    /// format sample_fmt.
    ///
    /// The audio_data array is filled with the pointers to the samples data planes:
    /// for planar, set the start point of each channel's data within the buffer,
    /// for packed, set the start point of the entire buffer only.
    ///
    /// The value pointed to by linesize is set to the aligned size of each
    /// channel's data buffer for planar layout, or to the aligned size of the
    /// buffer for all channels for packed layout.
    ///
    /// The buffer in buf must be big enough to contain all the samples
    /// (use av_samples_get_buffer_size() to compute its minimum size),
    /// otherwise the audio_data pointers will point to invalid data.
    ///
    /// @see enum AVSampleFormat
    /// The documentation for AVSampleFormat describes the data layout.
    ///
    /// @param[out] audio_data  array to be filled with the pointer for each channel
    /// @param[out] linesize    calculated linesize, may be NULL
    /// @param buf              the pointer to a buffer containing the samples
    /// @param nb_channels      the number of channels
    /// @param nb_samples       the number of samples in a single channel
    /// @param sample_fmt       the sample format
    /// @param align            buffer size alignment (0 = default, 1 = no alignment)
    /// @return                 >=0 on success or a negative error code on failure
    /// @todo return minimum size in bytes required for the buffer in case
    /// of success at the next bump
    pub fn av_samples_fill_arrays(
        audio_data: *mut *mut u8,
        linesize: *mut libc::c_int,
        buf: *const u8,
        nb_channels: libc::c_int,
        nb_samples: libc::c_int,
        sample_fmt: AVSampleFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Allocate a samples buffer for nb_samples samples, and fill data pointers and
    /// linesize accordingly.
    /// The allocated samples buffer can be freed by using av_freep(&audio_data[0])
    /// Allocated data will be initialized to silence.
    ///
    /// @see enum AVSampleFormat
    /// The documentation for AVSampleFormat describes the data layout.
    ///
    /// @param[out] audio_data  array to be filled with the pointer for each channel
    /// @param[out] linesize    aligned size for audio buffer(s), may be NULL
    /// @param nb_channels      number of audio channels
    /// @param nb_samples       number of samples per channel
    /// @param align            buffer size alignment (0 = default, 1 = no alignment)
    /// @return                 >=0 on success or a negative error code on failure
    /// @todo return the size of the allocated buffer in case of success at the next bump
    /// @see av_samples_fill_arrays()
    /// @see av_samples_alloc_array_and_samples()
    pub fn av_samples_alloc(
        audio_data: *mut *mut u8,
        linesize: *mut libc::c_int,
        nb_channels: libc::c_int,
        nb_samples: libc::c_int,
        sample_fmt: AVSampleFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Allocate a data pointers array, samples buffer for nb_samples
    /// samples, and fill data pointers and linesize accordingly.
    ///
    /// This is the same as av_samples_alloc(), but also allocates the data
    /// pointers array.
    ///
    /// @see av_samples_alloc()
    pub fn av_samples_alloc_array_and_samples(
        audio_data: *mut *mut *mut u8,
        linesize: *mut libc::c_int,
        nb_channels: libc::c_int,
        nb_samples: libc::c_int,
        sample_fmt: AVSampleFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Copy samples from src to dst.
    ///
    /// @param dst destination array of pointers to data planes
    /// @param src source array of pointers to data planes
    /// @param dst_offset offset in samples at which the data will be written to dst
    /// @param src_offset offset in samples at which the data will be read from src
    /// @param nb_samples number of samples to be copied
    /// @param nb_channels number of audio channels
    /// @param sample_fmt audio sample format
    pub fn av_samples_copy(
        dst: *mut *mut u8,
        src: *const *const u8,
        dst_offset: libc::c_int,
        src_offset: libc::c_int,
        nb_samples: libc::c_int,
        nb_channels: libc::c_int,
        sample_fmt: AVSampleFormat,
    ) -> libc::c_int;
}
extern "C" {
    /// Fill an audio buffer with silence.
    ///
    /// @param audio_data  array of pointers to data planes
    /// @param offset      offset in samples at which to start filling
    /// @param nb_samples  number of samples to fill
    /// @param nb_channels number of audio channels
    /// @param sample_fmt  audio sample format
    pub fn av_samples_set_silence(
        audio_data: *mut *mut u8,
        offset: libc::c_int,
        nb_samples: libc::c_int,
        nb_channels: libc::c_int,
        sample_fmt: AVSampleFormat,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBuffer {
    _unused: [u8; 0],
}
/// A reference to a data buffer.
///
/// The size of this struct is not a part of the public ABI and it is not meant
/// to be allocated directly.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBufferRef {
    pub buffer: *mut AVBuffer,
    /// The data buffer. It is considered writable if and only if
    /// this is the only reference to the buffer, in which case
    /// av_buffer_is_writable() returns 1.
    pub data: *mut u8,
    /// Size of data in bytes.
    pub size: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVBufferRef() {
    assert_eq!(
        ::std::mem::size_of::<AVBufferRef>(),
        24usize,
        concat!("Size of: ", stringify!(AVBufferRef))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBufferRef>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBufferRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferRef>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferRef>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferRef>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferRef),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    /// Allocate an AVBuffer of the given size using av_malloc().
    ///
    /// @return an AVBufferRef of given size or NULL when out of memory
    pub fn av_buffer_alloc(size: libc::c_int) -> *mut AVBufferRef;
}
extern "C" {
    /// Same as av_buffer_alloc(), except the returned buffer will be initialized
    /// to zero.
    pub fn av_buffer_allocz(size: libc::c_int) -> *mut AVBufferRef;
}
extern "C" {
    /// Create an AVBuffer from an existing array.
    ///
    /// If this function is successful, data is owned by the AVBuffer. The caller may
    /// only access data through the returned AVBufferRef and references derived from
    /// it.
    /// If this function fails, data is left untouched.
    /// @param data   data array
    /// @param size   size of data in bytes
    /// @param free   a callback for freeing this buffer's data
    /// @param opaque parameter to be got for processing or passed to free
    /// @param flags  a combination of AV_BUFFER_FLAG_*
    ///
    /// @return an AVBufferRef referring to data on success, NULL on failure.
    pub fn av_buffer_create(
        data: *mut u8,
        size: libc::c_int,
        free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void, data: *mut u8)>,
        opaque: *mut libc::c_void,
        flags: libc::c_int,
    ) -> *mut AVBufferRef;
}
extern "C" {
    /// Default free callback, which calls av_free() on the buffer data.
    /// This function is meant to be passed to av_buffer_create(), not called
    /// directly.
    pub fn av_buffer_default_free(opaque: *mut libc::c_void, data: *mut u8);
}
extern "C" {
    /// Create a new reference to an AVBuffer.
    ///
    /// @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on
    /// failure.
    pub fn av_buffer_ref(buf: *mut AVBufferRef) -> *mut AVBufferRef;
}
extern "C" {
    /// Free a given reference and automatically free the buffer if there are no more
    /// references to it.
    ///
    /// @param buf the reference to be freed. The pointer is set to NULL on return.
    pub fn av_buffer_unref(buf: *mut *mut AVBufferRef);
}
extern "C" {
    /// @return 1 if the caller may write to the data referred to by buf (which is
    /// true if and only if buf is the only reference to the underlying AVBuffer).
    /// Return 0 otherwise.
    /// A positive answer is valid until av_buffer_ref() is called on buf.
    pub fn av_buffer_is_writable(buf: *const AVBufferRef) -> libc::c_int;
}
extern "C" {
    /// @return the opaque parameter set by av_buffer_create.
    pub fn av_buffer_get_opaque(buf: *const AVBufferRef) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_buffer_get_ref_count(buf: *const AVBufferRef) -> libc::c_int;
}
extern "C" {
    /// Create a writable reference from a given buffer reference, avoiding data copy
    /// if possible.
    ///
    /// @param buf buffer reference to make writable. On success, buf is either left
    /// untouched, or it is unreferenced and a new writable AVBufferRef is
    /// written in its place. On failure, buf is left untouched.
    /// @return 0 on success, a negative AVERROR on failure.
    pub fn av_buffer_make_writable(buf: *mut *mut AVBufferRef) -> libc::c_int;
}
extern "C" {
    /// Reallocate a given buffer.
    ///
    /// @param buf  a buffer reference to reallocate. On success, buf will be
    /// unreferenced and a new reference with the required size will be
    /// written in its place. On failure buf will be left untouched. *buf
    /// may be NULL, then a new buffer is allocated.
    /// @param size required new buffer size.
    /// @return 0 on success, a negative AVERROR on failure.
    ///
    /// @note the buffer is actually reallocated with av_realloc() only if it was
    /// initially allocated through av_buffer_realloc(NULL) and there is only one
    /// reference to it (i.e. the one passed to this function). In all other cases
    /// a new buffer is allocated and the data is copied.
    pub fn av_buffer_realloc(buf: *mut *mut AVBufferRef, size: libc::c_int) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBufferPool {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate and initialize a buffer pool.
    ///
    /// @param size size of each buffer in this pool
    /// @param alloc a function that will be used to allocate new buffers when the
    /// pool is empty. May be NULL, then the default allocator will be used
    /// (av_buffer_alloc()).
    /// @return newly created buffer pool on success, NULL on error.
    pub fn av_buffer_pool_init(
        size: libc::c_int,
        alloc: ::std::option::Option<unsafe extern "C" fn(size: libc::c_int) -> *mut AVBufferRef>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    /// Allocate and initialize a buffer pool with a more complex allocator.
    ///
    /// @param size size of each buffer in this pool
    /// @param opaque arbitrary user data used by the allocator
    /// @param alloc a function that will be used to allocate new buffers when the
    /// pool is empty.
    /// @param pool_free a function that will be called immediately before the pool
    /// is freed. I.e. after av_buffer_pool_uninit() is called
    /// by the caller and all the frames are returned to the pool
    /// and freed. It is intended to uninitialize the user opaque
    /// data.
    /// @return newly created buffer pool on success, NULL on error.
    pub fn av_buffer_pool_init2(
        size: libc::c_int,
        opaque: *mut libc::c_void,
        alloc: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut libc::c_void, size: libc::c_int) -> *mut AVBufferRef,
        >,
        pool_free: ::std::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void)>,
    ) -> *mut AVBufferPool;
}
extern "C" {
    /// Mark the pool as being available for freeing. It will actually be freed only
    /// once all the allocated buffers associated with the pool are released. Thus it
    /// is safe to call this function while some of the allocated buffers are still
    /// in use.
    ///
    /// @param pool pointer to the pool to be freed. It will be set to NULL.
    pub fn av_buffer_pool_uninit(pool: *mut *mut AVBufferPool);
}
extern "C" {
    /// Allocate a new AVBuffer, reusing an old buffer from the pool when available.
    /// This function may be called simultaneously from multiple threads.
    ///
    /// @return a reference to the new buffer on success, NULL on error.
    pub fn av_buffer_pool_get(pool: *mut AVBufferPool) -> *mut AVBufferRef;
}
extern "C" {
    /// Return the flags which specify extensions supported by the CPU.
    /// The returned value is affected by av_force_cpu_flags() if that was used
    /// before. So av_get_cpu_flags() can easily be used in an application to
    /// detect the enabled cpu flags.
    pub fn av_get_cpu_flags() -> libc::c_int;
}
extern "C" {
    /// Disables cpu detection and forces the specified flags.
    /// -1 is a special case that disables forcing of specific flags.
    pub fn av_force_cpu_flags(flags: libc::c_int);
}
extern "C" {
    /// Set a mask on flags returned by av_get_cpu_flags().
    /// This function is mainly useful for testing.
    /// Please use av_force_cpu_flags() and av_get_cpu_flags() instead which are more flexible
    pub fn av_set_cpu_flags_mask(mask: libc::c_int);
}
extern "C" {
    /// Parse CPU flags from a string.
    ///
    /// The returned flags contain the specified flags as well as related unspecified flags.
    ///
    /// This function exists only for compatibility with libav.
    /// Please use av_parse_cpu_caps() when possible.
    /// @return a combination of AV_CPU_* flags, negative on error.
    pub fn av_parse_cpu_flags(s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Parse CPU caps from a string and update the given AV_CPU_* flags based on that.
    ///
    /// @return negative on error.
    pub fn av_parse_cpu_caps(flags: *mut libc::c_uint, s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// @return the number of logical CPU cores present.
    pub fn av_cpu_count() -> libc::c_int;
}
extern "C" {
    /// Get the maximum data alignment that may be required by FFmpeg.
    ///
    /// Note that this is affected by the build configuration and the CPU flags mask,
    /// so e.g. if the CPU supports AVX, but libavutil has been built with
    /// --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through
    /// av_set_cpu_flags_mask(), then this function will behave as if AVX is not
    /// present.
    pub fn av_cpu_max_align() -> usize;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVMatrixEncoding {
    AV_MATRIX_ENCODING_NONE = 0,
    AV_MATRIX_ENCODING_DOLBY = 1,
    AV_MATRIX_ENCODING_DPLII = 2,
    AV_MATRIX_ENCODING_DPLIIX = 3,
    AV_MATRIX_ENCODING_DPLIIZ = 4,
    AV_MATRIX_ENCODING_DOLBYEX = 5,
    AV_MATRIX_ENCODING_DOLBYHEADPHONE = 6,
    AV_MATRIX_ENCODING_NB = 7,
}
extern "C" {
    /// Return a channel layout id that matches name, or 0 if no match is found.
    ///
    /// name can be one or several of the following notations,
    /// separated by '+' or '|':
    /// - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,
    /// 5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);
    /// - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,
    /// SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);
    /// - a number of channels, in decimal, followed by 'c', yielding
    /// the default channel layout for that number of channels (@see
    /// av_get_default_channel_layout);
    /// - a channel layout mask, in hexadecimal starting with "0x" (see the
    /// AV_CH_* macros).
    ///
    /// Example: "stereo+FC" = "2c+FC" = "2c+1c" = "0x7"
    pub fn av_get_channel_layout(name: *const libc::c_char) -> u64;
}
extern "C" {
    /// Return a channel layout and the number of channels based on the specified name.
    ///
    /// This function is similar to (@see av_get_channel_layout), but can also parse
    /// unknown channel layout specifications.
    ///
    /// @param[in]  name             channel layout specification string
    /// @param[out] channel_layout   parsed channel layout (0 if unknown)
    /// @param[out] nb_channels      number of channels
    ///
    /// @return 0 on success, AVERROR(EINVAL) if the parsing fails.
    pub fn av_get_extended_channel_layout(
        name: *const libc::c_char,
        channel_layout: *mut u64,
        nb_channels: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Return a description of a channel layout.
    /// If nb_channels is <= 0, it is guessed from the channel_layout.
    ///
    /// @param buf put here the string containing the channel layout
    /// @param buf_size size in bytes of the buffer
    pub fn av_get_channel_layout_string(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        nb_channels: libc::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    /// Append a description of a channel layout to a bprint buffer.
    pub fn av_bprint_channel_layout(
        bp: *mut AVBPrint,
        nb_channels: libc::c_int,
        channel_layout: u64,
    );
}
extern "C" {
    /// Return the number of channels in the channel layout.
    pub fn av_get_channel_layout_nb_channels(channel_layout: u64) -> libc::c_int;
}
extern "C" {
    /// Return default channel layout for a given number of channels.
    pub fn av_get_default_channel_layout(nb_channels: libc::c_int) -> i64;
}
extern "C" {
    /// Get the index of a channel in channel_layout.
    ///
    /// @param channel a channel layout describing exactly one channel which must be
    /// present in channel_layout.
    ///
    /// @return index of channel in channel_layout on success, a negative AVERROR
    /// on error.
    pub fn av_get_channel_layout_channel_index(channel_layout: u64, channel: u64) -> libc::c_int;
}
extern "C" {
    /// Get the channel with the given index in channel_layout.
    pub fn av_channel_layout_extract_channel(channel_layout: u64, index: libc::c_int) -> u64;
}
extern "C" {
    /// Get the name of a given channel.
    ///
    /// @return channel name on success, NULL on error.
    pub fn av_get_channel_name(channel: u64) -> *const libc::c_char;
}
extern "C" {
    /// Get the description of a given channel.
    ///
    /// @param channel  a channel layout with a single channel
    /// @return  channel description on success, NULL on error
    pub fn av_get_channel_description(channel: u64) -> *const libc::c_char;
}
extern "C" {
    /// Get the value and name of a standard channel layout.
    ///
    /// @param[in]  index   index in an internal list, starting at 0
    /// @param[out] layout  channel layout mask
    /// @param[out] name    name of the layout
    /// @return  0  if the layout exists,
    /// <0 if index is beyond the limits
    pub fn av_get_standard_channel_layout(
        index: libc::c_uint,
        layout: *mut u64,
        name: *mut *const libc::c_char,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDictionaryEntry {
    pub key: *mut libc::c_char,
    pub value: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_AVDictionaryEntry() {
    assert_eq!(
        ::std::mem::size_of::<AVDictionaryEntry>(),
        16usize,
        concat!("Size of: ", stringify!(AVDictionaryEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDictionaryEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDictionaryEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDictionaryEntry>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDictionaryEntry),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDictionaryEntry>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDictionaryEntry),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVDictionary {
    _unused: [u8; 0],
}
extern "C" {
    /// Get a dictionary entry with matching key.
    ///
    /// The returned entry key or value must not be changed, or it will
    /// cause undefined behavior.
    ///
    /// To iterate through all the dictionary entries, you can set the matching key
    /// to the null string "" and set the AV_DICT_IGNORE_SUFFIX flag.
    ///
    /// @param prev Set to the previous matching element to find the next.
    /// If set to NULL the first matching element is returned.
    /// @param key matching key
    /// @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved
    /// @return found entry or NULL in case no matching entry was found in the dictionary
    pub fn av_dict_get(
        m: *const AVDictionary,
        key: *const libc::c_char,
        prev: *const AVDictionaryEntry,
        flags: libc::c_int,
    ) -> *mut AVDictionaryEntry;
}
extern "C" {
    /// Get number of entries in dictionary.
    ///
    /// @param m dictionary
    /// @return  number of entries in dictionary
    pub fn av_dict_count(m: *const AVDictionary) -> libc::c_int;
}
extern "C" {
    /// Set the given entry in *pm, overwriting an existing entry.
    ///
    /// Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,
    /// these arguments will be freed on error.
    ///
    /// Warning: Adding a new entry to a dictionary invalidates all existing entries
    /// previously returned with av_dict_get.
    ///
    /// @param pm pointer to a pointer to a dictionary struct. If *pm is NULL
    /// a dictionary struct is allocated and put in *pm.
    /// @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)
    /// @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags).
    /// Passing a NULL value will cause an existing entry to be deleted.
    /// @return >= 0 on success otherwise an error code <0
    pub fn av_dict_set(
        pm: *mut *mut AVDictionary,
        key: *const libc::c_char,
        value: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Convenience wrapper for av_dict_set that converts the value to a string
    /// and stores it.
    ///
    /// Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.
    pub fn av_dict_set_int(
        pm: *mut *mut AVDictionary,
        key: *const libc::c_char,
        value: i64,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Parse the key/value pairs list and add the parsed entries to a dictionary.
    ///
    /// In case of failure, all the successfully set entries are stored in
    /// *pm. You may need to manually free the created dictionary.
    ///
    /// @param key_val_sep  a 0-terminated list of characters used to separate
    /// key from value
    /// @param pairs_sep    a 0-terminated list of characters used to separate
    /// two pairs from each other
    /// @param flags        flags to use when adding to dictionary.
    /// AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL
    /// are ignored since the key/value tokens will always
    /// be duplicated.
    /// @return             0 on success, negative AVERROR code on failure
    pub fn av_dict_parse_string(
        pm: *mut *mut AVDictionary,
        str: *const libc::c_char,
        key_val_sep: *const libc::c_char,
        pairs_sep: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Copy entries from one AVDictionary struct into another.
    /// @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,
    /// this function will allocate a struct for you and put it in *dst
    /// @param src pointer to source AVDictionary struct
    /// @param flags flags to use when setting entries in *dst
    /// @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag
    /// @return 0 on success, negative AVERROR code on failure. If dst was allocated
    /// by this function, callers should free the associated memory.
    pub fn av_dict_copy(
        dst: *mut *mut AVDictionary,
        src: *const AVDictionary,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Free all the memory allocated for an AVDictionary struct
    /// and all keys and values.
    pub fn av_dict_free(m: *mut *mut AVDictionary);
}
extern "C" {
    /// Get dictionary entries as a string.
    ///
    /// Create a string containing dictionary's entries.
    /// Such string may be passed back to av_dict_parse_string().
    /// @note String is escaped with backslashes ('\').
    ///
    /// @param[in]  m             dictionary
    /// @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.
    /// Buffer must be freed by the caller when is no longer needed.
    /// @param[in]  key_val_sep   character used to separate key from value
    /// @param[in]  pairs_sep     character used to separate two pairs from each other
    /// @return                   >= 0 on success, negative on error
    /// @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.
    pub fn av_dict_get_string(
        m: *const AVDictionary,
        buffer: *mut *mut libc::c_char,
        key_val_sep: libc::c_char,
        pairs_sep: libc::c_char,
    ) -> libc::c_int;
}
#[repr(u32)]
/// @defgroup lavu_frame AVFrame
/// @ingroup lavu_data
///
/// @{
/// AVFrame is an abstraction for reference-counted raw multimedia data.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVFrameSideDataType {
    AV_FRAME_DATA_PANSCAN = 0,
    AV_FRAME_DATA_A53_CC = 1,
    AV_FRAME_DATA_STEREO3D = 2,
    AV_FRAME_DATA_MATRIXENCODING = 3,
    AV_FRAME_DATA_DOWNMIX_INFO = 4,
    AV_FRAME_DATA_REPLAYGAIN = 5,
    AV_FRAME_DATA_DISPLAYMATRIX = 6,
    AV_FRAME_DATA_AFD = 7,
    AV_FRAME_DATA_MOTION_VECTORS = 8,
    AV_FRAME_DATA_SKIP_SAMPLES = 9,
    AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10,
    AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11,
    AV_FRAME_DATA_GOP_TIMECODE = 12,
    AV_FRAME_DATA_SPHERICAL = 13,
    AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14,
    AV_FRAME_DATA_ICC_PROFILE = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVActiveFormatDescription {
    AV_AFD_SAME = 8,
    AV_AFD_4_3 = 9,
    AV_AFD_16_9 = 10,
    AV_AFD_14_9 = 11,
    AV_AFD_4_3_SP_14_9 = 13,
    AV_AFD_16_9_SP_14_9 = 14,
    AV_AFD_SP_4_3 = 15,
}
/// Structure to hold side data for an AVFrame.
///
/// sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added
/// to the end with a minor bump.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFrameSideData {
    pub type_: AVFrameSideDataType,
    pub data: *mut u8,
    pub size: libc::c_int,
    pub metadata: *mut AVDictionary,
    pub buf: *mut AVBufferRef,
}
#[test]
fn bindgen_test_layout_AVFrameSideData() {
    assert_eq!(
        ::std::mem::size_of::<AVFrameSideData>(),
        40usize,
        concat!("Size of: ", stringify!(AVFrameSideData))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFrameSideData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFrameSideData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).metadata as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrameSideData>())).buf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrameSideData),
            "::",
            stringify!(buf)
        )
    );
}
/// This structure describes decoded (raw) audio or video data.
///
/// AVFrame must be allocated using av_frame_alloc(). Note that this only
/// allocates the AVFrame itself, the buffers for the data must be managed
/// through other means (see below).
/// AVFrame must be freed with av_frame_free().
///
/// AVFrame is typically allocated once and then reused multiple times to hold
/// different data (e.g. a single AVFrame to hold frames received from a
/// decoder). In such a case, av_frame_unref() will free any references held by
/// the frame and reset it to its original clean state before it
/// is reused again.
///
/// The data described by an AVFrame is usually reference counted through the
/// AVBuffer API. The underlying buffer references are stored in AVFrame.buf /
/// AVFrame.extended_buf. An AVFrame is considered to be reference counted if at
/// least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a case,
/// every single data plane must be contained in one of the buffers in
/// AVFrame.buf or AVFrame.extended_buf.
/// There may be a single buffer for all the data, or one separate buffer for
/// each plane, or anything in between.
///
/// sizeof(AVFrame) is not a part of the public ABI, so new fields may be added
/// to the end with a minor bump.
///
/// Fields can be accessed through AVOptions, the name string used, matches the
/// C structure field name for fields accessible through AVOptions. The AVClass
/// for AVFrame can be obtained from avcodec_get_frame_class()
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFrame {
    /// pointer to the picture/channel planes.
    /// This might be different from the first allocated byte
    ///
    /// Some decoders access areas outside 0,0 - width,height, please
    /// see avcodec_align_dimensions2(). Some filters and swscale can read
    /// up to 16 bytes beyond the planes, if these filters are to be used,
    /// then 16 extra bytes must be allocated.
    ///
    /// NOTE: Except for hwaccel formats, pointers not needed by the format
    /// MUST be set to NULL.
    pub data: [*mut u8; 8usize],
    /// For video, size in bytes of each picture line.
    /// For audio, size in bytes of each plane.
    ///
    /// For audio, only linesize[0] may be set. For planar audio, each channel
    /// plane must be the same size.
    ///
    /// For video the linesizes should be multiples of the CPUs alignment
    /// preference, this is 16 or 32 for modern desktop CPUs.
    /// Some code requires such alignment other code can be slower without
    /// correct alignment, for yet other it makes no difference.
    ///
    /// @note The linesize may be larger than the size of usable data -- there
    /// may be extra padding present for performance reasons.
    pub linesize: [libc::c_int; 8usize],
    /// pointers to the data planes/channels.
    ///
    /// For video, this should simply point to data[].
    ///
    /// For planar audio, each channel has a separate data pointer, and
    /// linesize[0] contains the size of each channel buffer.
    /// For packed audio, there is just one data pointer, and linesize[0]
    /// contains the total size of the buffer for all channels.
    ///
    /// Note: Both data and extended_data should always be set in a valid frame,
    /// but for planar audio with more channels that can fit in data,
    /// extended_data must be used in order to access all channels.
    pub extended_data: *mut *mut u8,
    /// @name Video dimensions
    /// Video frames only. The coded dimensions (in pixels) of the video frame,
    /// i.e. the size of the rectangle that contains some well-defined values.
    ///
    /// @note The part of the frame intended for display/presentation is further
    /// restricted by the @ref cropping "Cropping rectangle".
    /// @{
    pub width: libc::c_int,
    /// @name Video dimensions
    /// Video frames only. The coded dimensions (in pixels) of the video frame,
    /// i.e. the size of the rectangle that contains some well-defined values.
    ///
    /// @note The part of the frame intended for display/presentation is further
    /// restricted by the @ref cropping "Cropping rectangle".
    /// @{
    pub height: libc::c_int,
    /// number of audio samples (per channel) described by this frame
    pub nb_samples: libc::c_int,
    /// format of the frame, -1 if unknown or unset
    /// Values correspond to enum AVPixelFormat for video frames,
    /// enum AVSampleFormat for audio)
    pub format: libc::c_int,
    /// 1 -> keyframe, 0-> not
    pub key_frame: libc::c_int,
    /// Picture type of the frame.
    pub pict_type: AVPictureType,
    /// Sample aspect ratio for the video frame, 0/1 if unknown/unspecified.
    pub sample_aspect_ratio: AVRational,
    /// Presentation timestamp in time_base units (time when frame should be shown to user).
    pub pts: i64,
    /// PTS copied from the AVPacket that was decoded to produce this frame.
    /// @deprecated use the pts field instead
    pub pkt_pts: i64,
    /// DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn't used)
    /// This is also the Presentation time of this AVFrame calculated from
    /// only AVPacket.dts values without pts values.
    pub pkt_dts: i64,
    /// picture number in bitstream order
    pub coded_picture_number: libc::c_int,
    /// picture number in display order
    pub display_picture_number: libc::c_int,
    /// quality (between 1 (good) and FF_LAMBDA_MAX (bad))
    pub quality: libc::c_int,
    /// for some private data of the user
    pub opaque: *mut libc::c_void,
    /// @deprecated unused
    pub error: [u64; 8usize],
    /// When decoding, this signals how much the picture must be delayed.
    /// extra_delay = repeat_pict / (2*fps)
    pub repeat_pict: libc::c_int,
    /// The content of the picture is interlaced.
    pub interlaced_frame: libc::c_int,
    /// If the content is interlaced, is top field displayed first.
    pub top_field_first: libc::c_int,
    /// Tell user application that palette has changed from previous frame.
    pub palette_has_changed: libc::c_int,
    /// reordered opaque 64 bits (generally an integer or a double precision float
    /// PTS but can be anything).
    /// The user sets AVCodecContext.reordered_opaque to represent the input at
    /// that time,
    /// the decoder reorders values as needed and sets AVFrame.reordered_opaque
    /// to exactly one of the values provided by the user through AVCodecContext.reordered_opaque
    /// @deprecated in favor of pkt_pts
    pub reordered_opaque: i64,
    /// Sample rate of the audio data.
    pub sample_rate: libc::c_int,
    /// Channel layout of the audio data.
    pub channel_layout: u64,
    /// AVBuffer references backing the data for this frame. If all elements of
    /// this array are NULL, then this frame is not reference counted. This array
    /// must be filled contiguously -- if buf[i] is non-NULL then buf[j] must
    /// also be non-NULL for all j < i.
    ///
    /// There may be at most one AVBuffer per data plane, so for video this array
    /// always contains all the references. For planar audio with more than
    /// AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in
    /// this array. Then the extra AVBufferRef pointers are stored in the
    /// extended_buf array.
    pub buf: [*mut AVBufferRef; 8usize],
    /// For planar audio which requires more than AV_NUM_DATA_POINTERS
    /// AVBufferRef pointers, this array will hold all the references which
    /// cannot fit into AVFrame.buf.
    ///
    /// Note that this is different from AVFrame.extended_data, which always
    /// contains all the pointers. This array only contains the extra pointers,
    /// which cannot fit into AVFrame.buf.
    ///
    /// This array is always allocated using av_malloc() by whoever constructs
    /// the frame. It is freed in av_frame_unref().
    pub extended_buf: *mut *mut AVBufferRef,
    /// Number of elements in extended_buf.
    pub nb_extended_buf: libc::c_int,
    pub side_data: *mut *mut AVFrameSideData,
    pub nb_side_data: libc::c_int,
    /// Frame flags, a combination of @ref lavu_frame_flags
    pub flags: libc::c_int,
    /// MPEG vs JPEG YUV range.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    /// YUV colorspace type.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub colorspace: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    /// frame timestamp estimated using various heuristics, in stream time base
    /// - encoding: unused
    /// - decoding: set by libavcodec, read by user.
    pub best_effort_timestamp: i64,
    /// reordered pos from the last AVPacket that has been input into the decoder
    /// - encoding: unused
    /// - decoding: Read by user.
    pub pkt_pos: i64,
    /// duration of the corresponding packet, expressed in
    /// AVStream->time_base units, 0 if unknown.
    /// - encoding: unused
    /// - decoding: Read by user.
    pub pkt_duration: i64,
    /// metadata.
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub metadata: *mut AVDictionary,
    /// decode error flags of the frame, set to a combination of
    /// FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there
    /// were errors during the decoding.
    /// - encoding: unused
    /// - decoding: set by libavcodec, read by user.
    pub decode_error_flags: libc::c_int,
    /// number of audio channels, only used for audio.
    /// - encoding: unused
    /// - decoding: Read by user.
    pub channels: libc::c_int,
    /// size of the corresponding packet containing the compressed
    /// frame.
    /// It is set to a negative value if unknown.
    /// - encoding: unused
    /// - decoding: set by libavcodec, read by user.
    pub pkt_size: libc::c_int,
    /// QP table
    pub qscale_table: *mut i8,
    /// QP store stride
    pub qstride: libc::c_int,
    pub qscale_type: libc::c_int,
    pub qp_table_buf: *mut AVBufferRef,
    /// For hwaccel-format frames, this should be a reference to the
    /// AVHWFramesContext describing the frame.
    pub hw_frames_ctx: *mut AVBufferRef,
    /// AVBufferRef for free use by the API user. FFmpeg will never check the
    /// contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when
    /// the frame is unreferenced. av_frame_copy_props() calls create a new
    /// reference with av_buffer_ref() for the target frame's opaque_ref field.
    ///
    /// This is unrelated to the opaque field, although it serves a similar
    /// purpose.
    pub opaque_ref: *mut AVBufferRef,
    /// @anchor cropping
    /// @name Cropping
    /// Video frames only. The number of pixels to discard from the the
    /// top/bottom/left/right border of the frame to obtain the sub-rectangle of
    /// the frame intended for presentation.
    /// @{
    pub crop_top: usize,
    pub crop_bottom: usize,
    pub crop_left: usize,
    pub crop_right: usize,
}
#[test]
fn bindgen_test_layout_AVFrame() {
    assert_eq!(
        ::std::mem::size_of::<AVFrame>(),
        528usize,
        concat!("Size of: ", stringify!(AVFrame))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFrame>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFrame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).linesize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).extended_data as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(extended_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).width as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).height as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).nb_samples as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).format as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).key_frame as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(key_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pict_type as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pict_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).sample_aspect_ratio as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pts as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_pts as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_dts as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).coded_picture_number as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(coded_picture_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).display_picture_number as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(display_picture_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).quality as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(quality)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).opaque as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).error as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).repeat_pict as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(repeat_pict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).interlaced_frame as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(interlaced_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).top_field_first as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(top_field_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).palette_has_changed as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(palette_has_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).reordered_opaque as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(reordered_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).sample_rate as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).channel_layout as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).buf as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).extended_buf as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(extended_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).nb_extended_buf as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_extended_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).side_data as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).nb_side_data as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(nb_side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).flags as *const _ as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).color_range as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).color_primaries as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).color_trc as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).colorspace as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).chroma_location as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(chroma_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).best_effort_timestamp as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(best_effort_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_pos as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_duration as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).metadata as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).decode_error_flags as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(decode_error_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).channels as *const _ as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).pkt_size as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(pkt_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).qscale_table as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(qscale_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).qstride as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(qstride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).qscale_type as *const _ as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(qscale_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).qp_table_buf as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(qp_table_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).hw_frames_ctx as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).opaque_ref as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(opaque_ref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_top as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_bottom as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_left as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrame>())).crop_right as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrame),
            "::",
            stringify!(crop_right)
        )
    );
}
extern "C" {
    /// Accessors for some AVFrame fields. These used to be provided for ABI
    /// compatibility, and do not need to be used anymore.
    pub fn av_frame_get_best_effort_timestamp(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_best_effort_timestamp(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_duration(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_duration(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_pkt_pos(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_pkt_pos(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channel_layout(frame: *const AVFrame) -> i64;
}
extern "C" {
    pub fn av_frame_set_channel_layout(frame: *mut AVFrame, val: i64);
}
extern "C" {
    pub fn av_frame_get_channels(frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_set_channels(frame: *mut AVFrame, val: libc::c_int);
}
extern "C" {
    pub fn av_frame_get_sample_rate(frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_set_sample_rate(frame: *mut AVFrame, val: libc::c_int);
}
extern "C" {
    pub fn av_frame_get_metadata(frame: *const AVFrame) -> *mut AVDictionary;
}
extern "C" {
    pub fn av_frame_set_metadata(frame: *mut AVFrame, val: *mut AVDictionary);
}
extern "C" {
    pub fn av_frame_get_decode_error_flags(frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_set_decode_error_flags(frame: *mut AVFrame, val: libc::c_int);
}
extern "C" {
    pub fn av_frame_get_pkt_size(frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_set_pkt_size(frame: *mut AVFrame, val: libc::c_int);
}
extern "C" {
    pub fn avpriv_frame_get_metadatap(frame: *mut AVFrame) -> *mut *mut AVDictionary;
}
extern "C" {
    pub fn av_frame_get_qp_table(
        f: *mut AVFrame,
        stride: *mut libc::c_int,
        type_: *mut libc::c_int,
    ) -> *mut i8;
}
extern "C" {
    pub fn av_frame_set_qp_table(
        f: *mut AVFrame,
        buf: *mut AVBufferRef,
        stride: libc::c_int,
        type_: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_frame_get_colorspace(frame: *const AVFrame) -> AVColorSpace;
}
extern "C" {
    pub fn av_frame_set_colorspace(frame: *mut AVFrame, val: AVColorSpace);
}
extern "C" {
    pub fn av_frame_get_color_range(frame: *const AVFrame) -> AVColorRange;
}
extern "C" {
    pub fn av_frame_set_color_range(frame: *mut AVFrame, val: AVColorRange);
}
extern "C" {
    /// Get the name of a colorspace.
    /// @return a static string identifying the colorspace; can be NULL.
    pub fn av_get_colorspace_name(val: AVColorSpace) -> *const libc::c_char;
}
extern "C" {
    /// Allocate an AVFrame and set its fields to default values.  The resulting
    /// struct must be freed using av_frame_free().
    ///
    /// @return An AVFrame filled with default values or NULL on failure.
    ///
    /// @note this only allocates the AVFrame itself, not the data buffers. Those
    /// must be allocated through other means, e.g. with av_frame_get_buffer() or
    /// manually.
    pub fn av_frame_alloc() -> *mut AVFrame;
}
extern "C" {
    /// Free the frame and any dynamically allocated objects in it,
    /// e.g. extended_data. If the frame is reference counted, it will be
    /// unreferenced first.
    ///
    /// @param frame frame to be freed. The pointer will be set to NULL.
    pub fn av_frame_free(frame: *mut *mut AVFrame);
}
extern "C" {
    /// Set up a new reference to the data described by the source frame.
    ///
    /// Copy frame properties from src to dst and create a new reference for each
    /// AVBufferRef from src.
    ///
    /// If src is not reference counted, new buffers are allocated and the data is
    /// copied.
    ///
    /// @warning: dst MUST have been either unreferenced with av_frame_unref(dst),
    /// or newly allocated with av_frame_alloc() before calling this
    /// function, or undefined behavior will occur.
    ///
    /// @return 0 on success, a negative AVERROR on error
    pub fn av_frame_ref(dst: *mut AVFrame, src: *const AVFrame) -> libc::c_int;
}
extern "C" {
    /// Create a new frame that references the same data as src.
    ///
    /// This is a shortcut for av_frame_alloc()+av_frame_ref().
    ///
    /// @return newly created AVFrame on success, NULL on error.
    pub fn av_frame_clone(src: *const AVFrame) -> *mut AVFrame;
}
extern "C" {
    /// Unreference all the buffers referenced by frame and reset the frame fields.
    pub fn av_frame_unref(frame: *mut AVFrame);
}
extern "C" {
    /// Move everything contained in src to dst and reset src.
    ///
    /// @warning: dst is not unreferenced, but directly overwritten without reading
    /// or deallocating its contents. Call av_frame_unref(dst) manually
    /// before calling this function to ensure that no memory is leaked.
    pub fn av_frame_move_ref(dst: *mut AVFrame, src: *mut AVFrame);
}
extern "C" {
    /// Allocate new buffer(s) for audio or video data.
    ///
    /// The following fields must be set on frame before calling this function:
    /// - format (pixel format for video, sample format for audio)
    /// - width and height for video
    /// - nb_samples and channel_layout for audio
    ///
    /// This function will fill AVFrame.data and AVFrame.buf arrays and, if
    /// necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.
    /// For planar formats, one buffer will be allocated for each plane.
    ///
    /// @warning: if frame already has been allocated, calling this function will
    /// leak memory. In addition, undefined behavior can occur in certain
    /// cases.
    ///
    /// @param frame frame in which to store the new buffers.
    /// @param align Required buffer size alignment. If equal to 0, alignment will be
    /// chosen automatically for the current CPU. It is highly
    /// recommended to pass 0 here unless you know what you are doing.
    ///
    /// @return 0 on success, a negative AVERROR on error.
    pub fn av_frame_get_buffer(frame: *mut AVFrame, align: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// Check if the frame data is writable.
    ///
    /// @return A positive value if the frame data is writable (which is true if and
    /// only if each of the underlying buffers has only one reference, namely the one
    /// stored in this frame). Return 0 otherwise.
    ///
    /// If 1 is returned the answer is valid until av_buffer_ref() is called on any
    /// of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).
    ///
    /// @see av_frame_make_writable(), av_buffer_is_writable()
    pub fn av_frame_is_writable(frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    /// Ensure that the frame data is writable, avoiding data copy if possible.
    ///
    /// Do nothing if the frame is writable, allocate new buffers and copy the data
    /// if it is not.
    ///
    /// @return 0 on success, a negative AVERROR on error.
    ///
    /// @see av_frame_is_writable(), av_buffer_is_writable(),
    /// av_buffer_make_writable()
    pub fn av_frame_make_writable(frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    /// Copy the frame data from src to dst.
    ///
    /// This function does not allocate anything, dst must be already initialized and
    /// allocated with the same parameters as src.
    ///
    /// This function only copies the frame data (i.e. the contents of the data /
    /// extended data arrays), not any other properties.
    ///
    /// @return >= 0 on success, a negative AVERROR on error.
    pub fn av_frame_copy(dst: *mut AVFrame, src: *const AVFrame) -> libc::c_int;
}
extern "C" {
    /// Copy only "metadata" fields from src to dst.
    ///
    /// Metadata for the purpose of this function are those fields that do not affect
    /// the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample
    /// aspect ratio (for video), but not width/height or channel layout.
    /// Side data is also copied.
    pub fn av_frame_copy_props(dst: *mut AVFrame, src: *const AVFrame) -> libc::c_int;
}
extern "C" {
    /// Get the buffer reference a given data plane is stored in.
    ///
    /// @param plane index of the data plane of interest in frame->extended_data.
    ///
    /// @return the buffer reference that contains the plane or NULL if the input
    /// frame is not valid.
    pub fn av_frame_get_plane_buffer(frame: *mut AVFrame, plane: libc::c_int) -> *mut AVBufferRef;
}
extern "C" {
    /// Add a new side data to a frame.
    ///
    /// @param frame a frame to which the side data should be added
    /// @param type type of the added side data
    /// @param size size of the side data
    ///
    /// @return newly added side data on success, NULL on error
    pub fn av_frame_new_side_data(
        frame: *mut AVFrame,
        type_: AVFrameSideDataType,
        size: libc::c_int,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    /// @return a pointer to the side data of a given type on success, NULL if there
    /// is no side data with such type in this frame.
    pub fn av_frame_get_side_data(
        frame: *const AVFrame,
        type_: AVFrameSideDataType,
    ) -> *mut AVFrameSideData;
}
extern "C" {
    /// If side data of the supplied type exists in the frame, free it and remove it
    /// from the frame.
    pub fn av_frame_remove_side_data(frame: *mut AVFrame, type_: AVFrameSideDataType);
}
pub const AV_FRAME_CROP_UNALIGNED: _bindgen_ty_1 = _bindgen_ty_1::AV_FRAME_CROP_UNALIGNED;
#[repr(u32)]
/// Flags for frame cropping.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 {
    AV_FRAME_CROP_UNALIGNED = 1,
}
extern "C" {
    /// Crop the given video AVFrame according to its crop_left/crop_top/crop_right/
    /// crop_bottom fields. If cropping is successful, the function will adjust the
    /// data pointers and the width/height fields, and set the crop fields to 0.
    ///
    /// In all cases, the cropping boundaries will be rounded to the inherent
    /// alignment of the pixel format. In some cases, such as for opaque hwaccel
    /// formats, the left/top cropping is ignored. The crop fields are set to 0 even
    /// if the cropping was rounded or ignored.
    ///
    /// @param frame the frame which should be cropped
    /// @param flags Some combination of AV_FRAME_CROP_* flags, or 0.
    ///
    /// @return >= 0 on success, a negative AVERROR on error. If the cropping fields
    /// were invalid, AVERROR(ERANGE) is returned, and nothing is changed.
    pub fn av_frame_apply_cropping(frame: *mut AVFrame, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// @return a string identifying the side data type
    pub fn av_frame_side_data_name(type_: AVFrameSideDataType) -> *const libc::c_char;
}
pub const AV_CODEC_ID_PCM_S16LE: AVCodecID = AVCodecID::AV_CODEC_ID_FIRST_AUDIO;
pub const AV_CODEC_ID_VIMA: AVCodecID = AVCodecID::AV_CODEC_ID_ADPCM_VIMA;
pub const AV_CODEC_ID_DVD_SUBTITLE: AVCodecID = AVCodecID::AV_CODEC_ID_FIRST_SUBTITLE;
pub const AV_CODEC_ID_TTF: AVCodecID = AVCodecID::AV_CODEC_ID_FIRST_UNKNOWN;
#[repr(u32)]
/// Identify the syntax and semantics of the bitstream.
/// The principle is roughly:
/// Two decoders with the same ID can decode the same streams.
/// Two encoders with the same ID can encode compatible streams.
/// There may be slight deviations from the principle due to implementation
/// details.
///
/// If you add a codec ID to this list, add it so that
/// 1. no value of an existing codec ID changes (that would break ABI),
/// 2. it is as close as possible to similar codecs
///
/// After adding new codec IDs, do not forget to add an entry to the codec
/// descriptor list and bump libavcodec minor version.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVCodecID {
    AV_CODEC_ID_NONE = 0,
    AV_CODEC_ID_MPEG1VIDEO = 1,
    AV_CODEC_ID_MPEG2VIDEO = 2,
    AV_CODEC_ID_MPEG2VIDEO_XVMC = 3,
    AV_CODEC_ID_H261 = 4,
    AV_CODEC_ID_H263 = 5,
    AV_CODEC_ID_RV10 = 6,
    AV_CODEC_ID_RV20 = 7,
    AV_CODEC_ID_MJPEG = 8,
    AV_CODEC_ID_MJPEGB = 9,
    AV_CODEC_ID_LJPEG = 10,
    AV_CODEC_ID_SP5X = 11,
    AV_CODEC_ID_JPEGLS = 12,
    AV_CODEC_ID_MPEG4 = 13,
    AV_CODEC_ID_RAWVIDEO = 14,
    AV_CODEC_ID_MSMPEG4V1 = 15,
    AV_CODEC_ID_MSMPEG4V2 = 16,
    AV_CODEC_ID_MSMPEG4V3 = 17,
    AV_CODEC_ID_WMV1 = 18,
    AV_CODEC_ID_WMV2 = 19,
    AV_CODEC_ID_H263P = 20,
    AV_CODEC_ID_H263I = 21,
    AV_CODEC_ID_FLV1 = 22,
    AV_CODEC_ID_SVQ1 = 23,
    AV_CODEC_ID_SVQ3 = 24,
    AV_CODEC_ID_DVVIDEO = 25,
    AV_CODEC_ID_HUFFYUV = 26,
    AV_CODEC_ID_CYUV = 27,
    AV_CODEC_ID_H264 = 28,
    AV_CODEC_ID_INDEO3 = 29,
    AV_CODEC_ID_VP3 = 30,
    AV_CODEC_ID_THEORA = 31,
    AV_CODEC_ID_ASV1 = 32,
    AV_CODEC_ID_ASV2 = 33,
    AV_CODEC_ID_FFV1 = 34,
    AV_CODEC_ID_4XM = 35,
    AV_CODEC_ID_VCR1 = 36,
    AV_CODEC_ID_CLJR = 37,
    AV_CODEC_ID_MDEC = 38,
    AV_CODEC_ID_ROQ = 39,
    AV_CODEC_ID_INTERPLAY_VIDEO = 40,
    AV_CODEC_ID_XAN_WC3 = 41,
    AV_CODEC_ID_XAN_WC4 = 42,
    AV_CODEC_ID_RPZA = 43,
    AV_CODEC_ID_CINEPAK = 44,
    AV_CODEC_ID_WS_VQA = 45,
    AV_CODEC_ID_MSRLE = 46,
    AV_CODEC_ID_MSVIDEO1 = 47,
    AV_CODEC_ID_IDCIN = 48,
    AV_CODEC_ID_8BPS = 49,
    AV_CODEC_ID_SMC = 50,
    AV_CODEC_ID_FLIC = 51,
    AV_CODEC_ID_TRUEMOTION1 = 52,
    AV_CODEC_ID_VMDVIDEO = 53,
    AV_CODEC_ID_MSZH = 54,
    AV_CODEC_ID_ZLIB = 55,
    AV_CODEC_ID_QTRLE = 56,
    AV_CODEC_ID_TSCC = 57,
    AV_CODEC_ID_ULTI = 58,
    AV_CODEC_ID_QDRAW = 59,
    AV_CODEC_ID_VIXL = 60,
    AV_CODEC_ID_QPEG = 61,
    AV_CODEC_ID_PNG = 62,
    AV_CODEC_ID_PPM = 63,
    AV_CODEC_ID_PBM = 64,
    AV_CODEC_ID_PGM = 65,
    AV_CODEC_ID_PGMYUV = 66,
    AV_CODEC_ID_PAM = 67,
    AV_CODEC_ID_FFVHUFF = 68,
    AV_CODEC_ID_RV30 = 69,
    AV_CODEC_ID_RV40 = 70,
    AV_CODEC_ID_VC1 = 71,
    AV_CODEC_ID_WMV3 = 72,
    AV_CODEC_ID_LOCO = 73,
    AV_CODEC_ID_WNV1 = 74,
    AV_CODEC_ID_AASC = 75,
    AV_CODEC_ID_INDEO2 = 76,
    AV_CODEC_ID_FRAPS = 77,
    AV_CODEC_ID_TRUEMOTION2 = 78,
    AV_CODEC_ID_BMP = 79,
    AV_CODEC_ID_CSCD = 80,
    AV_CODEC_ID_MMVIDEO = 81,
    AV_CODEC_ID_ZMBV = 82,
    AV_CODEC_ID_AVS = 83,
    AV_CODEC_ID_SMACKVIDEO = 84,
    AV_CODEC_ID_NUV = 85,
    AV_CODEC_ID_KMVC = 86,
    AV_CODEC_ID_FLASHSV = 87,
    AV_CODEC_ID_CAVS = 88,
    AV_CODEC_ID_JPEG2000 = 89,
    AV_CODEC_ID_VMNC = 90,
    AV_CODEC_ID_VP5 = 91,
    AV_CODEC_ID_VP6 = 92,
    AV_CODEC_ID_VP6F = 93,
    AV_CODEC_ID_TARGA = 94,
    AV_CODEC_ID_DSICINVIDEO = 95,
    AV_CODEC_ID_TIERTEXSEQVIDEO = 96,
    AV_CODEC_ID_TIFF = 97,
    AV_CODEC_ID_GIF = 98,
    AV_CODEC_ID_DXA = 99,
    AV_CODEC_ID_DNXHD = 100,
    AV_CODEC_ID_THP = 101,
    AV_CODEC_ID_SGI = 102,
    AV_CODEC_ID_C93 = 103,
    AV_CODEC_ID_BETHSOFTVID = 104,
    AV_CODEC_ID_PTX = 105,
    AV_CODEC_ID_TXD = 106,
    AV_CODEC_ID_VP6A = 107,
    AV_CODEC_ID_AMV = 108,
    AV_CODEC_ID_VB = 109,
    AV_CODEC_ID_PCX = 110,
    AV_CODEC_ID_SUNRAST = 111,
    AV_CODEC_ID_INDEO4 = 112,
    AV_CODEC_ID_INDEO5 = 113,
    AV_CODEC_ID_MIMIC = 114,
    AV_CODEC_ID_RL2 = 115,
    AV_CODEC_ID_ESCAPE124 = 116,
    AV_CODEC_ID_DIRAC = 117,
    AV_CODEC_ID_BFI = 118,
    AV_CODEC_ID_CMV = 119,
    AV_CODEC_ID_MOTIONPIXELS = 120,
    AV_CODEC_ID_TGV = 121,
    AV_CODEC_ID_TGQ = 122,
    AV_CODEC_ID_TQI = 123,
    AV_CODEC_ID_AURA = 124,
    AV_CODEC_ID_AURA2 = 125,
    AV_CODEC_ID_V210X = 126,
    AV_CODEC_ID_TMV = 127,
    AV_CODEC_ID_V210 = 128,
    AV_CODEC_ID_DPX = 129,
    AV_CODEC_ID_MAD = 130,
    AV_CODEC_ID_FRWU = 131,
    AV_CODEC_ID_FLASHSV2 = 132,
    AV_CODEC_ID_CDGRAPHICS = 133,
    AV_CODEC_ID_R210 = 134,
    AV_CODEC_ID_ANM = 135,
    AV_CODEC_ID_BINKVIDEO = 136,
    AV_CODEC_ID_IFF_ILBM = 137,
    AV_CODEC_ID_KGV1 = 138,
    AV_CODEC_ID_YOP = 139,
    AV_CODEC_ID_VP8 = 140,
    AV_CODEC_ID_PICTOR = 141,
    AV_CODEC_ID_ANSI = 142,
    AV_CODEC_ID_A64_MULTI = 143,
    AV_CODEC_ID_A64_MULTI5 = 144,
    AV_CODEC_ID_R10K = 145,
    AV_CODEC_ID_MXPEG = 146,
    AV_CODEC_ID_LAGARITH = 147,
    AV_CODEC_ID_PRORES = 148,
    AV_CODEC_ID_JV = 149,
    AV_CODEC_ID_DFA = 150,
    AV_CODEC_ID_WMV3IMAGE = 151,
    AV_CODEC_ID_VC1IMAGE = 152,
    AV_CODEC_ID_UTVIDEO = 153,
    AV_CODEC_ID_BMV_VIDEO = 154,
    AV_CODEC_ID_VBLE = 155,
    AV_CODEC_ID_DXTORY = 156,
    AV_CODEC_ID_V410 = 157,
    AV_CODEC_ID_XWD = 158,
    AV_CODEC_ID_CDXL = 159,
    AV_CODEC_ID_XBM = 160,
    AV_CODEC_ID_ZEROCODEC = 161,
    AV_CODEC_ID_MSS1 = 162,
    AV_CODEC_ID_MSA1 = 163,
    AV_CODEC_ID_TSCC2 = 164,
    AV_CODEC_ID_MTS2 = 165,
    AV_CODEC_ID_CLLC = 166,
    AV_CODEC_ID_MSS2 = 167,
    AV_CODEC_ID_VP9 = 168,
    AV_CODEC_ID_AIC = 169,
    AV_CODEC_ID_ESCAPE130 = 170,
    AV_CODEC_ID_G2M = 171,
    AV_CODEC_ID_WEBP = 172,
    AV_CODEC_ID_HNM4_VIDEO = 173,
    AV_CODEC_ID_HEVC = 174,
    AV_CODEC_ID_FIC = 175,
    AV_CODEC_ID_ALIAS_PIX = 176,
    AV_CODEC_ID_BRENDER_PIX = 177,
    AV_CODEC_ID_PAF_VIDEO = 178,
    AV_CODEC_ID_EXR = 179,
    AV_CODEC_ID_VP7 = 180,
    AV_CODEC_ID_SANM = 181,
    AV_CODEC_ID_SGIRLE = 182,
    AV_CODEC_ID_MVC1 = 183,
    AV_CODEC_ID_MVC2 = 184,
    AV_CODEC_ID_HQX = 185,
    AV_CODEC_ID_TDSC = 186,
    AV_CODEC_ID_HQ_HQA = 187,
    AV_CODEC_ID_HAP = 188,
    AV_CODEC_ID_DDS = 189,
    AV_CODEC_ID_DXV = 190,
    AV_CODEC_ID_SCREENPRESSO = 191,
    AV_CODEC_ID_RSCC = 192,
    AV_CODEC_ID_Y41P = 32768,
    AV_CODEC_ID_AVRP = 32769,
    AV_CODEC_ID_012V = 32770,
    AV_CODEC_ID_AVUI = 32771,
    AV_CODEC_ID_AYUV = 32772,
    AV_CODEC_ID_TARGA_Y216 = 32773,
    AV_CODEC_ID_V308 = 32774,
    AV_CODEC_ID_V408 = 32775,
    AV_CODEC_ID_YUV4 = 32776,
    AV_CODEC_ID_AVRN = 32777,
    AV_CODEC_ID_CPIA = 32778,
    AV_CODEC_ID_XFACE = 32779,
    AV_CODEC_ID_SNOW = 32780,
    AV_CODEC_ID_SMVJPEG = 32781,
    AV_CODEC_ID_APNG = 32782,
    AV_CODEC_ID_DAALA = 32783,
    AV_CODEC_ID_CFHD = 32784,
    AV_CODEC_ID_TRUEMOTION2RT = 32785,
    AV_CODEC_ID_M101 = 32786,
    AV_CODEC_ID_MAGICYUV = 32787,
    AV_CODEC_ID_SHEERVIDEO = 32788,
    AV_CODEC_ID_YLC = 32789,
    AV_CODEC_ID_PSD = 32790,
    AV_CODEC_ID_PIXLET = 32791,
    AV_CODEC_ID_SPEEDHQ = 32792,
    AV_CODEC_ID_FMVC = 32793,
    AV_CODEC_ID_SCPR = 32794,
    AV_CODEC_ID_CLEARVIDEO = 32795,
    AV_CODEC_ID_XPM = 32796,
    AV_CODEC_ID_AV1 = 32797,
    AV_CODEC_ID_BITPACKED = 32798,
    AV_CODEC_ID_MSCC = 32799,
    AV_CODEC_ID_SRGC = 32800,
    AV_CODEC_ID_SVG = 32801,
    AV_CODEC_ID_GDV = 32802,
    AV_CODEC_ID_FITS = 32803,
    AV_CODEC_ID_FIRST_AUDIO = 65536,
    AV_CODEC_ID_PCM_S16BE = 65537,
    AV_CODEC_ID_PCM_U16LE = 65538,
    AV_CODEC_ID_PCM_U16BE = 65539,
    AV_CODEC_ID_PCM_S8 = 65540,
    AV_CODEC_ID_PCM_U8 = 65541,
    AV_CODEC_ID_PCM_MULAW = 65542,
    AV_CODEC_ID_PCM_ALAW = 65543,
    AV_CODEC_ID_PCM_S32LE = 65544,
    AV_CODEC_ID_PCM_S32BE = 65545,
    AV_CODEC_ID_PCM_U32LE = 65546,
    AV_CODEC_ID_PCM_U32BE = 65547,
    AV_CODEC_ID_PCM_S24LE = 65548,
    AV_CODEC_ID_PCM_S24BE = 65549,
    AV_CODEC_ID_PCM_U24LE = 65550,
    AV_CODEC_ID_PCM_U24BE = 65551,
    AV_CODEC_ID_PCM_S24DAUD = 65552,
    AV_CODEC_ID_PCM_ZORK = 65553,
    AV_CODEC_ID_PCM_S16LE_PLANAR = 65554,
    AV_CODEC_ID_PCM_DVD = 65555,
    AV_CODEC_ID_PCM_F32BE = 65556,
    AV_CODEC_ID_PCM_F32LE = 65557,
    AV_CODEC_ID_PCM_F64BE = 65558,
    AV_CODEC_ID_PCM_F64LE = 65559,
    AV_CODEC_ID_PCM_BLURAY = 65560,
    AV_CODEC_ID_PCM_LXF = 65561,
    AV_CODEC_ID_S302M = 65562,
    AV_CODEC_ID_PCM_S8_PLANAR = 65563,
    AV_CODEC_ID_PCM_S24LE_PLANAR = 65564,
    AV_CODEC_ID_PCM_S32LE_PLANAR = 65565,
    AV_CODEC_ID_PCM_S16BE_PLANAR = 65566,
    AV_CODEC_ID_PCM_S64LE = 67584,
    AV_CODEC_ID_PCM_S64BE = 67585,
    AV_CODEC_ID_PCM_F16LE = 67586,
    AV_CODEC_ID_PCM_F24LE = 67587,
    AV_CODEC_ID_ADPCM_IMA_QT = 69632,
    AV_CODEC_ID_ADPCM_IMA_WAV = 69633,
    AV_CODEC_ID_ADPCM_IMA_DK3 = 69634,
    AV_CODEC_ID_ADPCM_IMA_DK4 = 69635,
    AV_CODEC_ID_ADPCM_IMA_WS = 69636,
    AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637,
    AV_CODEC_ID_ADPCM_MS = 69638,
    AV_CODEC_ID_ADPCM_4XM = 69639,
    AV_CODEC_ID_ADPCM_XA = 69640,
    AV_CODEC_ID_ADPCM_ADX = 69641,
    AV_CODEC_ID_ADPCM_EA = 69642,
    AV_CODEC_ID_ADPCM_G726 = 69643,
    AV_CODEC_ID_ADPCM_CT = 69644,
    AV_CODEC_ID_ADPCM_SWF = 69645,
    AV_CODEC_ID_ADPCM_YAMAHA = 69646,
    AV_CODEC_ID_ADPCM_SBPRO_4 = 69647,
    AV_CODEC_ID_ADPCM_SBPRO_3 = 69648,
    AV_CODEC_ID_ADPCM_SBPRO_2 = 69649,
    AV_CODEC_ID_ADPCM_THP = 69650,
    AV_CODEC_ID_ADPCM_IMA_AMV = 69651,
    AV_CODEC_ID_ADPCM_EA_R1 = 69652,
    AV_CODEC_ID_ADPCM_EA_R3 = 69653,
    AV_CODEC_ID_ADPCM_EA_R2 = 69654,
    AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655,
    AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656,
    AV_CODEC_ID_ADPCM_EA_XAS = 69657,
    AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658,
    AV_CODEC_ID_ADPCM_IMA_ISS = 69659,
    AV_CODEC_ID_ADPCM_G722 = 69660,
    AV_CODEC_ID_ADPCM_IMA_APC = 69661,
    AV_CODEC_ID_ADPCM_VIMA = 69662,
    AV_CODEC_ID_ADPCM_AFC = 71680,
    AV_CODEC_ID_ADPCM_IMA_OKI = 71681,
    AV_CODEC_ID_ADPCM_DTK = 71682,
    AV_CODEC_ID_ADPCM_IMA_RAD = 71683,
    AV_CODEC_ID_ADPCM_G726LE = 71684,
    AV_CODEC_ID_ADPCM_THP_LE = 71685,
    AV_CODEC_ID_ADPCM_PSX = 71686,
    AV_CODEC_ID_ADPCM_AICA = 71687,
    AV_CODEC_ID_ADPCM_IMA_DAT4 = 71688,
    AV_CODEC_ID_ADPCM_MTAF = 71689,
    AV_CODEC_ID_AMR_NB = 73728,
    AV_CODEC_ID_AMR_WB = 73729,
    AV_CODEC_ID_RA_144 = 77824,
    AV_CODEC_ID_RA_288 = 77825,
    AV_CODEC_ID_ROQ_DPCM = 81920,
    AV_CODEC_ID_INTERPLAY_DPCM = 81921,
    AV_CODEC_ID_XAN_DPCM = 81922,
    AV_CODEC_ID_SOL_DPCM = 81923,
    AV_CODEC_ID_SDX2_DPCM = 83968,
    AV_CODEC_ID_GREMLIN_DPCM = 83969,
    AV_CODEC_ID_MP2 = 86016,
    AV_CODEC_ID_MP3 = 86017,
    AV_CODEC_ID_AAC = 86018,
    AV_CODEC_ID_AC3 = 86019,
    AV_CODEC_ID_DTS = 86020,
    AV_CODEC_ID_VORBIS = 86021,
    AV_CODEC_ID_DVAUDIO = 86022,
    AV_CODEC_ID_WMAV1 = 86023,
    AV_CODEC_ID_WMAV2 = 86024,
    AV_CODEC_ID_MACE3 = 86025,
    AV_CODEC_ID_MACE6 = 86026,
    AV_CODEC_ID_VMDAUDIO = 86027,
    AV_CODEC_ID_FLAC = 86028,
    AV_CODEC_ID_MP3ADU = 86029,
    AV_CODEC_ID_MP3ON4 = 86030,
    AV_CODEC_ID_SHORTEN = 86031,
    AV_CODEC_ID_ALAC = 86032,
    AV_CODEC_ID_WESTWOOD_SND1 = 86033,
    AV_CODEC_ID_GSM = 86034,
    AV_CODEC_ID_QDM2 = 86035,
    AV_CODEC_ID_COOK = 86036,
    AV_CODEC_ID_TRUESPEECH = 86037,
    AV_CODEC_ID_TTA = 86038,
    AV_CODEC_ID_SMACKAUDIO = 86039,
    AV_CODEC_ID_QCELP = 86040,
    AV_CODEC_ID_WAVPACK = 86041,
    AV_CODEC_ID_DSICINAUDIO = 86042,
    AV_CODEC_ID_IMC = 86043,
    AV_CODEC_ID_MUSEPACK7 = 86044,
    AV_CODEC_ID_MLP = 86045,
    AV_CODEC_ID_GSM_MS = 86046,
    AV_CODEC_ID_ATRAC3 = 86047,
    AV_CODEC_ID_VOXWARE = 86048,
    AV_CODEC_ID_APE = 86049,
    AV_CODEC_ID_NELLYMOSER = 86050,
    AV_CODEC_ID_MUSEPACK8 = 86051,
    AV_CODEC_ID_SPEEX = 86052,
    AV_CODEC_ID_WMAVOICE = 86053,
    AV_CODEC_ID_WMAPRO = 86054,
    AV_CODEC_ID_WMALOSSLESS = 86055,
    AV_CODEC_ID_ATRAC3P = 86056,
    AV_CODEC_ID_EAC3 = 86057,
    AV_CODEC_ID_SIPR = 86058,
    AV_CODEC_ID_MP1 = 86059,
    AV_CODEC_ID_TWINVQ = 86060,
    AV_CODEC_ID_TRUEHD = 86061,
    AV_CODEC_ID_MP4ALS = 86062,
    AV_CODEC_ID_ATRAC1 = 86063,
    AV_CODEC_ID_BINKAUDIO_RDFT = 86064,
    AV_CODEC_ID_BINKAUDIO_DCT = 86065,
    AV_CODEC_ID_AAC_LATM = 86066,
    AV_CODEC_ID_QDMC = 86067,
    AV_CODEC_ID_CELT = 86068,
    AV_CODEC_ID_G723_1 = 86069,
    AV_CODEC_ID_G729 = 86070,
    AV_CODEC_ID_8SVX_EXP = 86071,
    AV_CODEC_ID_8SVX_FIB = 86072,
    AV_CODEC_ID_BMV_AUDIO = 86073,
    AV_CODEC_ID_RALF = 86074,
    AV_CODEC_ID_IAC = 86075,
    AV_CODEC_ID_ILBC = 86076,
    AV_CODEC_ID_OPUS = 86077,
    AV_CODEC_ID_COMFORT_NOISE = 86078,
    AV_CODEC_ID_TAK = 86079,
    AV_CODEC_ID_METASOUND = 86080,
    AV_CODEC_ID_PAF_AUDIO = 86081,
    AV_CODEC_ID_ON2AVC = 86082,
    AV_CODEC_ID_DSS_SP = 86083,
    AV_CODEC_ID_FFWAVESYNTH = 88064,
    AV_CODEC_ID_SONIC = 88065,
    AV_CODEC_ID_SONIC_LS = 88066,
    AV_CODEC_ID_EVRC = 88067,
    AV_CODEC_ID_SMV = 88068,
    AV_CODEC_ID_DSD_LSBF = 88069,
    AV_CODEC_ID_DSD_MSBF = 88070,
    AV_CODEC_ID_DSD_LSBF_PLANAR = 88071,
    AV_CODEC_ID_DSD_MSBF_PLANAR = 88072,
    AV_CODEC_ID_4GV = 88073,
    AV_CODEC_ID_INTERPLAY_ACM = 88074,
    AV_CODEC_ID_XMA1 = 88075,
    AV_CODEC_ID_XMA2 = 88076,
    AV_CODEC_ID_DST = 88077,
    AV_CODEC_ID_ATRAC3AL = 88078,
    AV_CODEC_ID_ATRAC3PAL = 88079,
    AV_CODEC_ID_DOLBY_E = 88080,
    AV_CODEC_ID_FIRST_SUBTITLE = 94208,
    AV_CODEC_ID_DVB_SUBTITLE = 94209,
    AV_CODEC_ID_TEXT = 94210,
    AV_CODEC_ID_XSUB = 94211,
    AV_CODEC_ID_SSA = 94212,
    AV_CODEC_ID_MOV_TEXT = 94213,
    AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214,
    AV_CODEC_ID_DVB_TELETEXT = 94215,
    AV_CODEC_ID_SRT = 94216,
    AV_CODEC_ID_MICRODVD = 96256,
    AV_CODEC_ID_EIA_608 = 96257,
    AV_CODEC_ID_JACOSUB = 96258,
    AV_CODEC_ID_SAMI = 96259,
    AV_CODEC_ID_REALTEXT = 96260,
    AV_CODEC_ID_STL = 96261,
    AV_CODEC_ID_SUBVIEWER1 = 96262,
    AV_CODEC_ID_SUBVIEWER = 96263,
    AV_CODEC_ID_SUBRIP = 96264,
    AV_CODEC_ID_WEBVTT = 96265,
    AV_CODEC_ID_MPL2 = 96266,
    AV_CODEC_ID_VPLAYER = 96267,
    AV_CODEC_ID_PJS = 96268,
    AV_CODEC_ID_ASS = 96269,
    AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 96270,
    AV_CODEC_ID_FIRST_UNKNOWN = 98304,
    AV_CODEC_ID_SCTE_35 = 98305,
    AV_CODEC_ID_BINTEXT = 100352,
    AV_CODEC_ID_XBIN = 100353,
    AV_CODEC_ID_IDF = 100354,
    AV_CODEC_ID_OTF = 100355,
    AV_CODEC_ID_SMPTE_KLV = 100356,
    AV_CODEC_ID_DVD_NAV = 100357,
    AV_CODEC_ID_TIMED_ID3 = 100358,
    AV_CODEC_ID_BIN_DATA = 100359,
    AV_CODEC_ID_PROBE = 102400,
    AV_CODEC_ID_MPEG2TS = 131072,
    AV_CODEC_ID_MPEG4SYSTEMS = 131073,
    AV_CODEC_ID_FFMETADATA = 135168,
    AV_CODEC_ID_WRAPPED_AVFRAME = 135169,
}
/// This struct describes the properties of a single codec described by an
/// AVCodecID.
/// @see avcodec_descriptor_get()
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecDescriptor {
    pub id: AVCodecID,
    pub type_: AVMediaType,
    /// Name of the codec described by this descriptor. It is non-empty and
    /// unique for each codec descriptor. It should contain alphanumeric
    /// characters and '_' only.
    pub name: *const libc::c_char,
    /// A more descriptive name for this codec. May be NULL.
    pub long_name: *const libc::c_char,
    /// Codec properties, a combination of AV_CODEC_PROP_* flags.
    pub props: libc::c_int,
    /// MIME type(s) associated with the codec.
    /// May be NULL; if not, a NULL-terminated array of MIME types.
    /// The first item is always non-NULL and is the preferred MIME type.
    pub mime_types: *const *const libc::c_char,
    /// If non-NULL, an array of profiles recognized for this codec.
    /// Terminated with FF_PROFILE_UNKNOWN.
    pub profiles: *const AVProfile,
}
#[test]
fn bindgen_test_layout_AVCodecDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecDescriptor>(),
        48usize,
        concat!("Size of: ", stringify!(AVCodecDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).long_name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).props as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(props)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).mime_types as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(mime_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecDescriptor>())).profiles as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecDescriptor),
            "::",
            stringify!(profiles)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum Motion_Est_ID {
    ME_ZERO = 1,
    ME_FULL = 2,
    ME_LOG = 3,
    ME_PHODS = 4,
    ME_EPZS = 5,
    ME_X1 = 6,
    ME_HEX = 7,
    ME_UMH = 8,
    ME_TESA = 9,
    ME_ITER = 50,
}
#[repr(i32)]
/// @ingroup lavc_decoding
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVDiscard {
    AVDISCARD_NONE = -16,
    AVDISCARD_DEFAULT = 0,
    AVDISCARD_NONREF = 8,
    AVDISCARD_BIDIR = 16,
    AVDISCARD_NONINTRA = 24,
    AVDISCARD_NONKEY = 32,
    AVDISCARD_ALL = 48,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVAudioServiceType {
    AV_AUDIO_SERVICE_TYPE_MAIN = 0,
    AV_AUDIO_SERVICE_TYPE_EFFECTS = 1,
    AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2,
    AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3,
    AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4,
    AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5,
    AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6,
    AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7,
    AV_AUDIO_SERVICE_TYPE_KARAOKE = 8,
    AV_AUDIO_SERVICE_TYPE_NB = 9,
}
/// @ingroup lavc_encoding
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct RcOverride {
    pub start_frame: libc::c_int,
    pub end_frame: libc::c_int,
    pub qscale: libc::c_int,
    pub quality_factor: f32,
}
#[test]
fn bindgen_test_layout_RcOverride() {
    assert_eq!(
        ::std::mem::size_of::<RcOverride>(),
        16usize,
        concat!("Size of: ", stringify!(RcOverride))
    );
    assert_eq!(
        ::std::mem::align_of::<RcOverride>(),
        4usize,
        concat!("Alignment of ", stringify!(RcOverride))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RcOverride>())).start_frame as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(start_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RcOverride>())).end_frame as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(end_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RcOverride>())).qscale as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(qscale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RcOverride>())).quality_factor as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(RcOverride),
            "::",
            stringify!(quality_factor)
        )
    );
}
/// Pan Scan area.
/// This specifies the area which should be displayed.
/// Note there may be multiple such areas for one frame.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPanScan {
    /// id
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub id: libc::c_int,
    /// width and height in 1/16 pel
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub width: libc::c_int,
    pub height: libc::c_int,
    /// position of the top left corner in 1/16 pel for up to 3 fields/frames
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub position: [[i16; 2usize]; 3usize],
}
#[test]
fn bindgen_test_layout_AVPanScan() {
    assert_eq!(
        ::std::mem::size_of::<AVPanScan>(),
        24usize,
        concat!("Size of: ", stringify!(AVPanScan))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPanScan>(),
        4usize,
        concat!("Alignment of ", stringify!(AVPanScan))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPanScan>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPanScan>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPanScan>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPanScan>())).position as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPanScan),
            "::",
            stringify!(position)
        )
    );
}
/// This structure describes the bitrate properties of an encoded bitstream. It
/// roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD
/// parameters for H.264/HEVC.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCPBProperties {
    /// Maximum bitrate of the stream, in bits per second.
    /// Zero if unknown or unspecified.
    pub max_bitrate: libc::c_int,
    /// Minimum bitrate of the stream, in bits per second.
    /// Zero if unknown or unspecified.
    pub min_bitrate: libc::c_int,
    /// Average bitrate of the stream, in bits per second.
    /// Zero if unknown or unspecified.
    pub avg_bitrate: libc::c_int,
    /// The size of the buffer to which the ratecontrol is applied, in bits.
    /// Zero if unknown or unspecified.
    pub buffer_size: libc::c_int,
    /// The delay between the time the packet this structure is associated with
    /// is received and the time when it should be decoded, in periods of a 27MHz
    /// clock.
    ///
    /// UINT64_MAX when unknown or unspecified.
    pub vbv_delay: u64,
}
#[test]
fn bindgen_test_layout_AVCPBProperties() {
    assert_eq!(
        ::std::mem::size_of::<AVCPBProperties>(),
        24usize,
        concat!("Size of: ", stringify!(AVCPBProperties))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCPBProperties>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCPBProperties))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).max_bitrate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(max_bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).min_bitrate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(min_bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).avg_bitrate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(avg_bitrate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).buffer_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCPBProperties>())).vbv_delay as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCPBProperties),
            "::",
            stringify!(vbv_delay)
        )
    );
}
#[repr(u32)]
/// @defgroup lavc_packet AVPacket
///
/// Types and functions for working with AVPacket.
/// @{
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVPacketSideDataType {
    AV_PKT_DATA_PALETTE = 0,
    AV_PKT_DATA_NEW_EXTRADATA = 1,
    AV_PKT_DATA_PARAM_CHANGE = 2,
    AV_PKT_DATA_H263_MB_INFO = 3,
    AV_PKT_DATA_REPLAYGAIN = 4,
    AV_PKT_DATA_DISPLAYMATRIX = 5,
    AV_PKT_DATA_STEREO3D = 6,
    AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7,
    AV_PKT_DATA_QUALITY_STATS = 8,
    AV_PKT_DATA_FALLBACK_TRACK = 9,
    AV_PKT_DATA_CPB_PROPERTIES = 10,
    AV_PKT_DATA_SKIP_SAMPLES = 70,
    AV_PKT_DATA_JP_DUALMONO = 71,
    AV_PKT_DATA_STRINGS_METADATA = 72,
    AV_PKT_DATA_SUBTITLE_POSITION = 73,
    AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 74,
    AV_PKT_DATA_WEBVTT_IDENTIFIER = 75,
    AV_PKT_DATA_WEBVTT_SETTINGS = 76,
    AV_PKT_DATA_METADATA_UPDATE = 77,
    AV_PKT_DATA_MPEGTS_STREAM_ID = 78,
    AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 79,
    AV_PKT_DATA_SPHERICAL = 80,
    AV_PKT_DATA_CONTENT_LIGHT_LEVEL = 81,
    AV_PKT_DATA_A53_CC = 82,
    AV_PKT_DATA_NB = 83,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPacketSideData {
    pub data: *mut u8,
    pub size: libc::c_int,
    pub type_: AVPacketSideDataType,
}
#[test]
fn bindgen_test_layout_AVPacketSideData() {
    assert_eq!(
        ::std::mem::size_of::<AVPacketSideData>(),
        16usize,
        concat!("Size of: ", stringify!(AVPacketSideData))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPacketSideData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacketSideData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketSideData>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketSideData>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketSideData>())).type_ as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketSideData),
            "::",
            stringify!(type_)
        )
    );
}
/// This structure stores compressed data. It is typically exported by demuxers
/// and then passed as input to decoders, or received as output from encoders and
/// then passed to muxers.
///
/// For video, it should typically contain one compressed frame. For audio it may
/// contain several compressed frames. Encoders are allowed to output empty
/// packets, with no compressed data, containing only side data
/// (e.g. to update some stream parameters at the end of encoding).
///
/// AVPacket is one of the few structs in FFmpeg, whose size is a part of public
/// ABI. Thus it may be allocated on stack and no new fields can be added to it
/// without libavcodec and libavformat major bump.
///
/// The semantics of data ownership depends on the buf field.
/// If it is set, the packet data is dynamically allocated and is
/// valid indefinitely until a call to av_packet_unref() reduces the
/// reference count to 0.
///
/// If the buf field is not set av_packet_ref() would make a copy instead
/// of increasing the reference count.
///
/// The side data is always allocated with av_malloc(), copied by
/// av_packet_ref() and freed by av_packet_unref().
///
/// @see av_packet_ref
/// @see av_packet_unref
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPacket {
    /// A reference to the reference-counted buffer where the packet data is
    /// stored.
    /// May be NULL, then the packet data is not reference-counted.
    pub buf: *mut AVBufferRef,
    /// Presentation timestamp in AVStream->time_base units; the time at which
    /// the decompressed packet will be presented to the user.
    /// Can be AV_NOPTS_VALUE if it is not stored in the file.
    /// pts MUST be larger or equal to dts as presentation cannot happen before
    /// decompression, unless one wants to view hex dumps. Some formats misuse
    /// the terms dts and pts/cts to mean something different. Such timestamps
    /// must be converted to true pts/dts before they are stored in AVPacket.
    pub pts: i64,
    /// Decompression timestamp in AVStream->time_base units; the time at which
    /// the packet is decompressed.
    /// Can be AV_NOPTS_VALUE if it is not stored in the file.
    pub dts: i64,
    pub data: *mut u8,
    pub size: libc::c_int,
    pub stream_index: libc::c_int,
    /// A combination of AV_PKT_FLAG values
    pub flags: libc::c_int,
    /// Additional packet data that can be provided by the container.
    /// Packet can contain several types of side information.
    pub side_data: *mut AVPacketSideData,
    pub side_data_elems: libc::c_int,
    /// Duration of this packet in AVStream->time_base units, 0 if unknown.
    /// Equals next_pts - this_pts in presentation order.
    pub duration: i64,
    /// < byte position in stream, -1 if unknown
    pub pos: i64,
    /// @deprecated Same as the duration field, but as int64_t. This was required
    /// for Matroska subtitles, whose duration values could overflow when the
    /// duration field was still an int.
    pub convergence_duration: i64,
}
#[test]
fn bindgen_test_layout_AVPacket() {
    assert_eq!(
        ::std::mem::size_of::<AVPacket>(),
        88usize,
        concat!("Size of: ", stringify!(AVPacket))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPacket>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacket))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).pts as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).dts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).stream_index as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(stream_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).side_data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).side_data_elems as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(side_data_elems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).duration as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).pos as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacket>())).convergence_duration as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacket),
            "::",
            stringify!(convergence_duration)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVSideDataParamChangeFlags {
    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 1,
    AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 2,
    AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 4,
    AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecInternal {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVFieldOrder {
    AV_FIELD_UNKNOWN = 0,
    AV_FIELD_PROGRESSIVE = 1,
    AV_FIELD_TT = 2,
    AV_FIELD_BB = 3,
    AV_FIELD_TB = 4,
    AV_FIELD_BT = 5,
}
/// main external API structure.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// You can use AVOptions (av_opt* / av_set/get*()) to access these fields from user
/// applications.
/// The name string for AVOptions options matches the associated command line
/// parameter name and can be found in libavcodec/options_table.h
/// The AVOption/command line parameter names differ in some cases from the C
/// structure field names for historic reasons or brevity.
/// sizeof(AVCodecContext) must not be used outside libav*.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct AVCodecContext {
    /// information on struct for av_log
    /// - set by avcodec_alloc_context3
    pub av_class: *const AVClass,
    pub log_level_offset: libc::c_int,
    pub codec_type: AVMediaType,
    pub codec: *const AVCodec,
    /// @deprecated this field is not used for anything in libavcodec
    pub codec_name: [libc::c_char; 32usize],
    pub codec_id: AVCodecID,
    /// fourcc (LSB first, so "ABCD" -> ('D'<<24) + ('C'<<16) + ('B'<<8) + 'A').
    /// This is used to work around some encoder bugs.
    /// A demuxer should set this to what is stored in the field used to identify the codec.
    /// If there are multiple such fields in a container then the demuxer should choose the one
    /// which maximizes the information about the used codec.
    /// If the codec tag field in a container is larger than 32 bits then the demuxer should
    /// remap the longer ID to 32 bits with a table or other structure. Alternatively a new
    /// extra_codec_tag + size could be added but for this a clear advantage must be demonstrated
    /// first.
    /// - encoding: Set by user, if not then the default based on codec_id will be used.
    /// - decoding: Set by user, will be converted to uppercase by libavcodec during init.
    pub codec_tag: libc::c_uint,
    /// @deprecated this field is unused
    pub stream_codec_tag: libc::c_uint,
    pub priv_data: *mut libc::c_void,
    /// Private context used for internal data.
    ///
    /// Unlike priv_data, this is not codec-specific. It is used in general
    /// libavcodec functions.
    pub internal: *mut AVCodecInternal,
    /// Private data of the user, can be used to carry app specific stuff.
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub opaque: *mut libc::c_void,
    /// the average bitrate
    /// - encoding: Set by user; unused for constant quantizer encoding.
    /// - decoding: Set by user, may be overwritten by libavcodec
    /// if this info is available in the stream
    pub bit_rate: i64,
    /// number of bits the bitstream is allowed to diverge from the reference.
    /// the reference can be CBR (for CBR pass1) or VBR (for pass2)
    /// - encoding: Set by user; unused for constant quantizer encoding.
    /// - decoding: unused
    pub bit_rate_tolerance: libc::c_int,
    /// Global quality for codecs which cannot change it per frame.
    /// This should be proportional to MPEG-1/2/4 qscale.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub global_quality: libc::c_int,
    /// - encoding: Set by user.
    /// - decoding: unused
    pub compression_level: libc::c_int,
    /// AV_CODEC_FLAG_*.
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub flags: libc::c_int,
    /// AV_CODEC_FLAG2_*
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub flags2: libc::c_int,
    /// some codecs need / can use extradata like Huffman tables.
    /// MJPEG: Huffman tables
    /// rv10: additional flags
    /// MPEG-4: global headers (they can be in the bitstream or here)
    /// The allocated memory should be AV_INPUT_BUFFER_PADDING_SIZE bytes larger
    /// than extradata_size to avoid problems if it is read with the bitstream reader.
    /// The bytewise contents of extradata must not depend on the architecture or CPU endianness.
    /// - encoding: Set/allocated/freed by libavcodec.
    /// - decoding: Set/allocated/freed by user.
    pub extradata: *mut u8,
    pub extradata_size: libc::c_int,
    /// This is the fundamental unit of time (in seconds) in terms
    /// of which frame timestamps are represented. For fixed-fps content,
    /// timebase should be 1/framerate and timestamp increments should be
    /// identically 1.
    /// This often, but not always is the inverse of the frame rate or field rate
    /// for video. 1/time_base is not the average frame rate if the frame rate is not
    /// constant.
    ///
    /// Like containers, elementary streams also can store timestamps, 1/time_base
    /// is the unit in which these timestamps are specified.
    /// As example of such codec time base see ISO/IEC 14496-2:2001(E)
    /// vop_time_increment_resolution and fixed_vop_rate
    /// (fixed_vop_rate == 0 implies that it is different from the framerate)
    ///
    /// - encoding: MUST be set by user.
    /// - decoding: the use of this field for decoding is deprecated.
    /// Use framerate instead.
    pub time_base: AVRational,
    /// For some codecs, the time base is closer to the field rate than the frame rate.
    /// Most notably, H.264 and MPEG-2 specify time_base as half of frame duration
    /// if no telecine is used ...
    ///
    /// Set to time_base ticks per frame. Default 1, e.g., H.264/MPEG-2 set it to 2.
    pub ticks_per_frame: libc::c_int,
    /// Codec delay.
    ///
    /// Encoding: Number of frames delay there will be from the encoder input to
    /// the decoder output. (we assume the decoder matches the spec)
    /// Decoding: Number of frames delay in addition to what a standard decoder
    /// as specified in the spec would produce.
    ///
    /// Video:
    /// Number of frames the decoded output will be delayed relative to the
    /// encoded input.
    ///
    /// Audio:
    /// For encoding, this field is unused (see initial_padding).
    ///
    /// For decoding, this is the number of samples the decoder needs to
    /// output before the decoder's output is valid. When seeking, you should
    /// start decoding this many samples prior to your desired seek point.
    ///
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by libavcodec.
    pub delay: libc::c_int,
    /// picture width / height.
    ///
    /// @note Those fields may not match the values of the last
    /// AVFrame output by avcodec_decode_video2 due frame
    /// reordering.
    ///
    /// - encoding: MUST be set by user.
    /// - decoding: May be set by the user before opening the decoder if known e.g.
    /// from the container. Some decoders will require the dimensions
    /// to be set by the caller. During decoding, the decoder may
    /// overwrite those values as required while parsing the data.
    pub width: libc::c_int,
    /// picture width / height.
    ///
    /// @note Those fields may not match the values of the last
    /// AVFrame output by avcodec_decode_video2 due frame
    /// reordering.
    ///
    /// - encoding: MUST be set by user.
    /// - decoding: May be set by the user before opening the decoder if known e.g.
    /// from the container. Some decoders will require the dimensions
    /// to be set by the caller. During decoding, the decoder may
    /// overwrite those values as required while parsing the data.
    pub height: libc::c_int,
    /// Bitstream width / height, may be different from width/height e.g. when
    /// the decoded frame is cropped before being output or lowres is enabled.
    ///
    /// @note Those field may not match the value of the last
    /// AVFrame output by avcodec_receive_frame() due frame
    /// reordering.
    ///
    /// - encoding: unused
    /// - decoding: May be set by the user before opening the decoder if known
    /// e.g. from the container. During decoding, the decoder may
    /// overwrite those values as required while parsing the data.
    pub coded_width: libc::c_int,
    /// Bitstream width / height, may be different from width/height e.g. when
    /// the decoded frame is cropped before being output or lowres is enabled.
    ///
    /// @note Those field may not match the value of the last
    /// AVFrame output by avcodec_receive_frame() due frame
    /// reordering.
    ///
    /// - encoding: unused
    /// - decoding: May be set by the user before opening the decoder if known
    /// e.g. from the container. During decoding, the decoder may
    /// overwrite those values as required while parsing the data.
    pub coded_height: libc::c_int,
    /// the number of pictures in a group of pictures, or 0 for intra_only
    /// - encoding: Set by user.
    /// - decoding: unused
    pub gop_size: libc::c_int,
    /// Pixel format, see AV_PIX_FMT_xxx.
    /// May be set by the demuxer if known from headers.
    /// May be overridden by the decoder if it knows better.
    ///
    /// @note This field may not match the value of the last
    /// AVFrame output by avcodec_receive_frame() due frame
    /// reordering.
    ///
    /// - encoding: Set by user.
    /// - decoding: Set by user if known, overridden by libavcodec while
    /// parsing the data.
    pub pix_fmt: AVPixelFormat,
    /// This option does nothing
    /// @deprecated use codec private options instead
    pub me_method: libc::c_int,
    /// If non NULL, 'draw_horiz_band' is called by the libavcodec
    /// decoder to draw a horizontal band. It improves cache usage. Not
    /// all codecs can do that. You must check the codec capabilities
    /// beforehand.
    /// When multithreading is used, it may be called from multiple threads
    /// at the same time; threads might draw different parts of the same AVFrame,
    /// or multiple AVFrames, and there is no guarantee that slices will be drawn
    /// in order.
    /// The function is also used by hardware acceleration APIs.
    /// It is called at least once during frame decoding to pass
    /// the data needed for hardware render.
    /// In that mode instead of pixel data, AVFrame points to
    /// a structure specific to the acceleration API. The application
    /// reads the structure and can change some fields to indicate progress
    /// or mark state.
    /// - encoding: unused
    /// - decoding: Set by user.
    /// @param height the height of the slice
    /// @param y the y position of the slice
    /// @param type 1->top field, 2->bottom field, 3->frame
    /// @param offset offset into the AVFrame.data from which the slice should be read
    pub draw_horiz_band: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecContext,
            src: *const AVFrame,
            offset: *mut libc::c_int,
            y: libc::c_int,
            type_: libc::c_int,
            height: libc::c_int,
        ),
    >,
    /// callback to negotiate the pixelFormat
    /// @param fmt is the list of formats which are supported by the codec,
    /// it is terminated by -1 as 0 is a valid format, the formats are ordered by quality.
    /// The first is always the native one.
    /// @note The callback may be called again immediately if initialization for
    /// the selected (hardware-accelerated) pixel format failed.
    /// @warning Behavior is undefined if the callback returns a value not
    /// in the fmt list of formats.
    /// @return the chosen format
    /// - encoding: unused
    /// - decoding: Set by user, if not set the native format will be chosen.
    pub get_format: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecContext, fmt: *const AVPixelFormat) -> AVPixelFormat,
    >,
    /// maximum number of B-frames between non-B-frames
    /// Note: The output will be delayed by max_b_frames+1 relative to the input.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub max_b_frames: libc::c_int,
    /// qscale factor between IP and B-frames
    /// If > 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset).
    /// If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
    /// - encoding: Set by user.
    /// - decoding: unused
    pub b_quant_factor: f32,
    /// @deprecated use codec private option instead
    pub rc_strategy: libc::c_int,
    /// @deprecated use encoder private options instead
    pub b_frame_strategy: libc::c_int,
    /// qscale offset between IP and B-frames
    /// - encoding: Set by user.
    /// - decoding: unused
    pub b_quant_offset: f32,
    /// Size of the frame reordering buffer in the decoder.
    /// For MPEG-2 it is 1 IPB or 0 low delay IP.
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by libavcodec.
    pub has_b_frames: libc::c_int,
    /// @deprecated use encoder private options instead
    pub mpeg_quant: libc::c_int,
    /// qscale factor between P- and I-frames
    /// If > 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset).
    /// If < 0 then normal ratecontrol will be done (q= -normal_q*factor+offset).
    /// - encoding: Set by user.
    /// - decoding: unused
    pub i_quant_factor: f32,
    /// qscale offset between P and I-frames
    /// - encoding: Set by user.
    /// - decoding: unused
    pub i_quant_offset: f32,
    /// luminance masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub lumi_masking: f32,
    /// temporary complexity masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub temporal_cplx_masking: f32,
    /// spatial complexity masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub spatial_cplx_masking: f32,
    /// p block masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub p_masking: f32,
    /// darkness masking (0-> disabled)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub dark_masking: f32,
    /// slice count
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by user (or 0).
    pub slice_count: libc::c_int,
    /// @deprecated use encoder private options instead
    pub prediction_method: libc::c_int,
    /// slice offsets in the frame in bytes
    /// - encoding: Set/allocated by libavcodec.
    /// - decoding: Set/allocated by user (or NULL).
    pub slice_offset: *mut libc::c_int,
    /// sample aspect ratio (0 if unknown)
    /// That is the width of a pixel divided by the height of the pixel.
    /// Numerator and denominator must be relatively prime and smaller than 256 for some video standards.
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub sample_aspect_ratio: AVRational,
    /// motion estimation comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_cmp: libc::c_int,
    /// subpixel motion estimation comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_sub_cmp: libc::c_int,
    /// macroblock comparison function (not supported yet)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mb_cmp: libc::c_int,
    /// interlaced DCT comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub ildct_cmp: libc::c_int,
    /// ME diamond size & shape
    /// - encoding: Set by user.
    /// - decoding: unused
    pub dia_size: libc::c_int,
    /// amount of previous MV predictors (2a+1 x 2a+1 square)
    /// - encoding: Set by user.
    /// - decoding: unused
    pub last_predictor_count: libc::c_int,
    /// @deprecated use encoder private options instead
    pub pre_me: libc::c_int,
    /// motion estimation prepass comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_pre_cmp: libc::c_int,
    /// ME prepass diamond size & shape
    /// - encoding: Set by user.
    /// - decoding: unused
    pub pre_dia_size: libc::c_int,
    /// subpel ME quality
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_subpel_quality: libc::c_int,
    /// DTG active format information (additional aspect ratio
    /// information only used in DVB MPEG-2 transport streams)
    /// 0 if not set.
    ///
    /// - encoding: unused
    /// - decoding: Set by decoder.
    /// @deprecated Deprecated in favor of AVSideData
    pub dtg_active_format: libc::c_int,
    /// maximum motion estimation search range in subpel units
    /// If 0 then no limit.
    ///
    /// - encoding: Set by user.
    /// - decoding: unused
    pub me_range: libc::c_int,
    /// @deprecated use encoder private option instead
    pub intra_quant_bias: libc::c_int,
    /// @deprecated use encoder private option instead
    pub inter_quant_bias: libc::c_int,
    /// slice flags
    /// - encoding: unused
    /// - decoding: Set by user.
    pub slice_flags: libc::c_int,
    /// XVideo Motion Acceleration
    /// - encoding: forbidden
    /// - decoding: set by decoder
    /// @deprecated XvMC doesn't need it anymore.
    pub xvmc_acceleration: libc::c_int,
    /// macroblock decision mode
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mb_decision: libc::c_int,
    /// custom intra quantization matrix
    /// - encoding: Set by user, can be NULL.
    /// - decoding: Set by libavcodec.
    pub intra_matrix: *mut u16,
    /// custom inter quantization matrix
    /// - encoding: Set by user, can be NULL.
    /// - decoding: Set by libavcodec.
    pub inter_matrix: *mut u16,
    /// @deprecated use encoder private options instead
    pub scenechange_threshold: libc::c_int,
    /// @deprecated use encoder private options instead
    pub noise_reduction: libc::c_int,
    /// @deprecated this field is unused
    pub me_threshold: libc::c_int,
    /// @deprecated this field is unused
    pub mb_threshold: libc::c_int,
    /// precision of the intra DC coefficient - 8
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec
    pub intra_dc_precision: libc::c_int,
    /// Number of macroblock rows at the top which are skipped.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_top: libc::c_int,
    /// Number of macroblock rows at the bottom which are skipped.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_bottom: libc::c_int,
    /// @deprecated use encoder private options instead
    pub border_masking: f32,
    /// minimum MB Lagrange multiplier
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mb_lmin: libc::c_int,
    /// maximum MB Lagrange multiplier
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mb_lmax: libc::c_int,
    /// @deprecated use encoder private options instead
    pub me_penalty_compensation: libc::c_int,
    /// - encoding: Set by user.
    /// - decoding: unused
    pub bidir_refine: libc::c_int,
    /// @deprecated use encoder private options instead
    pub brd_scale: libc::c_int,
    /// minimum GOP size
    /// - encoding: Set by user.
    /// - decoding: unused
    pub keyint_min: libc::c_int,
    /// number of reference frames
    /// - encoding: Set by user.
    /// - decoding: Set by lavc.
    pub refs: libc::c_int,
    /// @deprecated use encoder private options instead
    pub chromaoffset: libc::c_int,
    /// Multiplied by qscale for each frame and added to scene_change_score.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub scenechange_factor: libc::c_int,
    /// Note: Value depends upon the compare function used for fullpel ME.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub mv0_threshold: libc::c_int,
    /// @deprecated use encoder private options instead
    pub b_sensitivity: libc::c_int,
    /// Chromaticity coordinates of the source primaries.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub color_primaries: AVColorPrimaries,
    /// Color Transfer Characteristic.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub color_trc: AVColorTransferCharacteristic,
    /// YUV colorspace type.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub colorspace: AVColorSpace,
    /// MPEG vs JPEG YUV range.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub color_range: AVColorRange,
    /// This defines the location of chroma samples.
    /// - encoding: Set by user
    /// - decoding: Set by libavcodec
    pub chroma_sample_location: AVChromaLocation,
    /// Number of slices.
    /// Indicates number of picture subdivisions. Used for parallelized
    /// decoding.
    /// - encoding: Set by user
    /// - decoding: unused
    pub slices: libc::c_int,
    /// Field order
    /// - encoding: set by libavcodec
    /// - decoding: Set by user.
    pub field_order: AVFieldOrder,
    /// < samples per second
    pub sample_rate: libc::c_int,
    /// < number of audio channels
    pub channels: libc::c_int,
    /// < sample format
    pub sample_fmt: AVSampleFormat,
    /// Number of samples per channel in an audio frame.
    ///
    /// - encoding: set by libavcodec in avcodec_open2(). Each submitted frame
    /// except the last must contain exactly frame_size samples per channel.
    /// May be 0 when the codec has AV_CODEC_CAP_VARIABLE_FRAME_SIZE set, then the
    /// frame size is not restricted.
    /// - decoding: may be set by some decoders to indicate constant frame size
    pub frame_size: libc::c_int,
    /// Frame counter, set by libavcodec.
    ///
    /// - decoding: total number of frames returned from the decoder so far.
    /// - encoding: total number of frames passed to the encoder so far.
    ///
    /// @note the counter is not incremented if encoding/decoding resulted in
    /// an error.
    pub frame_number: libc::c_int,
    /// number of bytes per packet if constant and known or 0
    /// Used by some WAV based audio codecs.
    pub block_align: libc::c_int,
    /// Audio cutoff bandwidth (0 means "automatic")
    /// - encoding: Set by user.
    /// - decoding: unused
    pub cutoff: libc::c_int,
    /// Audio channel layout.
    /// - encoding: set by user.
    /// - decoding: set by user, may be overwritten by libavcodec.
    pub channel_layout: u64,
    /// Request decoder to use this channel layout if it can (0 for default)
    /// - encoding: unused
    /// - decoding: Set by user.
    pub request_channel_layout: u64,
    /// Type of service that the audio stream conveys.
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub audio_service_type: AVAudioServiceType,
    /// desired sample format
    /// - encoding: Not used.
    /// - decoding: Set by user.
    /// Decoder will decode to this format if it can.
    pub request_sample_fmt: AVSampleFormat,
    /// This callback is called at the beginning of each frame to get data
    /// buffer(s) for it. There may be one contiguous buffer for all the data or
    /// there may be a buffer per each data plane or anything in between. What
    /// this means is, you may set however many entries in buf[] you feel necessary.
    /// Each buffer must be reference-counted using the AVBuffer API (see description
    /// of buf[] below).
    ///
    /// The following fields will be set in the frame before this callback is
    /// called:
    /// - format
    /// - width, height (video only)
    /// - sample_rate, channel_layout, nb_samples (audio only)
    /// Their values may differ from the corresponding values in
    /// AVCodecContext. This callback must use the frame values, not the codec
    /// context values, to calculate the required buffer size.
    ///
    /// This callback must fill the following fields in the frame:
    /// - data[]
    /// - linesize[]
    /// - extended_data:
    /// * if the data is planar audio with more than 8 channels, then this
    /// callback must allocate and fill extended_data to contain all pointers
    /// to all data planes. data[] must hold as many pointers as it can.
    /// extended_data must be allocated with av_malloc() and will be freed in
    /// av_frame_unref().
    /// * otherwise extended_data must point to data
    /// - buf[] must contain one or more pointers to AVBufferRef structures. Each of
    /// the frame's data and extended_data pointers must be contained in these. That
    /// is, one AVBufferRef for each allocated chunk of memory, not necessarily one
    /// AVBufferRef per data[] entry. See: av_buffer_create(), av_buffer_alloc(),
    /// and av_buffer_ref().
    /// - extended_buf and nb_extended_buf must be allocated with av_malloc() by
    /// this callback and filled with the extra buffers if there are more
    /// buffers than buf[] can hold. extended_buf will be freed in
    /// av_frame_unref().
    ///
    /// If AV_CODEC_CAP_DR1 is not set then get_buffer2() must call
    /// avcodec_default_get_buffer2() instead of providing buffers allocated by
    /// some other means.
    ///
    /// Each data plane must be aligned to the maximum required by the target
    /// CPU.
    ///
    /// @see avcodec_default_get_buffer2()
    ///
    /// Video:
    ///
    /// If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused
    /// (read and/or written to if it is writable) later by libavcodec.
    ///
    /// avcodec_align_dimensions2() should be used to find the required width and
    /// height, as they normally need to be rounded up to the next multiple of 16.
    ///
    /// Some decoders do not support linesizes changing between frames.
    ///
    /// If frame multithreading is used and thread_safe_callbacks is set,
    /// this callback may be called from a different thread, but not from more
    /// than one at once. Does not need to be reentrant.
    ///
    /// @see avcodec_align_dimensions2()
    ///
    /// Audio:
    ///
    /// Decoders request a buffer of a particular size by setting
    /// AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,
    /// however, utilize only part of the buffer by setting AVFrame.nb_samples
    /// to a smaller value in the output frame.
    ///
    /// As a convenience, av_samples_get_buffer_size() and
    /// av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()
    /// functions to find the required data size and to fill data pointers and
    /// linesize. In AVFrame.linesize, only linesize[0] may be set for audio
    /// since all planes must be the same size.
    ///
    /// @see av_samples_get_buffer_size(), av_samples_fill_arrays()
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec, user can override.
    pub get_buffer2: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVCodecContext, frame: *mut AVFrame, flags: libc::c_int)
            -> libc::c_int,
    >,
    /// If non-zero, the decoded audio and video frames returned from
    /// avcodec_decode_video2() and avcodec_decode_audio4() are reference-counted
    /// and are valid indefinitely. The caller must free them with
    /// av_frame_unref() when they are not needed anymore.
    /// Otherwise, the decoded frames must not be freed by the caller and are
    /// only valid until the next decode call.
    ///
    /// This is always automatically enabled if avcodec_receive_frame() is used.
    ///
    /// - encoding: unused
    /// - decoding: set by the caller before avcodec_open2().
    pub refcounted_frames: libc::c_int,
    /// < amount of qscale change between easy & hard scenes (0.0-1.0)
    pub qcompress: f32,
    /// < amount of qscale smoothing over time (0.0-1.0)
    pub qblur: f32,
    /// minimum quantizer
    /// - encoding: Set by user.
    /// - decoding: unused
    pub qmin: libc::c_int,
    /// maximum quantizer
    /// - encoding: Set by user.
    /// - decoding: unused
    pub qmax: libc::c_int,
    /// maximum quantizer difference between frames
    /// - encoding: Set by user.
    /// - decoding: unused
    pub max_qdiff: libc::c_int,
    /// @deprecated use encoder private options instead
    pub rc_qsquish: f32,
    pub rc_qmod_amp: f32,
    pub rc_qmod_freq: libc::c_int,
    /// decoder bitstream buffer size
    /// - encoding: Set by user.
    /// - decoding: unused
    pub rc_buffer_size: libc::c_int,
    /// ratecontrol override, see RcOverride
    /// - encoding: Allocated/set/freed by user.
    /// - decoding: unused
    pub rc_override_count: libc::c_int,
    pub rc_override: *mut RcOverride,
    /// @deprecated use encoder private options instead
    pub rc_eq: *const libc::c_char,
    /// maximum bitrate
    /// - encoding: Set by user.
    /// - decoding: Set by user, may be overwritten by libavcodec.
    pub rc_max_rate: i64,
    /// minimum bitrate
    /// - encoding: Set by user.
    /// - decoding: unused
    pub rc_min_rate: i64,
    /// @deprecated use encoder private options instead
    pub rc_buffer_aggressivity: f32,
    pub rc_initial_cplx: f32,
    /// Ratecontrol attempt to use, at maximum, <value> of what can be used without an underflow.
    /// - encoding: Set by user.
    /// - decoding: unused.
    pub rc_max_available_vbv_use: f32,
    /// Ratecontrol attempt to use, at least, <value> times the amount needed to prevent a vbv overflow.
    /// - encoding: Set by user.
    /// - decoding: unused.
    pub rc_min_vbv_overflow_use: f32,
    /// Number of bits which should be loaded into the rc buffer before decoding starts.
    /// - encoding: Set by user.
    /// - decoding: unused
    pub rc_initial_buffer_occupancy: libc::c_int,
    /// @deprecated use encoder private options instead
    pub coder_type: libc::c_int,
    /// @deprecated use encoder private options instead
    pub context_model: libc::c_int,
    /// @deprecated use encoder private options instead
    pub lmin: libc::c_int,
    /// @deprecated use encoder private options instead
    pub lmax: libc::c_int,
    /// @deprecated use encoder private options instead
    pub frame_skip_threshold: libc::c_int,
    /// @deprecated use encoder private options instead
    pub frame_skip_factor: libc::c_int,
    /// @deprecated use encoder private options instead
    pub frame_skip_exp: libc::c_int,
    /// @deprecated use encoder private options instead
    pub frame_skip_cmp: libc::c_int,
    /// trellis RD quantization
    /// - encoding: Set by user.
    /// - decoding: unused
    pub trellis: libc::c_int,
    /// @deprecated use encoder private options instead
    pub min_prediction_order: libc::c_int,
    /// @deprecated use encoder private options instead
    pub max_prediction_order: libc::c_int,
    /// @deprecated use encoder private options instead
    pub timecode_frame_start: i64,
    /// @deprecated unused
    pub rtp_callback: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            data: *mut libc::c_void,
            size: libc::c_int,
            mb_nb: libc::c_int,
        ),
    >,
    /// @deprecated use encoder private options instead
    pub rtp_payload_size: libc::c_int,
    pub mv_bits: libc::c_int,
    pub header_bits: libc::c_int,
    pub i_tex_bits: libc::c_int,
    pub p_tex_bits: libc::c_int,
    pub i_count: libc::c_int,
    pub p_count: libc::c_int,
    pub skip_count: libc::c_int,
    pub misc_bits: libc::c_int,
    /// @deprecated this field is unused
    pub frame_bits: libc::c_int,
    /// pass1 encoding statistics output buffer
    /// - encoding: Set by libavcodec.
    /// - decoding: unused
    pub stats_out: *mut libc::c_char,
    /// pass2 encoding statistics input buffer
    /// Concatenated stuff from stats_out of pass1 should be placed here.
    /// - encoding: Allocated/set/freed by user.
    /// - decoding: unused
    pub stats_in: *mut libc::c_char,
    /// Work around bugs in encoders which sometimes cannot be detected automatically.
    /// - encoding: Set by user
    /// - decoding: Set by user
    pub workaround_bugs: libc::c_int,
    /// strictly follow the standard (MPEG-4, ...).
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    /// Setting this to STRICT or higher means the encoder and decoder will
    /// generally do stupid things, whereas setting it to unofficial or lower
    /// will mean the encoder might produce output that is not supported by all
    /// spec-compliant decoders. Decoders don't differentiate between normal,
    /// unofficial and experimental (that is, they always try to decode things
    /// when they can) unless they are explicitly asked to behave stupidly
    /// (=strictly conform to the specs)
    pub strict_std_compliance: libc::c_int,
    /// error concealment flags
    /// - encoding: unused
    /// - decoding: Set by user.
    pub error_concealment: libc::c_int,
    /// debug
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub debug: libc::c_int,
    /// debug
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub debug_mv: libc::c_int,
    /// Error recognition; may misdetect some more or less valid parts as errors.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub err_recognition: libc::c_int,
    /// opaque 64-bit number (generally a PTS) that will be reordered and
    /// output in AVFrame.reordered_opaque
    /// - encoding: unused
    /// - decoding: Set by user.
    pub reordered_opaque: i64,
    /// Hardware accelerator in use
    /// - encoding: unused.
    /// - decoding: Set by libavcodec
    pub hwaccel: *mut AVHWAccel,
    /// Hardware accelerator context.
    /// For some hardware accelerators, a global context needs to be
    /// provided by the user. In that case, this holds display-dependent
    /// data FFmpeg cannot instantiate itself. Please refer to the
    /// FFmpeg HW accelerator documentation to know how to fill this
    /// is. e.g. for VA API, this is a struct vaapi_context.
    /// - encoding: unused
    /// - decoding: Set by user
    pub hwaccel_context: *mut libc::c_void,
    /// error
    /// - encoding: Set by libavcodec if flags & AV_CODEC_FLAG_PSNR.
    /// - decoding: unused
    pub error: [u64; 8usize],
    /// DCT algorithm, see FF_DCT_* below
    /// - encoding: Set by user.
    /// - decoding: unused
    pub dct_algo: libc::c_int,
    /// IDCT algorithm, see FF_IDCT_* below.
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub idct_algo: libc::c_int,
    /// bits per sample/pixel from the demuxer (needed for huffyuv).
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by user.
    pub bits_per_coded_sample: libc::c_int,
    /// Bits per sample/pixel of internal libavcodec pixel/sample format.
    /// - encoding: set by user.
    /// - decoding: set by libavcodec.
    pub bits_per_raw_sample: libc::c_int,
    /// low resolution decoding, 1-> 1/2 size, 2->1/4 size
    /// - encoding: unused
    /// - decoding: Set by user.
    pub lowres: libc::c_int,
    /// the picture in the bitstream
    /// - encoding: Set by libavcodec.
    /// - decoding: unused
    ///
    /// @deprecated use the quality factor packet side data instead
    pub coded_frame: *mut AVFrame,
    /// thread count
    /// is used to decide how many independent tasks should be passed to execute()
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub thread_count: libc::c_int,
    /// Which multithreading methods to use.
    /// Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread,
    /// so clients which cannot provide future frames should not use it.
    ///
    /// - encoding: Set by user, otherwise the default is used.
    /// - decoding: Set by user, otherwise the default is used.
    pub thread_type: libc::c_int,
    /// Which multithreading methods are in use by the codec.
    /// - encoding: Set by libavcodec.
    /// - decoding: Set by libavcodec.
    pub active_thread_type: libc::c_int,
    /// Set by the client if its custom get_buffer() callback can be called
    /// synchronously from another thread, which allows faster multithreaded decoding.
    /// draw_horiz_band() will be called from other threads regardless of this setting.
    /// Ignored if the default get_buffer() is used.
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub thread_safe_callbacks: libc::c_int,
    /// The codec may call this to execute several independent things.
    /// It will return only after finishing all tasks.
    /// The user may replace this with some multithreaded implementation,
    /// the default implementation will execute the parts serially.
    /// @param count the number of things to execute
    /// - encoding: Set by libavcodec, user can override.
    /// - decoding: Set by libavcodec, user can override.
    pub execute: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(c2: *mut AVCodecContext, arg: *mut libc::c_void)
                    -> libc::c_int,
            >,
            arg2: *mut libc::c_void,
            ret: *mut libc::c_int,
            count: libc::c_int,
            size: libc::c_int,
        ) -> libc::c_int,
    >,
    /// The codec may call this to execute several independent things.
    /// It will return only after finishing all tasks.
    /// The user may replace this with some multithreaded implementation,
    /// the default implementation will execute the parts serially.
    /// Also see avcodec_thread_init and e.g. the --enable-pthread configure option.
    /// @param c context passed also to func
    /// @param count the number of things to execute
    /// @param arg2 argument passed unchanged to func
    /// @param ret return values of executed functions, must have space for "count" values. May be NULL.
    /// @param func function that will be called count times, with jobnr from 0 to count-1.
    /// threadnr will be in the range 0 to c->thread_count-1 < MAX_THREADS and so that no
    /// two instances of func executing at the same time will have the same threadnr.
    /// @return always 0 currently, but code should handle a future improvement where when any call to func
    /// returns < 0 no further calls to func may be done and < 0 is returned.
    /// - encoding: Set by libavcodec, user can override.
    /// - decoding: Set by libavcodec, user can override.
    pub execute2: ::std::option::Option<
        unsafe extern "C" fn(
            c: *mut AVCodecContext,
            func: ::std::option::Option<
                unsafe extern "C" fn(
                    c2: *mut AVCodecContext,
                    arg: *mut libc::c_void,
                    jobnr: libc::c_int,
                    threadnr: libc::c_int,
                ) -> libc::c_int,
            >,
            arg2: *mut libc::c_void,
            ret: *mut libc::c_int,
            count: libc::c_int,
        ) -> libc::c_int,
    >,
    /// noise vs. sse weight for the nsse comparison function
    /// - encoding: Set by user.
    /// - decoding: unused
    pub nsse_weight: libc::c_int,
    /// profile
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub profile: libc::c_int,
    /// level
    /// - encoding: Set by user.
    /// - decoding: Set by libavcodec.
    pub level: libc::c_int,
    /// Skip loop filtering for selected frames.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_loop_filter: AVDiscard,
    /// Skip IDCT/dequantization for selected frames.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_idct: AVDiscard,
    /// Skip decoding for selected frames.
    /// - encoding: unused
    /// - decoding: Set by user.
    pub skip_frame: AVDiscard,
    /// Header containing style information for text subtitles.
    /// For SUBTITLE_ASS subtitle type, it should contain the whole ASS
    /// [Script Info] and [V4+ Styles] section, plus the [Events] line and
    /// the Format line following. It shouldn't include any Dialogue line.
    /// - encoding: Set/allocated/freed by user (before avcodec_open2())
    /// - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())
    pub subtitle_header: *mut u8,
    pub subtitle_header_size: libc::c_int,
    /// @deprecated use the 'error_rate' private AVOption of the mpegvideo
    /// encoders
    pub error_rate: libc::c_int,
    /// VBV delay coded in the last frame (in periods of a 27 MHz clock).
    /// Used for compliant TS muxing.
    /// - encoding: Set by libavcodec.
    /// - decoding: unused.
    /// @deprecated this value is now exported as a part of
    /// AV_PKT_DATA_CPB_PROPERTIES packet side data
    pub vbv_delay: u64,
    /// Encoding only and set by default. Allow encoders to output packets
    /// that do not contain any encoded data, only side data.
    ///
    /// Some encoders need to output such packets, e.g. to update some stream
    /// parameters at the end of encoding.
    ///
    /// @deprecated this field disables the default behaviour and
    /// it is kept only for compatibility.
    pub side_data_only_packets: libc::c_int,
    /// Audio only. The number of "priming" samples (padding) inserted by the
    /// encoder at the beginning of the audio. I.e. this number of leading
    /// decoded samples must be discarded by the caller to get the original audio
    /// without leading padding.
    ///
    /// - decoding: unused
    /// - encoding: Set by libavcodec. The timestamps on the output packets are
    /// adjusted by the encoder so that they always refer to the
    /// first sample of the data actually contained in the packet,
    /// including any added padding.  E.g. if the timebase is
    /// 1/samplerate and the timestamp of the first input sample is
    /// 0, the timestamp of the first output packet will be
    /// -initial_padding.
    pub initial_padding: libc::c_int,
    /// - decoding: For codecs that store a framerate value in the compressed
    /// bitstream, the decoder may export it here. { 0, 1} when
    /// unknown.
    /// - encoding: May be used to signal the framerate of CFR content to an
    /// encoder.
    pub framerate: AVRational,
    /// Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx.
    /// - encoding: unused.
    /// - decoding: Set by libavcodec before calling get_format()
    pub sw_pix_fmt: AVPixelFormat,
    /// Timebase in which pkt_dts/pts and AVPacket.dts/pts are.
    /// - encoding unused.
    /// - decoding set by user.
    pub pkt_timebase: AVRational,
    /// AVCodecDescriptor
    /// - encoding: unused.
    /// - decoding: set by libavcodec.
    pub codec_descriptor: *const AVCodecDescriptor,
    /// Current statistics for PTS correction.
    /// - decoding: maintained and used by libavcodec, not intended to be used by user apps
    /// - encoding: unused
    pub pts_correction_num_faulty_pts: i64,
    /// Number of incorrect PTS values so far
    pub pts_correction_num_faulty_dts: i64,
    /// Number of incorrect DTS values so far
    pub pts_correction_last_pts: i64,
    /// PTS of the last frame
    pub pts_correction_last_dts: i64,
    /// Character encoding of the input subtitles file.
    /// - decoding: set by user
    /// - encoding: unused
    pub sub_charenc: *mut libc::c_char,
    /// Subtitles character encoding mode. Formats or codecs might be adjusting
    /// this setting (if they are doing the conversion themselves for instance).
    /// - decoding: set by libavcodec
    /// - encoding: unused
    pub sub_charenc_mode: libc::c_int,
    /// Skip processing alpha if supported by codec.
    /// Note that if the format uses pre-multiplied alpha (common with VP6,
    /// and recommended due to better video quality/compression)
    /// the image will look as if alpha-blended onto a black background.
    /// However for formats that do not use pre-multiplied alpha
    /// there might be serious artefacts (though e.g. libswscale currently
    /// assumes pre-multiplied alpha anyway).
    ///
    /// - decoding: set by user
    /// - encoding: unused
    pub skip_alpha: libc::c_int,
    /// Number of samples to skip after a discontinuity
    /// - decoding: unused
    /// - encoding: set by libavcodec
    pub seek_preroll: libc::c_int,
    /// custom intra quantization matrix
    /// - encoding: Set by user, can be NULL.
    /// - decoding: unused.
    pub chroma_intra_matrix: *mut u16,
    /// dump format separator.
    /// can be ", " or "\n      " or anything else
    /// - encoding: Set by user.
    /// - decoding: Set by user.
    pub dump_separator: *mut u8,
    /// ',' separated list of allowed decoders.
    /// If NULL then all are allowed
    /// - encoding: unused
    /// - decoding: set by user
    pub codec_whitelist: *mut libc::c_char,
    /// Properties of the stream that gets decoded
    /// - encoding: unused
    /// - decoding: set by libavcodec
    pub properties: libc::c_uint,
    /// Additional data associated with the entire coded stream.
    ///
    /// - decoding: unused
    /// - encoding: may be set by libavcodec after avcodec_open2().
    pub coded_side_data: *mut AVPacketSideData,
    pub nb_coded_side_data: libc::c_int,
    /// A reference to the AVHWFramesContext describing the input (for encoding)
    /// or output (decoding) frames. The reference is set by the caller and
    /// afterwards owned (and freed) by libavcodec - it should never be read by
    /// the caller after being set.
    ///
    /// - decoding: This field should be set by the caller from the get_format()
    /// callback. The previous reference (if any) will always be
    /// unreffed by libavcodec before the get_format() call.
    ///
    /// If the default get_buffer2() is used with a hwaccel pixel
    /// format, then this AVHWFramesContext will be used for
    /// allocating the frame buffers.
    ///
    /// - encoding: For hardware encoders configured to use a hwaccel pixel
    /// format, this field should be set by the caller to a reference
    /// to the AVHWFramesContext describing input frames.
    /// AVHWFramesContext.format must be equal to
    /// AVCodecContext.pix_fmt.
    ///
    /// This field should be set before avcodec_open2() is called.
    pub hw_frames_ctx: *mut AVBufferRef,
    /// Control the form of AVSubtitle.rects[N]->ass
    /// - decoding: set by user
    /// - encoding: unused
    pub sub_text_format: libc::c_int,
    /// Audio only. The amount of padding (in samples) appended by the encoder to
    /// the end of the audio. I.e. this number of decoded samples must be
    /// discarded by the caller from the end of the stream to get the original
    /// audio without any trailing padding.
    ///
    /// - decoding: unused
    /// - encoding: unused
    pub trailing_padding: libc::c_int,
    /// The number of pixels per image to maximally accept.
    ///
    /// - decoding: set by user
    /// - encoding: set by user
    pub max_pixels: i64,
    /// A reference to the AVHWDeviceContext describing the device which will
    /// be used by a hardware encoder/decoder.  The reference is set by the
    /// caller and afterwards owned (and freed) by libavcodec.
    ///
    /// This should be used if either the codec device does not require
    /// hardware frames or any that are used are to be allocated internally by
    /// libavcodec.  If the user wishes to supply any of the frames used as
    /// encoder input or decoder output then hw_frames_ctx should be used
    /// instead.  When hw_frames_ctx is set in get_format() for a decoder, this
    /// field will be ignored while decoding the associated stream segment, but
    /// may again be used on a following one after another get_format() call.
    ///
    /// For both encoders and decoders this field should be set before
    /// avcodec_open2() is called and must not be written to thereafter.
    ///
    /// Note that some decoders may require this field to be set initially in
    /// order to support hw_frames_ctx at all - in that case, all frames
    /// contexts used must be created on the same device.
    pub hw_device_ctx: *mut AVBufferRef,
    /// Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated
    /// decoding (if active).
    /// - encoding: unused
    /// - decoding: Set by user (either before avcodec_open2(), or in the
    /// AVCodecContext.get_format callback)
    pub hwaccel_flags: libc::c_int,
    /// Video decoding only. Certain video codecs support cropping, meaning that
    /// only a sub-rectangle of the decoded frame is intended for display.  This
    /// option controls how cropping is handled by libavcodec.
    ///
    /// When set to 1 (the default), libavcodec will apply cropping internally.
    /// I.e. it will modify the output frame width/height fields and offset the
    /// data pointers (only by as much as possible while preserving alignment, or
    /// by the full amount if the AV_CODEC_FLAG_UNALIGNED flag is set) so that
    /// the frames output by the decoder refer only to the cropped area. The
    /// crop_* fields of the output frames will be zero.
    ///
    /// When set to 0, the width/height fields of the output frames will be set
    /// to the coded dimensions and the crop_* fields will describe the cropping
    /// rectangle. Applying the cropping is left to the caller.
    ///
    /// @warning When hardware acceleration with opaque output frames is used,
    /// libavcodec is unable to apply cropping from the top/left border.
    ///
    /// @note when this option is set to zero, the width/height fields of the
    /// AVCodecContext and output AVFrames have different meanings. The codec
    /// context fields store display dimensions (with the coded dimensions in
    /// coded_width/height), while the frame fields store the coded dimensions
    /// (with the display dimensions being determined by the crop_* fields).
    pub apply_cropping: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecContext() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecContext>(),
        1160usize,
        concat!("Size of: ", stringify!(AVCodecContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).log_level_offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(log_level_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_tag as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).stream_codec_tag as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(stream_codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).priv_data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).internal as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).opaque as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).bit_rate as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).bit_rate_tolerance as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bit_rate_tolerance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).global_quality as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(global_quality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).compression_level as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(compression_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).flags as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).flags2 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).extradata as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extradata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).extradata_size as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(extradata_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).time_base as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).ticks_per_frame as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(ticks_per_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).delay as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).width as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).height as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coded_width as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coded_height as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).gop_size as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(gop_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).pix_fmt as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_method as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).draw_horiz_band as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(draw_horiz_band)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).get_format as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(get_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).max_b_frames as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_b_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).b_quant_factor as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_quant_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_strategy as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_strategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).b_frame_strategy as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_frame_strategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).b_quant_offset as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_quant_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).has_b_frames as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(has_b_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mpeg_quant as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mpeg_quant)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).i_quant_factor as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_quant_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).i_quant_offset as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_quant_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).lumi_masking as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(lumi_masking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).temporal_cplx_masking as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(temporal_cplx_masking)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).spatial_cplx_masking as *const _ as usize
        },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(spatial_cplx_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).p_masking as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(p_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).dark_masking as *const _ as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dark_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).slice_count as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).prediction_method as *const _ as usize
        },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(prediction_method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).slice_offset as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).sample_aspect_ratio as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_cmp as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_sub_cmp as *const _ as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_sub_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_cmp as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).ildct_cmp as *const _ as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(ildct_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).dia_size as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dia_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).last_predictor_count as *const _ as usize
        },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(last_predictor_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).pre_me as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pre_me)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_pre_cmp as *const _ as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_pre_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).pre_dia_size as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pre_dia_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).me_subpel_quality as *const _ as usize
        },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_subpel_quality)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).dtg_active_format as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dtg_active_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_range as *const _ as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).intra_quant_bias as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(intra_quant_bias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).inter_quant_bias as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(inter_quant_bias)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).slice_flags as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slice_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).xvmc_acceleration as *const _ as usize
        },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(xvmc_acceleration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_decision as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_decision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).intra_matrix as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(intra_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).inter_matrix as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(inter_matrix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).scenechange_threshold as *const _ as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(scenechange_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).noise_reduction as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(noise_reduction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).me_threshold as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_threshold as *const _ as usize },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).intra_dc_precision as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(intra_dc_precision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_top as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_bottom as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_bottom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).border_masking as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(border_masking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_lmin as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_lmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mb_lmax as *const _ as usize },
        404usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mb_lmax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).me_penalty_compensation as *const _ as usize
        },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(me_penalty_compensation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).bidir_refine as *const _ as usize },
        412usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bidir_refine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).brd_scale as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(brd_scale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).keyint_min as *const _ as usize },
        420usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(keyint_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).refs as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).chromaoffset as *const _ as usize },
        428usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chromaoffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).scenechange_factor as *const _ as usize
        },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(scenechange_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mv0_threshold as *const _ as usize },
        436usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mv0_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).b_sensitivity as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(b_sensitivity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).color_primaries as *const _ as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).color_trc as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).colorspace as *const _ as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(colorspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).color_range as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).chroma_sample_location as *const _ as usize
        },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chroma_sample_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).slices as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(slices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).field_order as *const _ as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sample_rate as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).channels as *const _ as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sample_fmt as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sample_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).frame_size as *const _ as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).frame_number as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).block_align as *const _ as usize },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(block_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).cutoff as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(cutoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).channel_layout as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).request_channel_layout as *const _ as usize
        },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(request_channel_layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).audio_service_type as *const _ as usize
        },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(audio_service_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).request_sample_fmt as *const _ as usize
        },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(request_sample_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).get_buffer2 as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(get_buffer2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).refcounted_frames as *const _ as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(refcounted_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).qcompress as *const _ as usize },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qcompress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).qblur as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qblur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).qmin as *const _ as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).qmax as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(qmax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).max_qdiff as *const _ as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_qdiff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_qsquish as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_qsquish)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_qmod_amp as *const _ as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_qmod_amp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_qmod_freq as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_qmod_freq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_buffer_size as *const _ as usize },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_buffer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_override_count as *const _ as usize
        },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_override_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_override as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_override)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_eq as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_eq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_max_rate as *const _ as usize },
        600usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_max_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_min_rate as *const _ as usize },
        608usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_min_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_buffer_aggressivity as *const _ as usize
        },
        616usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_buffer_aggressivity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rc_initial_cplx as *const _ as usize },
        620usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_initial_cplx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_max_available_vbv_use as *const _ as usize
        },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_max_available_vbv_use)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_min_vbv_overflow_use as *const _ as usize
        },
        628usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_min_vbv_overflow_use)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).rc_initial_buffer_occupancy as *const _
                as usize
        },
        632usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rc_initial_buffer_occupancy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coder_type as *const _ as usize },
        636usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coder_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).context_model as *const _ as usize },
        640usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(context_model)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).lmin as *const _ as usize },
        644usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(lmin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).lmax as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(lmax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).frame_skip_threshold as *const _ as usize
        },
        652usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_skip_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).frame_skip_factor as *const _ as usize
        },
        656usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_skip_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).frame_skip_exp as *const _ as usize },
        660usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_skip_exp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).frame_skip_cmp as *const _ as usize },
        664usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_skip_cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).trellis as *const _ as usize },
        668usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(trellis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).min_prediction_order as *const _ as usize
        },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(min_prediction_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).max_prediction_order as *const _ as usize
        },
        676usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_prediction_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).timecode_frame_start as *const _ as usize
        },
        680usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(timecode_frame_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rtp_callback as *const _ as usize },
        688usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rtp_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).rtp_payload_size as *const _ as usize },
        696usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(rtp_payload_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).mv_bits as *const _ as usize },
        700usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(mv_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).header_bits as *const _ as usize },
        704usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(header_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).i_tex_bits as *const _ as usize },
        708usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_tex_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).p_tex_bits as *const _ as usize },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(p_tex_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).i_count as *const _ as usize },
        716usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(i_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).p_count as *const _ as usize },
        720usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(p_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_count as *const _ as usize },
        724usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).misc_bits as *const _ as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(misc_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).frame_bits as *const _ as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(frame_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).stats_out as *const _ as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(stats_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).stats_in as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(stats_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).workaround_bugs as *const _ as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(workaround_bugs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).strict_std_compliance as *const _ as usize
        },
        756usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(strict_std_compliance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).error_concealment as *const _ as usize
        },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(error_concealment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).debug as *const _ as usize },
        764usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).debug_mv as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(debug_mv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).err_recognition as *const _ as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(err_recognition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).reordered_opaque as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(reordered_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hwaccel as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hwaccel_context as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).error as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).dct_algo as *const _ as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dct_algo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).idct_algo as *const _ as usize },
        868usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(idct_algo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).bits_per_coded_sample as *const _ as usize
        },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bits_per_coded_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).bits_per_raw_sample as *const _ as usize
        },
        876usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(bits_per_raw_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).lowres as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(lowres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coded_frame as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).thread_count as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).thread_type as *const _ as usize },
        900usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).active_thread_type as *const _ as usize
        },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(active_thread_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).thread_safe_callbacks as *const _ as usize
        },
        908usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(thread_safe_callbacks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).execute as *const _ as usize },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(execute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).execute2 as *const _ as usize },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(execute2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).nsse_weight as *const _ as usize },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(nsse_weight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).profile as *const _ as usize },
        932usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).level as *const _ as usize },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_loop_filter as *const _ as usize },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_loop_filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_idct as *const _ as usize },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_idct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_frame as *const _ as usize },
        948usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).subtitle_header as *const _ as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(subtitle_header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).subtitle_header_size as *const _ as usize
        },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(subtitle_header_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).error_rate as *const _ as usize },
        964usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(error_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).vbv_delay as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(vbv_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).side_data_only_packets as *const _ as usize
        },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(side_data_only_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).initial_padding as *const _ as usize },
        980usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(initial_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).framerate as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(framerate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sw_pix_fmt as *const _ as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sw_pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).pkt_timebase as *const _ as usize },
        996usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pkt_timebase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_descriptor as *const _ as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_descriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).pts_correction_num_faulty_pts as *const _
                as usize
        },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_num_faulty_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).pts_correction_num_faulty_dts as *const _
                as usize
        },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_num_faulty_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).pts_correction_last_pts as *const _ as usize
        },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_last_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).pts_correction_last_dts as *const _ as usize
        },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(pts_correction_last_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sub_charenc as *const _ as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_charenc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sub_charenc_mode as *const _ as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_charenc_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).skip_alpha as *const _ as usize },
        1060usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(skip_alpha)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).seek_preroll as *const _ as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(seek_preroll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).chroma_intra_matrix as *const _ as usize
        },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(chroma_intra_matrix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).dump_separator as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(dump_separator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).codec_whitelist as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(codec_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).properties as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(properties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).coded_side_data as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(coded_side_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecContext>())).nb_coded_side_data as *const _ as usize
        },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(nb_coded_side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hw_frames_ctx as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).sub_text_format as *const _ as usize },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(sub_text_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).trailing_padding as *const _ as usize },
        1132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(trailing_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).max_pixels as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(max_pixels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hw_device_ctx as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hw_device_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).hwaccel_flags as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(hwaccel_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecContext>())).apply_cropping as *const _ as usize },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecContext),
            "::",
            stringify!(apply_cropping)
        )
    );
}
extern "C" {
    pub fn av_codec_get_pkt_timebase(avctx: *const AVCodecContext) -> AVRational;
}
extern "C" {
    pub fn av_codec_set_pkt_timebase(avctx: *mut AVCodecContext, val: AVRational);
}
extern "C" {
    pub fn av_codec_get_codec_descriptor(avctx: *const AVCodecContext) -> *const AVCodecDescriptor;
}
extern "C" {
    pub fn av_codec_set_codec_descriptor(
        avctx: *mut AVCodecContext,
        desc: *const AVCodecDescriptor,
    );
}
extern "C" {
    pub fn av_codec_get_codec_properties(avctx: *const AVCodecContext) -> libc::c_uint;
}
extern "C" {
    pub fn av_codec_get_lowres(avctx: *const AVCodecContext) -> libc::c_int;
}
extern "C" {
    pub fn av_codec_set_lowres(avctx: *mut AVCodecContext, val: libc::c_int);
}
extern "C" {
    pub fn av_codec_get_seek_preroll(avctx: *const AVCodecContext) -> libc::c_int;
}
extern "C" {
    pub fn av_codec_set_seek_preroll(avctx: *mut AVCodecContext, val: libc::c_int);
}
extern "C" {
    pub fn av_codec_get_chroma_intra_matrix(avctx: *const AVCodecContext) -> *mut u16;
}
extern "C" {
    pub fn av_codec_set_chroma_intra_matrix(avctx: *mut AVCodecContext, val: *mut u16);
}
/// AVProfile.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVProfile {
    pub profile: libc::c_int,
    /// < short name for the profile
    pub name: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_AVProfile() {
    assert_eq!(
        ::std::mem::size_of::<AVProfile>(),
        16usize,
        concat!("Size of: ", stringify!(AVProfile))
    );
    assert_eq!(
        ::std::mem::align_of::<AVProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProfile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProfile>())).profile as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProfile),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProfile>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProfile),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecDefault {
    _unused: [u8; 0],
}
/// AVCodec.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodec {
    /// Name of the codec implementation.
    /// The name is globally unique among encoders and among decoders (but an
    /// encoder and a decoder can share the same name).
    /// This is the primary way to find a codec from the user perspective.
    pub name: *const libc::c_char,
    /// Descriptive name for the codec, meant to be more human readable than name.
    /// You should use the NULL_IF_CONFIG_SMALL() macro to define it.
    pub long_name: *const libc::c_char,
    pub type_: AVMediaType,
    pub id: AVCodecID,
    /// Codec capabilities.
    /// see AV_CODEC_CAP_*
    pub capabilities: libc::c_int,
    /// < array of supported framerates, or NULL if any, array is terminated by {0,0}
    pub supported_framerates: *const AVRational,
    /// < array of supported pixel formats, or NULL if unknown, array is terminated by -1
    pub pix_fmts: *const AVPixelFormat,
    /// < array of supported audio samplerates, or NULL if unknown, array is terminated by 0
    pub supported_samplerates: *const libc::c_int,
    /// < array of supported sample formats, or NULL if unknown, array is terminated by -1
    pub sample_fmts: *const AVSampleFormat,
    /// < array of support channel layouts, or NULL if unknown. array is terminated by 0
    pub channel_layouts: *const u64,
    /// < maximum value for lowres supported by the decoder
    pub max_lowres: u8,
    /// < AVClass for the private context
    pub priv_class: *const AVClass,
    /// < array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}
    pub profiles: *const AVProfile,
    /// No fields below this line are part of the public API. They
    /// may not be used outside of libavcodec and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub priv_data_size: libc::c_int,
    pub next: *mut AVCodec,
    /// @name Frame-level threading support functions
    /// @{
    /// /
    /// /**
    /// If defined, called on thread contexts when they are created.
    /// If the codec allocates writable tables in init(), re-allocate them here.
    /// priv_data will be set to a copy of the original.
    pub init_thread_copy:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVCodecContext) -> libc::c_int>,
    /// Copy necessary context variables from a previous thread context to the current one.
    /// If not defined, the next thread will start automatically; otherwise, the codec
    /// must call ff_thread_finish_setup().
    ///
    /// dst and src will (rarely) point to the same context, in which case memcpy should be skipped.
    pub update_thread_context: ::std::option::Option<
        unsafe extern "C" fn(dst: *mut AVCodecContext, src: *const AVCodecContext) -> libc::c_int,
    >,
    /// Private codec-specific defaults.
    pub defaults: *const AVCodecDefault,
    /// Initialize codec static data, called from avcodec_register().
    pub init_static_data: ::std::option::Option<unsafe extern "C" fn(codec: *mut AVCodec)>,
    pub init: ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVCodecContext) -> libc::c_int>,
    pub encode_sub: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVCodecContext,
            buf: *mut u8,
            buf_size: libc::c_int,
            sub: *const AVSubtitle,
        ) -> libc::c_int,
    >,
    /// Encode data to an AVPacket.
    ///
    /// @param      avctx          codec context
    /// @param      avpkt          output AVPacket (may contain a user-provided buffer)
    /// @param[in]  frame          AVFrame containing the raw data to be encoded
    /// @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a
    /// non-empty packet was returned in avpkt.
    /// @return 0 on success, negative error code on failure
    pub encode2: ::std::option::Option<
        unsafe extern "C" fn(
            avctx: *mut AVCodecContext,
            avpkt: *mut AVPacket,
            frame: *const AVFrame,
            got_packet_ptr: *mut libc::c_int,
        ) -> libc::c_int,
    >,
    pub decode: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVCodecContext,
            outdata: *mut libc::c_void,
            outdata_size: *mut libc::c_int,
            avpkt: *mut AVPacket,
        ) -> libc::c_int,
    >,
    pub close:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVCodecContext) -> libc::c_int>,
    /// Encode API with decoupled packet/frame dataflow. The API is the
    /// same as the avcodec_ prefixed APIs (avcodec_send_frame() etc.), except
    /// that:
    /// - never called if the codec is closed or the wrong type,
    /// - if AV_CODEC_CAP_DELAY is not set, drain frames are never sent,
    /// - only one drain frame is ever passed down,
    pub send_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, frame: *const AVFrame) -> libc::c_int,
    >,
    pub receive_packet: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, avpkt: *mut AVPacket) -> libc::c_int,
    >,
    /// Decode API with decoupled packet/frame dataflow. This function is called
    /// to get one output frame. It should call ff_decode_get_packet() to obtain
    /// input data.
    pub receive_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, frame: *mut AVFrame) -> libc::c_int,
    >,
    /// Flush buffers.
    /// Will be called when seeking
    pub flush: ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVCodecContext)>,
    /// Internal codec capabilities.
    /// See FF_CODEC_CAP_* in internal.h
    pub caps_internal: libc::c_int,
    /// Decoding only, a comma-separated list of bitstream filters to apply to
    /// packets before decoding.
    pub bsfs: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_AVCodec() {
    assert_eq!(
        ::std::mem::size_of::<AVCodec>(),
        232usize,
        concat!("Size of: ", stringify!(AVCodec))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodec>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).long_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).capabilities as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).supported_framerates as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(supported_framerates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).pix_fmts as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(pix_fmts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).supported_samplerates as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(supported_samplerates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).sample_fmts as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(sample_fmts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).channel_layouts as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(channel_layouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).max_lowres as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(max_lowres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).priv_class as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).profiles as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(profiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).priv_data_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).next as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).init_thread_copy as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(init_thread_copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).update_thread_context as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(update_thread_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).defaults as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(defaults)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).init_static_data as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(init_static_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).init as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).encode_sub as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(encode_sub)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).encode2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(encode2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).decode as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(decode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).close as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).send_frame as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(send_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).receive_packet as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(receive_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).receive_frame as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(receive_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).flush as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).caps_internal as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(caps_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodec>())).bsfs as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodec),
            "::",
            stringify!(bsfs)
        )
    );
}
extern "C" {
    pub fn av_codec_get_max_lowres(codec: *const AVCodec) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MpegEncContext {
    _unused: [u8; 0],
}
/// @defgroup lavc_hwaccel AVHWAccel
/// @{
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVHWAccel {
    /// Name of the hardware accelerated codec.
    /// The name is globally unique among encoders and among decoders (but an
    /// encoder and a decoder can share the same name).
    pub name: *const libc::c_char,
    /// Type of codec implemented by the hardware accelerator.
    ///
    /// See AVMEDIA_TYPE_xxx
    pub type_: AVMediaType,
    /// Codec implemented by the hardware accelerator.
    ///
    /// See AV_CODEC_ID_xxx
    pub id: AVCodecID,
    /// Supported pixel format.
    ///
    /// Only hardware accelerated formats are supported here.
    pub pix_fmt: AVPixelFormat,
    /// Hardware accelerated codec capabilities.
    /// see AV_HWACCEL_CODEC_CAP_*
    pub capabilities: libc::c_int,
    /// No fields below this line are part of the public API. They
    /// may not be used outside of libavcodec and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub next: *mut AVHWAccel,
    /// Allocate a custom buffer
    pub alloc_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, frame: *mut AVFrame) -> libc::c_int,
    >,
    /// Called at the beginning of each frame or field picture.
    ///
    /// Meaningful frame information (codec specific) is guaranteed to
    /// be parsed at this point. This function is mandatory.
    ///
    /// Note that buf can be NULL along with buf_size set to 0.
    /// Otherwise, this means the whole frame is available at this point.
    ///
    /// @param avctx the codec context
    /// @param buf the frame data buffer base
    /// @param buf_size the size of the frame in bytes
    /// @return zero if successful, a negative value otherwise
    pub start_frame: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, buf: *const u8, buf_size: u32)
            -> libc::c_int,
    >,
    /// Callback for each slice.
    ///
    /// Meaningful slice information (codec specific) is guaranteed to
    /// be parsed at this point. This function is mandatory.
    /// The only exception is XvMC, that works on MB level.
    ///
    /// @param avctx the codec context
    /// @param buf the slice data buffer base
    /// @param buf_size the size of the slice in bytes
    /// @return zero if successful, a negative value otherwise
    pub decode_slice: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, buf: *const u8, buf_size: u32)
            -> libc::c_int,
    >,
    /// Called at the end of each frame or field picture.
    ///
    /// The whole picture is parsed at this point and can now be sent
    /// to the hardware accelerator. This function is mandatory.
    ///
    /// @param avctx the codec context
    /// @return zero if successful, a negative value otherwise
    pub end_frame:
        ::std::option::Option<unsafe extern "C" fn(avctx: *mut AVCodecContext) -> libc::c_int>,
    /// Size of per-frame hardware accelerator private data.
    ///
    /// Private data is allocated with av_mallocz() before
    /// AVCodecContext.get_buffer() and deallocated after
    /// AVCodecContext.release_buffer().
    pub frame_priv_data_size: libc::c_int,
    /// Called for every Macroblock in a slice.
    ///
    /// XvMC uses it to replace the ff_mpv_reconstruct_mb().
    /// Instead of decoding to raw picture, MB parameters are
    /// stored in an array provided by the video driver.
    ///
    /// @param s the mpeg context
    pub decode_mb: ::std::option::Option<unsafe extern "C" fn(s: *mut MpegEncContext)>,
    /// Initialize the hwaccel private data.
    ///
    /// This will be called from ff_get_format(), after hwaccel and
    /// hwaccel_context are set and the hwaccel private data in AVCodecInternal
    /// is allocated.
    pub init:
        ::std::option::Option<unsafe extern "C" fn(avctx: *mut AVCodecContext) -> libc::c_int>,
    /// Uninitialize the hwaccel private data.
    ///
    /// This will be called from get_format() or avcodec_close(), after hwaccel
    /// and hwaccel_context are already uninitialized.
    pub uninit:
        ::std::option::Option<unsafe extern "C" fn(avctx: *mut AVCodecContext) -> libc::c_int>,
    /// Size of the private data to allocate in
    /// AVCodecInternal.hwaccel_priv_data.
    pub priv_data_size: libc::c_int,
    /// Internal hwaccel capabilities.
    pub caps_internal: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVHWAccel() {
    assert_eq!(
        ::std::mem::size_of::<AVHWAccel>(),
        104usize,
        concat!("Size of: ", stringify!(AVHWAccel))
    );
    assert_eq!(
        ::std::mem::align_of::<AVHWAccel>(),
        8usize,
        concat!("Alignment of ", stringify!(AVHWAccel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).pix_fmt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).capabilities as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).alloc_frame as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(alloc_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).start_frame as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(start_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).decode_slice as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(decode_slice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).end_frame as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(end_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).frame_priv_data_size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(frame_priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).decode_mb as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(decode_mb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).init as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).uninit as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(uninit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).priv_data_size as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVHWAccel>())).caps_internal as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(AVHWAccel),
            "::",
            stringify!(caps_internal)
        )
    );
}
/// Picture data structure.
///
/// Up to four components can be stored into it, the last component is
/// alpha.
/// @deprecated use AVFrame or imgutils functions instead
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPicture {
    /// < pointers to the image data planes
    pub data: [*mut u8; 8usize],
    /// < number of bytes per line
    pub linesize: [libc::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_AVPicture() {
    assert_eq!(
        ::std::mem::size_of::<AVPicture>(),
        96usize,
        concat!("Size of: ", stringify!(AVPicture))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPicture>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPicture))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPicture>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPicture),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPicture>())).linesize as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPicture),
            "::",
            stringify!(linesize)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVSubtitleType {
    SUBTITLE_NONE = 0,
    SUBTITLE_BITMAP = 1,
    SUBTITLE_TEXT = 2,
    SUBTITLE_ASS = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVSubtitleRect {
    /// < top left corner  of pict, undefined when pict is not set
    pub x: libc::c_int,
    /// < top left corner  of pict, undefined when pict is not set
    pub y: libc::c_int,
    /// < width            of pict, undefined when pict is not set
    pub w: libc::c_int,
    /// < height           of pict, undefined when pict is not set
    pub h: libc::c_int,
    /// < number of colors in pict, undefined when pict is not set
    pub nb_colors: libc::c_int,
    /// @deprecated unused
    pub pict: AVPicture,
    /// data+linesize for the bitmap of this subtitle.
    /// Can be set for text/ass as well once they are rendered.
    pub data: [*mut u8; 4usize],
    pub linesize: [libc::c_int; 4usize],
    pub type_: AVSubtitleType,
    /// < 0 terminated plain UTF-8 text
    pub text: *mut libc::c_char,
    /// 0 terminated ASS/SSA compatible event line.
    /// The presentation of this is unaffected by the other values in this
    /// struct.
    pub ass: *mut libc::c_char,
    pub flags: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVSubtitleRect() {
    assert_eq!(
        ::std::mem::size_of::<AVSubtitleRect>(),
        200usize,
        concat!("Size of: ", stringify!(AVSubtitleRect))
    );
    assert_eq!(
        ::std::mem::align_of::<AVSubtitleRect>(),
        8usize,
        concat!("Alignment of ", stringify!(AVSubtitleRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).nb_colors as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(nb_colors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).pict as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(pict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).data as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).linesize as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(linesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).type_ as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).text as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).ass as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(ass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitleRect>())).flags as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitleRect),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVSubtitle {
    pub format: u16,
    pub start_display_time: u32,
    pub end_display_time: u32,
    pub num_rects: libc::c_uint,
    pub rects: *mut *mut AVSubtitleRect,
    /// < Same as packet pts, in AV_TIME_BASE
    pub pts: i64,
}
#[test]
fn bindgen_test_layout_AVSubtitle() {
    assert_eq!(
        ::std::mem::size_of::<AVSubtitle>(),
        32usize,
        concat!("Size of: ", stringify!(AVSubtitle))
    );
    assert_eq!(
        ::std::mem::align_of::<AVSubtitle>(),
        8usize,
        concat!("Alignment of ", stringify!(AVSubtitle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).start_display_time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(start_display_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).end_display_time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(end_display_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).num_rects as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(num_rects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).rects as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(rects)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVSubtitle>())).pts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVSubtitle),
            "::",
            stringify!(pts)
        )
    );
}
/// This struct describes the properties of an encoded stream.
///
/// sizeof(AVCodecParameters) is not a part of the public ABI, this struct must
/// be allocated with avcodec_parameters_alloc() and freed with
/// avcodec_parameters_free().
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecParameters {
    /// General type of the encoded data.
    pub codec_type: AVMediaType,
    /// Specific type of the encoded data (the codec used).
    pub codec_id: AVCodecID,
    /// Additional information about the codec (corresponds to the AVI FOURCC).
    pub codec_tag: u32,
    /// Extra binary data needed for initializing the decoder, codec-dependent.
    ///
    /// Must be allocated with av_malloc() and will be freed by
    /// avcodec_parameters_free(). The allocated size of extradata must be at
    /// least extradata_size + AV_INPUT_BUFFER_PADDING_SIZE, with the padding
    /// bytes zeroed.
    pub extradata: *mut u8,
    /// Size of the extradata content in bytes.
    pub extradata_size: libc::c_int,
    /// - video: the pixel format, the value corresponds to enum AVPixelFormat.
    /// - audio: the sample format, the value corresponds to enum AVSampleFormat.
    pub format: libc::c_int,
    /// The average bitrate of the encoded data (in bits per second).
    pub bit_rate: i64,
    /// The number of bits per sample in the codedwords.
    ///
    /// This is basically the bitrate per sample. It is mandatory for a bunch of
    /// formats to actually decode them. It's the number of bits for one sample in
    /// the actual coded bitstream.
    ///
    /// This could be for example 4 for ADPCM
    /// For PCM formats this matches bits_per_raw_sample
    /// Can be 0
    pub bits_per_coded_sample: libc::c_int,
    /// This is the number of valid bits in each output sample. If the
    /// sample format has more bits, the least significant bits are additional
    /// padding bits, which are always 0. Use right shifts to reduce the sample
    /// to its actual size. For example, audio formats with 24 bit samples will
    /// have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32.
    /// To get the original sample use "(int32_t)sample >> 8"."
    ///
    /// For ADPCM this might be 12 or 16 or similar
    /// Can be 0
    pub bits_per_raw_sample: libc::c_int,
    /// Codec-specific bitstream restrictions that the stream conforms to.
    pub profile: libc::c_int,
    pub level: libc::c_int,
    /// Video only. The dimensions of the video frame in pixels.
    pub width: libc::c_int,
    pub height: libc::c_int,
    /// Video only. The aspect ratio (width / height) which a single pixel
    /// should have when displayed.
    ///
    /// When the aspect ratio is unknown / undefined, the numerator should be
    /// set to 0 (the denominator may have any value).
    pub sample_aspect_ratio: AVRational,
    /// Video only. The order of the fields in interlaced video.
    pub field_order: AVFieldOrder,
    /// Video only. Additional colorspace characteristics.
    pub color_range: AVColorRange,
    pub color_primaries: AVColorPrimaries,
    pub color_trc: AVColorTransferCharacteristic,
    pub color_space: AVColorSpace,
    pub chroma_location: AVChromaLocation,
    /// Video only. Number of delayed frames.
    pub video_delay: libc::c_int,
    /// Audio only. The channel layout bitmask. May be 0 if the channel layout is
    /// unknown or unspecified, otherwise the number of bits set must be equal to
    /// the channels field.
    pub channel_layout: u64,
    /// Audio only. The number of audio channels.
    pub channels: libc::c_int,
    /// Audio only. The number of audio samples per second.
    pub sample_rate: libc::c_int,
    /// Audio only. The number of bytes per coded audio frame, required by some
    /// formats.
    ///
    /// Corresponds to nBlockAlign in WAVEFORMATEX.
    pub block_align: libc::c_int,
    /// Audio only. Audio frame size, if known. Required by some formats to be static.
    pub frame_size: libc::c_int,
    /// Audio only. The amount of padding (in samples) inserted by the encoder at
    /// the beginning of the audio. I.e. this number of leading decoded samples
    /// must be discarded by the caller to get the original audio without leading
    /// padding.
    pub initial_padding: libc::c_int,
    /// Audio only. The amount of padding (in samples) appended by the encoder to
    /// the end of the audio. I.e. this number of decoded samples must be
    /// discarded by the caller from the end of the stream to get the original
    /// audio without any trailing padding.
    pub trailing_padding: libc::c_int,
    /// Audio only. Number of samples to skip after a discontinuity.
    pub seek_preroll: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecParameters() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecParameters>(),
        144usize,
        concat!("Size of: ", stringify!(AVCodecParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).codec_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).codec_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).codec_tag as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).extradata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(extradata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).extradata_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(extradata_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).format as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).bit_rate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).bits_per_coded_sample as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bits_per_coded_sample)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).bits_per_raw_sample as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(bits_per_raw_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).profile as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).level as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).width as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).height as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).sample_aspect_ratio as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).field_order as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).color_range as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).color_primaries as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_primaries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).color_trc as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_trc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).color_space as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(color_space)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).chroma_location as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(chroma_location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).video_delay as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(video_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).channel_layout as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).channels as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).sample_rate as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).block_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(block_align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).frame_size as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).initial_padding as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(initial_padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParameters>())).trailing_padding as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(trailing_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParameters>())).seek_preroll as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParameters),
            "::",
            stringify!(seek_preroll)
        )
    );
}
extern "C" {
    /// If c is NULL, returns the first registered codec,
    /// if c is non-NULL, returns the next registered codec after c,
    /// or NULL if c is the last one.
    pub fn av_codec_next(c: *const AVCodec) -> *mut AVCodec;
}
extern "C" {
    /// Return the LIBAVCODEC_VERSION_INT constant.
    pub fn avcodec_version() -> libc::c_uint;
}
extern "C" {
    /// Return the libavcodec build-time configuration.
    pub fn avcodec_configuration() -> *const libc::c_char;
}
extern "C" {
    /// Return the libavcodec license.
    pub fn avcodec_license() -> *const libc::c_char;
}
extern "C" {
    /// Register the codec codec and initialize libavcodec.
    ///
    /// @warning either this function or avcodec_register_all() must be called
    /// before any other libavcodec functions.
    ///
    /// @see avcodec_register_all()
    pub fn avcodec_register(codec: *mut AVCodec);
}
extern "C" {
    /// Register all the codecs, parsers and bitstream filters which were enabled at
    /// configuration time. If you do not call this function you can select exactly
    /// which formats you want to support, by using the individual registration
    /// functions.
    ///
    /// @see avcodec_register
    /// @see av_register_codec_parser
    /// @see av_register_bitstream_filter
    pub fn avcodec_register_all();
}
extern "C" {
    /// Allocate an AVCodecContext and set its fields to default values. The
    /// resulting struct should be freed with avcodec_free_context().
    ///
    /// @param codec if non-NULL, allocate private data and initialize defaults
    /// for the given codec. It is illegal to then call avcodec_open2()
    /// with a different codec.
    /// If NULL, then the codec-specific defaults won't be initialized,
    /// which may result in suboptimal default settings (this is
    /// important mainly for encoders, e.g. libx264).
    ///
    /// @return An AVCodecContext filled with default values or NULL on failure.
    pub fn avcodec_alloc_context3(codec: *const AVCodec) -> *mut AVCodecContext;
}
extern "C" {
    /// Free the codec context and everything associated with it and write NULL to
    /// the provided pointer.
    pub fn avcodec_free_context(avctx: *mut *mut AVCodecContext);
}
extern "C" {
    /// @deprecated This function should not be used, as closing and opening a codec
    /// context multiple time is not supported. A new codec context should be
    /// allocated for each new use.
    pub fn avcodec_get_context_defaults3(
        s: *mut AVCodecContext,
        codec: *const AVCodec,
    ) -> libc::c_int;
}
extern "C" {
    /// Get the AVClass for AVCodecContext. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn avcodec_get_class() -> *const AVClass;
}
extern "C" {
    /// Get the AVClass for AVFrame. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn avcodec_get_frame_class() -> *const AVClass;
}
extern "C" {
    /// Get the AVClass for AVSubtitleRect. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn avcodec_get_subtitle_rect_class() -> *const AVClass;
}
extern "C" {
    /// Copy the settings of the source AVCodecContext into the destination
    /// AVCodecContext. The resulting destination codec context will be
    /// unopened, i.e. you are required to call avcodec_open2() before you
    /// can use this AVCodecContext to decode/encode video/audio data.
    ///
    /// @param dest target codec context, should be initialized with
    /// avcodec_alloc_context3(NULL), but otherwise uninitialized
    /// @param src source codec context
    /// @return AVERROR() on error (e.g. memory allocation error), 0 on success
    ///
    /// @deprecated The semantics of this function are ill-defined and it should not
    /// be used. If you need to transfer the stream parameters from one codec context
    /// to another, use an intermediate AVCodecParameters instance and the
    /// avcodec_parameters_from_context() / avcodec_parameters_to_context()
    /// functions.
    pub fn avcodec_copy_context(
        dest: *mut AVCodecContext,
        src: *const AVCodecContext,
    ) -> libc::c_int;
}
extern "C" {
    /// Allocate a new AVCodecParameters and set its fields to default values
    /// (unknown/invalid/0). The returned struct must be freed with
    /// avcodec_parameters_free().
    pub fn avcodec_parameters_alloc() -> *mut AVCodecParameters;
}
extern "C" {
    /// Free an AVCodecParameters instance and everything associated with it and
    /// write NULL to the supplied pointer.
    pub fn avcodec_parameters_free(par: *mut *mut AVCodecParameters);
}
extern "C" {
    /// Copy the contents of src to dst. Any allocated fields in dst are freed and
    /// replaced with newly allocated duplicates of the corresponding fields in src.
    ///
    /// @return >= 0 on success, a negative AVERROR code on failure.
    pub fn avcodec_parameters_copy(
        dst: *mut AVCodecParameters,
        src: *const AVCodecParameters,
    ) -> libc::c_int;
}
extern "C" {
    /// Fill the parameters struct based on the values from the supplied codec
    /// context. Any allocated fields in par are freed and replaced with duplicates
    /// of the corresponding fields in codec.
    ///
    /// @return >= 0 on success, a negative AVERROR code on failure
    pub fn avcodec_parameters_from_context(
        par: *mut AVCodecParameters,
        codec: *const AVCodecContext,
    ) -> libc::c_int;
}
extern "C" {
    /// Fill the codec context based on the values from the supplied codec
    /// parameters. Any allocated fields in codec that have a corresponding field in
    /// par are freed and replaced with duplicates of the corresponding field in par.
    /// Fields in codec that do not have a counterpart in par are not touched.
    ///
    /// @return >= 0 on success, a negative AVERROR code on failure.
    pub fn avcodec_parameters_to_context(
        codec: *mut AVCodecContext,
        par: *const AVCodecParameters,
    ) -> libc::c_int;
}
extern "C" {
    /// Initialize the AVCodecContext to use the given AVCodec. Prior to using this
    /// function the context has to be allocated with avcodec_alloc_context3().
    ///
    /// The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),
    /// avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
    /// retrieving a codec.
    ///
    /// @warning This function is not thread safe!
    ///
    /// @note Always call this function before using decoding routines (such as
    /// @ref avcodec_receive_frame()).
    ///
    /// @code
    /// avcodec_register_all();
    /// av_dict_set(&opts, "b", "2.5M", 0);
    /// codec = avcodec_find_decoder(AV_CODEC_ID_H264);
    /// if (!codec)
    /// exit(1);
    ///
    /// context = avcodec_alloc_context3(codec);
    ///
    /// if (avcodec_open2(context, codec, opts) < 0)
    /// exit(1);
    /// @endcode
    ///
    /// @param avctx The context to initialize.
    /// @param codec The codec to open this context for. If a non-NULL codec has been
    /// previously passed to avcodec_alloc_context3() or
    /// for this context, then this parameter MUST be either NULL or
    /// equal to the previously passed codec.
    /// @param options A dictionary filled with AVCodecContext and codec-private options.
    /// On return this object will be filled with options that were not found.
    ///
    /// @return zero on success, a negative value on error
    /// @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),
    /// av_dict_set(), av_opt_find().
    pub fn avcodec_open2(
        avctx: *mut AVCodecContext,
        codec: *const AVCodec,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    /// Close a given AVCodecContext and free all the data associated with it
    /// (but not the AVCodecContext itself).
    ///
    /// Calling this function on an AVCodecContext that hasn't been opened will free
    /// the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL
    /// codec. Subsequent calls will do nothing.
    ///
    /// @note Do not use this function. Use avcodec_free_context() to destroy a
    /// codec context (either open or closed). Opening and closing a codec context
    /// multiple times is not supported anymore -- use multiple codec contexts
    /// instead.
    pub fn avcodec_close(avctx: *mut AVCodecContext) -> libc::c_int;
}
extern "C" {
    /// Free all allocated data in the given subtitle struct.
    ///
    /// @param sub AVSubtitle to free.
    pub fn avsubtitle_free(sub: *mut AVSubtitle);
}
extern "C" {
    /// Allocate an AVPacket and set its fields to default values.  The resulting
    /// struct must be freed using av_packet_free().
    ///
    /// @return An AVPacket filled with default values or NULL on failure.
    ///
    /// @note this only allocates the AVPacket itself, not the data buffers. Those
    /// must be allocated through other means such as av_new_packet.
    ///
    /// @see av_new_packet
    pub fn av_packet_alloc() -> *mut AVPacket;
}
extern "C" {
    /// Create a new packet that references the same data as src.
    ///
    /// This is a shortcut for av_packet_alloc()+av_packet_ref().
    ///
    /// @return newly created AVPacket on success, NULL on error.
    ///
    /// @see av_packet_alloc
    /// @see av_packet_ref
    pub fn av_packet_clone(src: *const AVPacket) -> *mut AVPacket;
}
extern "C" {
    /// Free the packet, if the packet is reference counted, it will be
    /// unreferenced first.
    ///
    /// @param pkt packet to be freed. The pointer will be set to NULL.
    /// @note passing NULL is a no-op.
    pub fn av_packet_free(pkt: *mut *mut AVPacket);
}
extern "C" {
    /// Initialize optional fields of a packet with default values.
    ///
    /// Note, this does not touch the data and size members, which have to be
    /// initialized separately.
    ///
    /// @param pkt packet
    pub fn av_init_packet(pkt: *mut AVPacket);
}
extern "C" {
    /// Allocate the payload of a packet and initialize its fields with
    /// default values.
    ///
    /// @param pkt packet
    /// @param size wanted payload size
    /// @return 0 if OK, AVERROR_xxx otherwise
    pub fn av_new_packet(pkt: *mut AVPacket, size: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// Reduce packet size, correctly zeroing padding
    ///
    /// @param pkt packet
    /// @param size new size
    pub fn av_shrink_packet(pkt: *mut AVPacket, size: libc::c_int);
}
extern "C" {
    /// Increase packet size, correctly zeroing padding
    ///
    /// @param pkt packet
    /// @param grow_by number of bytes by which to increase the size of the packet
    pub fn av_grow_packet(pkt: *mut AVPacket, grow_by: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// Initialize a reference-counted packet from av_malloc()ed data.
    ///
    /// @param pkt packet to be initialized. This function will set the data, size,
    /// buf and destruct fields, all others are left untouched.
    /// @param data Data allocated by av_malloc() to be used as packet data. If this
    /// function returns successfully, the data is owned by the underlying AVBuffer.
    /// The caller may not access the data through other means.
    /// @param size size of data in bytes, without the padding. I.e. the full buffer
    /// size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.
    ///
    /// @return 0 on success, a negative AVERROR on error
    pub fn av_packet_from_data(pkt: *mut AVPacket, data: *mut u8, size: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    /// @warning This is a hack - the packet memory allocation stuff is broken. The
    /// packet is allocated if it was not really allocated.
    ///
    /// @deprecated Use av_packet_ref
    pub fn av_dup_packet(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    /// Copy packet, including contents
    ///
    /// @return 0 on success, negative AVERROR on fail
    ///
    /// @deprecated Use av_packet_ref
    pub fn av_copy_packet(dst: *mut AVPacket, src: *const AVPacket) -> libc::c_int;
}
extern "C" {
    /// Copy packet side data
    ///
    /// @return 0 on success, negative AVERROR on fail
    ///
    /// @deprecated Use av_packet_copy_props
    pub fn av_copy_packet_side_data(dst: *mut AVPacket, src: *const AVPacket) -> libc::c_int;
}
extern "C" {
    /// Free a packet.
    ///
    /// @deprecated Use av_packet_unref
    ///
    /// @param pkt packet to free
    pub fn av_free_packet(pkt: *mut AVPacket);
}
extern "C" {
    /// Allocate new information of a packet.
    ///
    /// @param pkt packet
    /// @param type side information type
    /// @param size side information size
    /// @return pointer to fresh allocated data or NULL otherwise
    pub fn av_packet_new_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    /// Wrap an existing array as a packet side data.
    ///
    /// @param pkt packet
    /// @param type side information type
    /// @param data the side data array. It must be allocated with the av_malloc()
    /// family of functions. The ownership of the data is transferred to
    /// pkt.
    /// @param size side information size
    /// @return a non-negative number on success, a negative AVERROR code on
    /// failure. On failure, the packet is unchanged and the data remains
    /// owned by the caller.
    pub fn av_packet_add_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> libc::c_int;
}
extern "C" {
    /// Shrink the already allocated side data buffer
    ///
    /// @param pkt packet
    /// @param type side information type
    /// @param size new side information size
    /// @return 0 on success, < 0 on failure
    pub fn av_packet_shrink_side_data(
        pkt: *mut AVPacket,
        type_: AVPacketSideDataType,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Get side information from packet.
    ///
    /// @param pkt packet
    /// @param type desired side information type
    /// @param size pointer for side information size to store (optional)
    /// @return pointer to data if present or NULL otherwise
    pub fn av_packet_get_side_data(
        pkt: *const AVPacket,
        type_: AVPacketSideDataType,
        size: *mut libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_packet_merge_side_data(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    pub fn av_packet_split_side_data(pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    pub fn av_packet_side_data_name(type_: AVPacketSideDataType) -> *const libc::c_char;
}
extern "C" {
    /// Pack a dictionary for use in side_data.
    ///
    /// @param dict The dictionary to pack.
    /// @param size pointer to store the size of the returned data
    /// @return pointer to data if successful, NULL otherwise
    pub fn av_packet_pack_dictionary(dict: *mut AVDictionary, size: *mut libc::c_int) -> *mut u8;
}
extern "C" {
    /// Unpack a dictionary from side_data.
    ///
    /// @param data data from side_data
    /// @param size size of the data
    /// @param dict the metadata storage dictionary
    /// @return 0 on success, < 0 on failure
    pub fn av_packet_unpack_dictionary(
        data: *const u8,
        size: libc::c_int,
        dict: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    /// Convenience function to free all the side data stored.
    /// All the other fields stay untouched.
    ///
    /// @param pkt packet
    pub fn av_packet_free_side_data(pkt: *mut AVPacket);
}
extern "C" {
    /// Setup a new reference to the data described by a given packet
    ///
    /// If src is reference-counted, setup dst as a new reference to the
    /// buffer in src. Otherwise allocate a new buffer in dst and copy the
    /// data from src into it.
    ///
    /// All the other fields are copied from src.
    ///
    /// @see av_packet_unref
    ///
    /// @param dst Destination packet
    /// @param src Source packet
    ///
    /// @return 0 on success, a negative AVERROR on error.
    pub fn av_packet_ref(dst: *mut AVPacket, src: *const AVPacket) -> libc::c_int;
}
extern "C" {
    /// Wipe the packet.
    ///
    /// Unreference the buffer referenced by the packet and reset the
    /// remaining packet fields to their default values.
    ///
    /// @param pkt The packet to be unreferenced.
    pub fn av_packet_unref(pkt: *mut AVPacket);
}
extern "C" {
    /// Move every field in src to dst and reset src.
    ///
    /// @see av_packet_unref
    ///
    /// @param src Source packet, will be reset
    /// @param dst Destination packet
    pub fn av_packet_move_ref(dst: *mut AVPacket, src: *mut AVPacket);
}
extern "C" {
    /// Copy only "properties" fields from src to dst.
    ///
    /// Properties for the purpose of this function are all the fields
    /// beside those related to the packet data (buf, data, size)
    ///
    /// @param dst Destination packet
    /// @param src Source packet
    ///
    /// @return 0 on success AVERROR on failure.
    pub fn av_packet_copy_props(dst: *mut AVPacket, src: *const AVPacket) -> libc::c_int;
}
extern "C" {
    /// Convert valid timing fields (timestamps / durations) in a packet from one
    /// timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be
    /// ignored.
    ///
    /// @param pkt packet on which the conversion will be performed
    /// @param tb_src source timebase, in which the timing fields in pkt are
    /// expressed
    /// @param tb_dst destination timebase, to which the timing fields will be
    /// converted
    pub fn av_packet_rescale_ts(pkt: *mut AVPacket, tb_src: AVRational, tb_dst: AVRational);
}
extern "C" {
    /// Find a registered decoder with a matching codec ID.
    ///
    /// @param id AVCodecID of the requested decoder
    /// @return A decoder if one was found, NULL otherwise.
    pub fn avcodec_find_decoder(id: AVCodecID) -> *mut AVCodec;
}
extern "C" {
    /// Find a registered decoder with the specified name.
    ///
    /// @param name name of the requested decoder
    /// @return A decoder if one was found, NULL otherwise.
    pub fn avcodec_find_decoder_by_name(name: *const libc::c_char) -> *mut AVCodec;
}
extern "C" {
    /// The default callback for AVCodecContext.get_buffer2(). It is made public so
    /// it can be called by custom get_buffer2() implementations for decoders without
    /// AV_CODEC_CAP_DR1 set.
    pub fn avcodec_default_get_buffer2(
        s: *mut AVCodecContext,
        frame: *mut AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Return the amount of padding in pixels which the get_buffer callback must
    /// provide around the edge of the image for codecs which do not have the
    /// CODEC_FLAG_EMU_EDGE flag.
    ///
    /// @return Required padding in pixels.
    ///
    /// @deprecated CODEC_FLAG_EMU_EDGE is deprecated, so this function is no longer
    /// needed
    pub fn avcodec_get_edge_width() -> libc::c_uint;
}
extern "C" {
    /// Modify width and height values so that they will result in a memory
    /// buffer that is acceptable for the codec if you do not use any horizontal
    /// padding.
    ///
    /// May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
    pub fn avcodec_align_dimensions(
        s: *mut AVCodecContext,
        width: *mut libc::c_int,
        height: *mut libc::c_int,
    );
}
extern "C" {
    /// Modify width and height values so that they will result in a memory
    /// buffer that is acceptable for the codec if you also ensure that all
    /// line sizes are a multiple of the respective linesize_align[i].
    ///
    /// May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
    pub fn avcodec_align_dimensions2(
        s: *mut AVCodecContext,
        width: *mut libc::c_int,
        height: *mut libc::c_int,
        linesize_align: *mut libc::c_int,
    );
}
extern "C" {
    /// Converts AVChromaLocation to swscale x/y chroma position.
    ///
    /// The positions represent the chroma (0,0) position in a coordinates system
    /// with luma (0,0) representing the origin and luma(1,1) representing 256,256
    ///
    /// @param xpos  horizontal chroma sample position
    /// @param ypos  vertical   chroma sample position
    pub fn avcodec_enum_to_chroma_pos(
        xpos: *mut libc::c_int,
        ypos: *mut libc::c_int,
        pos: AVChromaLocation,
    ) -> libc::c_int;
}
extern "C" {
    /// Converts swscale x/y chroma position to AVChromaLocation.
    ///
    /// The positions represent the chroma (0,0) position in a coordinates system
    /// with luma (0,0) representing the origin and luma(1,1) representing 256,256
    ///
    /// @param xpos  horizontal chroma sample position
    /// @param ypos  vertical   chroma sample position
    pub fn avcodec_chroma_pos_to_enum(xpos: libc::c_int, ypos: libc::c_int) -> AVChromaLocation;
}
extern "C" {
    /// Decode the audio frame of size avpkt->size from avpkt->data into frame.
    ///
    /// Some decoders may support multiple frames in a single AVPacket. Such
    /// decoders would then just decode the first frame and the return value would be
    /// less than the packet size. In this case, avcodec_decode_audio4 has to be
    /// called again with an AVPacket containing the remaining data in order to
    /// decode the second frame, etc...  Even if no frames are returned, the packet
    /// needs to be fed to the decoder with remaining data until it is completely
    /// consumed or an error occurs.
    ///
    /// Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
    /// and output. This means that for some packets they will not immediately
    /// produce decoded output and need to be flushed at the end of decoding to get
    /// all the decoded data. Flushing is done by calling this function with packets
    /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
    /// returning samples. It is safe to flush even those decoders that are not
    /// marked with AV_CODEC_CAP_DELAY, then no samples will be returned.
    ///
    /// @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
    /// larger than the actual read bytes because some optimized bitstream
    /// readers read 32 or 64 bits at once and could read over the end.
    ///
    /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
    /// before packets may be fed to the decoder.
    ///
    /// @param      avctx the codec context
    /// @param[out] frame The AVFrame in which to store decoded audio samples.
    /// The decoder will allocate a buffer for the decoded frame by
    /// calling the AVCodecContext.get_buffer2() callback.
    /// When AVCodecContext.refcounted_frames is set to 1, the frame is
    /// reference counted and the returned reference belongs to the
    /// caller. The caller must release the frame using av_frame_unref()
    /// when the frame is no longer needed. The caller may safely write
    /// to the frame if av_frame_is_writable() returns 1.
    /// When AVCodecContext.refcounted_frames is set to 0, the returned
    /// reference belongs to the decoder and is valid only until the
    /// next call to this function or until closing or flushing the
    /// decoder. The caller may not write to it.
    /// @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is
    /// non-zero. Note that this field being set to zero
    /// does not mean that an error has occurred. For
    /// decoders with AV_CODEC_CAP_DELAY set, no given decode
    /// call is guaranteed to produce a frame.
    /// @param[in]  avpkt The input AVPacket containing the input buffer.
    /// At least avpkt->data and avpkt->size should be set. Some
    /// decoders might also require additional fields to be set.
    /// @return A negative error code is returned if an error occurred during
    /// decoding, otherwise the number of bytes consumed from the input
    /// AVPacket is returned.
    ///
    /// @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
    pub fn avcodec_decode_audio4(
        avctx: *mut AVCodecContext,
        frame: *mut AVFrame,
        got_frame_ptr: *mut libc::c_int,
        avpkt: *const AVPacket,
    ) -> libc::c_int;
}
extern "C" {
    /// Decode the video frame of size avpkt->size from avpkt->data into picture.
    /// Some decoders may support multiple frames in a single AVPacket, such
    /// decoders would then just decode the first frame.
    ///
    /// @warning The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than
    /// the actual read bytes because some optimized bitstream readers read 32 or 64
    /// bits at once and could read over the end.
    ///
    /// @warning The end of the input buffer buf should be set to 0 to ensure that
    /// no overreading happens for damaged MPEG streams.
    ///
    /// @note Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay
    /// between input and output, these need to be fed with avpkt->data=NULL,
    /// avpkt->size=0 at the end to return the remaining frames.
    ///
    /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
    /// before packets may be fed to the decoder.
    ///
    /// @param avctx the codec context
    /// @param[out] picture The AVFrame in which the decoded video frame will be stored.
    /// Use av_frame_alloc() to get an AVFrame. The codec will
    /// allocate memory for the actual bitmap by calling the
    /// AVCodecContext.get_buffer2() callback.
    /// When AVCodecContext.refcounted_frames is set to 1, the frame is
    /// reference counted and the returned reference belongs to the
    /// caller. The caller must release the frame using av_frame_unref()
    /// when the frame is no longer needed. The caller may safely write
    /// to the frame if av_frame_is_writable() returns 1.
    /// When AVCodecContext.refcounted_frames is set to 0, the returned
    /// reference belongs to the decoder and is valid only until the
    /// next call to this function or until closing or flushing the
    /// decoder. The caller may not write to it.
    ///
    /// @param[in] avpkt The input AVPacket containing the input buffer.
    /// You can create such packet with av_init_packet() and by then setting
    /// data and size, some decoders might in addition need other fields like
    /// flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least
    /// fields possible.
    /// @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.
    /// @return On error a negative value is returned, otherwise the number of bytes
    /// used or zero if no frame could be decompressed.
    ///
    /// @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
    pub fn avcodec_decode_video2(
        avctx: *mut AVCodecContext,
        picture: *mut AVFrame,
        got_picture_ptr: *mut libc::c_int,
        avpkt: *const AVPacket,
    ) -> libc::c_int;
}
extern "C" {
    /// Decode a subtitle message.
    /// Return a negative value on error, otherwise return the number of bytes used.
    /// If no subtitle could be decompressed, got_sub_ptr is zero.
    /// Otherwise, the subtitle is stored in *sub.
    /// Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for
    /// simplicity, because the performance difference is expect to be negligible
    /// and reusing a get_buffer written for video codecs would probably perform badly
    /// due to a potentially very different allocation pattern.
    ///
    /// Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
    /// and output. This means that for some packets they will not immediately
    /// produce decoded output and need to be flushed at the end of decoding to get
    /// all the decoded data. Flushing is done by calling this function with packets
    /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
    /// returning subtitles. It is safe to flush even those decoders that are not
    /// marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.
    ///
    /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
    /// before packets may be fed to the decoder.
    ///
    /// @param avctx the codec context
    /// @param[out] sub The Preallocated AVSubtitle in which the decoded subtitle will be stored,
    /// must be freed with avsubtitle_free if *got_sub_ptr is set.
    /// @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.
    /// @param[in] avpkt The input AVPacket containing the input buffer.
    pub fn avcodec_decode_subtitle2(
        avctx: *mut AVCodecContext,
        sub: *mut AVSubtitle,
        got_sub_ptr: *mut libc::c_int,
        avpkt: *mut AVPacket,
    ) -> libc::c_int;
}
extern "C" {
    /// Supply raw packet data as input to a decoder.
    ///
    /// Internally, this call will copy relevant AVCodecContext fields, which can
    /// influence decoding per-packet, and apply them when the packet is actually
    /// decoded. (For example AVCodecContext.skip_frame, which might direct the
    /// decoder to drop the frame contained by the packet sent with this function.)
    ///
    /// @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
    /// larger than the actual read bytes because some optimized bitstream
    /// readers read 32 or 64 bits at once and could read over the end.
    ///
    /// @warning Do not mix this API with the legacy API (like avcodec_decode_video2())
    /// on the same AVCodecContext. It will return unexpected results now
    /// or in future libavcodec versions.
    ///
    /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
    /// before packets may be fed to the decoder.
    ///
    /// @param avctx codec context
    /// @param[in] avpkt The input AVPacket. Usually, this will be a single video
    /// frame, or several complete audio frames.
    /// Ownership of the packet remains with the caller, and the
    /// decoder will not write to the packet. The decoder may create
    /// a reference to the packet data (or copy it if the packet is
    /// not reference-counted).
    /// Unlike with older APIs, the packet is always fully consumed,
    /// and if it contains multiple frames (e.g. some audio codecs),
    /// will require you to call avcodec_receive_frame() multiple
    /// times afterwards before you can send a new packet.
    /// It can be NULL (or an AVPacket with data set to NULL and
    /// size set to 0); in this case, it is considered a flush
    /// packet, which signals the end of the stream. Sending the
    /// first flush packet will return success. Subsequent ones are
    /// unnecessary and will return AVERROR_EOF. If the decoder
    /// still has frames buffered, it will return them after sending
    /// a flush packet.
    ///
    /// @return 0 on success, otherwise negative error code:
    /// AVERROR(EAGAIN):   input is not accepted in the current state - user
    /// must read output with avcodec_receive_frame() (once
    /// all output is read, the packet should be resent, and
    /// the call will not fail with EAGAIN).
    /// AVERROR_EOF:       the decoder has been flushed, and no new packets can
    /// be sent to it (also returned if more than 1 flush
    /// packet is sent)
    /// AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush
    /// AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
    /// other errors: legitimate decoding errors
    pub fn avcodec_send_packet(avctx: *mut AVCodecContext, avpkt: *const AVPacket) -> libc::c_int;
}
extern "C" {
    /// Return decoded output data from a decoder.
    ///
    /// @param avctx codec context
    /// @param frame This will be set to a reference-counted video or audio
    /// frame (depending on the decoder type) allocated by the
    /// decoder. Note that the function will always call
    /// av_frame_unref(frame) before doing anything else.
    ///
    /// @return
    /// 0:                 success, a frame was returned
    /// AVERROR(EAGAIN):   output is not available in this state - user must try
    /// to send new input
    /// AVERROR_EOF:       the decoder has been fully flushed, and there will be
    /// no more output frames
    /// AVERROR(EINVAL):   codec not opened, or it is an encoder
    /// other negative values: legitimate decoding errors
    pub fn avcodec_receive_frame(avctx: *mut AVCodecContext, frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    /// Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()
    /// to retrieve buffered output packets.
    ///
    /// @param avctx     codec context
    /// @param[in] frame AVFrame containing the raw audio or video frame to be encoded.
    /// Ownership of the frame remains with the caller, and the
    /// encoder will not write to the frame. The encoder may create
    /// a reference to the frame data (or copy it if the frame is
    /// not reference-counted).
    /// It can be NULL, in which case it is considered a flush
    /// packet.  This signals the end of the stream. If the encoder
    /// still has packets buffered, it will return them after this
    /// call. Once flushing mode has been entered, additional flush
    /// packets are ignored, and sending frames will return
    /// AVERROR_EOF.
    ///
    /// For audio:
    /// If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
    /// can have any number of samples.
    /// If it is not set, frame->nb_samples must be equal to
    /// avctx->frame_size for all frames except the last.
    /// The final frame may be smaller than avctx->frame_size.
    /// @return 0 on success, otherwise negative error code:
    /// AVERROR(EAGAIN):   input is not accepted in the current state - user
    /// must read output with avcodec_receive_packet() (once
    /// all output is read, the packet should be resent, and
    /// the call will not fail with EAGAIN).
    /// AVERROR_EOF:       the encoder has been flushed, and no new frames can
    /// be sent to it
    /// AVERROR(EINVAL):   codec not opened, refcounted_frames not set, it is a
    /// decoder, or requires flush
    /// AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
    /// other errors: legitimate decoding errors
    pub fn avcodec_send_frame(avctx: *mut AVCodecContext, frame: *const AVFrame) -> libc::c_int;
}
extern "C" {
    /// Read encoded data from the encoder.
    ///
    /// @param avctx codec context
    /// @param avpkt This will be set to a reference-counted packet allocated by the
    /// encoder. Note that the function will always call
    /// av_frame_unref(frame) before doing anything else.
    /// @return 0 on success, otherwise negative error code:
    /// AVERROR(EAGAIN):   output is not available in the current state - user
    /// must try to send input
    /// AVERROR_EOF:       the encoder has been fully flushed, and there will be
    /// no more output packets
    /// AVERROR(EINVAL):   codec not opened, or it is an encoder
    /// other errors: legitimate decoding errors
    pub fn avcodec_receive_packet(avctx: *mut AVCodecContext, avpkt: *mut AVPacket) -> libc::c_int;
}
#[repr(u32)]
/// @defgroup lavc_parsing Frame parsing
/// @{
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVPictureStructure {
    AV_PICTURE_STRUCTURE_UNKNOWN = 0,
    AV_PICTURE_STRUCTURE_TOP_FIELD = 1,
    AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2,
    AV_PICTURE_STRUCTURE_FRAME = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecParserContext {
    pub priv_data: *mut libc::c_void,
    pub parser: *mut AVCodecParser,
    pub frame_offset: i64,
    pub cur_offset: i64,
    pub next_frame_offset: i64,
    pub pict_type: libc::c_int,
    /// This field is used for proper frame duration computation in lavf.
    /// It signals, how much longer the frame duration of the current frame
    /// is compared to normal frame duration.
    ///
    /// frame_duration = (1 + repeat_pict) * time_base
    ///
    /// It is used by codecs like H.264 to display telecined material.
    pub repeat_pict: libc::c_int,
    pub pts: i64,
    pub dts: i64,
    pub last_pts: i64,
    pub last_dts: i64,
    pub fetch_timestamp: libc::c_int,
    pub cur_frame_start_index: libc::c_int,
    pub cur_frame_offset: [i64; 4usize],
    pub cur_frame_pts: [i64; 4usize],
    pub cur_frame_dts: [i64; 4usize],
    pub flags: libc::c_int,
    /// < byte offset from starting packet start
    pub offset: i64,
    pub cur_frame_end: [i64; 4usize],
    /// Set by parser to 1 for key frames and 0 for non-key frames.
    /// It is initialized to -1, so if the parser doesn't set this flag,
    /// old-style fallback using AV_PICTURE_TYPE_I picture type as key frames
    /// will be used.
    pub key_frame: libc::c_int,
    /// @deprecated unused
    pub convergence_duration: i64,
    /// Synchronization point for start of timestamp generation.
    ///
    /// Set to >0 for sync point, 0 for no sync point and <0 for undefined
    /// (default).
    ///
    /// For example, this corresponds to presence of H.264 buffering period
    /// SEI message.
    pub dts_sync_point: libc::c_int,
    /// Offset of the current timestamp against last timestamp sync point in
    /// units of AVCodecContext.time_base.
    ///
    /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
    /// contain a valid timestamp offset.
    ///
    /// Note that the timestamp of sync point has usually a nonzero
    /// dts_ref_dts_delta, which refers to the previous sync point. Offset of
    /// the next frame after timestamp sync point will be usually 1.
    ///
    /// For example, this corresponds to H.264 cpb_removal_delay.
    pub dts_ref_dts_delta: libc::c_int,
    /// Presentation delay of current frame in units of AVCodecContext.time_base.
    ///
    /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
    /// contain valid non-negative timestamp delta (presentation time of a frame
    /// must not lie in the past).
    ///
    /// This delay represents the difference between decoding and presentation
    /// time of the frame.
    ///
    /// For example, this corresponds to H.264 dpb_output_delay.
    pub pts_dts_delta: libc::c_int,
    /// Position of the packet in file.
    ///
    /// Analogous to cur_frame_pts/dts
    pub cur_frame_pos: [i64; 4usize],
    /// Byte position of currently parsed frame in stream.
    pub pos: i64,
    /// Previous frame byte position.
    pub last_pos: i64,
    /// Duration of the current frame.
    /// For audio, this is in units of 1 / AVCodecContext.sample_rate.
    /// For all other types, this is in units of AVCodecContext.time_base.
    pub duration: libc::c_int,
    pub field_order: AVFieldOrder,
    /// Indicate whether a picture is coded as a frame, top field or bottom field.
    ///
    /// For example, H.264 field_pic_flag equal to 0 corresponds to
    /// AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag
    /// equal to 1 and bottom_field_flag equal to 0 corresponds to
    /// AV_PICTURE_STRUCTURE_TOP_FIELD.
    pub picture_structure: AVPictureStructure,
    /// Picture number incremented in presentation or output order.
    /// This field may be reinitialized at the first picture of a new sequence.
    ///
    /// For example, this corresponds to H.264 PicOrderCnt.
    pub output_picture_number: libc::c_int,
    /// Dimensions of the decoded video intended for presentation.
    pub width: libc::c_int,
    pub height: libc::c_int,
    /// Dimensions of the coded video.
    pub coded_width: libc::c_int,
    pub coded_height: libc::c_int,
    /// The format of the coded data, corresponds to enum AVPixelFormat for video
    /// and for enum AVSampleFormat for audio.
    ///
    /// Note that a decoder can have considerable freedom in how exactly it
    /// decodes the data, so the format reported here might be different from the
    /// one returned by a decoder.
    pub format: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVCodecParserContext() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecParserContext>(),
        352usize,
        concat!("Size of: ", stringify!(AVCodecParserContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecParserContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParserContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).priv_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).parser as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).frame_offset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(frame_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).cur_offset as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).next_frame_offset as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(next_frame_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).pict_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pict_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).repeat_pict as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(repeat_pict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).pts as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).dts as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).last_pts as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).last_dts as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).fetch_timestamp as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(fetch_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_start_index as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_start_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_offset as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_pts as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_pts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_dts as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).flags as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).offset as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_end as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).key_frame as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(key_frame)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).convergence_duration as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(convergence_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).dts_sync_point as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts_sync_point)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).dts_ref_dts_delta as *const _ as usize
        },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(dts_ref_dts_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).pts_dts_delta as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pts_dts_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).cur_frame_pos as *const _ as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(cur_frame_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).pos as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).last_pos as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(last_pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).duration as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).field_order as *const _ as usize
        },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(field_order)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).picture_structure as *const _ as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(picture_structure)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).output_picture_number as *const _
                as usize
        },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(output_picture_number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).width as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).height as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).coded_width as *const _ as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(coded_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVCodecParserContext>())).coded_height as *const _ as usize
        },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(coded_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParserContext>())).format as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParserContext),
            "::",
            stringify!(format)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVCodecParser {
    pub codec_ids: [libc::c_int; 5usize],
    pub priv_data_size: libc::c_int,
    pub parser_init:
        ::std::option::Option<unsafe extern "C" fn(s: *mut AVCodecParserContext) -> libc::c_int>,
    pub parser_parse: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVCodecParserContext,
            avctx: *mut AVCodecContext,
            poutbuf: *mut *const u8,
            poutbuf_size: *mut libc::c_int,
            buf: *const u8,
            buf_size: libc::c_int,
        ) -> libc::c_int,
    >,
    pub parser_close: ::std::option::Option<unsafe extern "C" fn(s: *mut AVCodecParserContext)>,
    pub split: ::std::option::Option<
        unsafe extern "C" fn(avctx: *mut AVCodecContext, buf: *const u8, buf_size: libc::c_int)
            -> libc::c_int,
    >,
    pub next: *mut AVCodecParser,
}
#[test]
fn bindgen_test_layout_AVCodecParser() {
    assert_eq!(
        ::std::mem::size_of::<AVCodecParser>(),
        64usize,
        concat!("Size of: ", stringify!(AVCodecParser))
    );
    assert_eq!(
        ::std::mem::align_of::<AVCodecParser>(),
        8usize,
        concat!("Alignment of ", stringify!(AVCodecParser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).codec_ids as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(codec_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).priv_data_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).parser_init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).parser_parse as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).parser_close as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(parser_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).split as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(split)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVCodecParser>())).next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVCodecParser),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn av_parser_next(c: *const AVCodecParser) -> *mut AVCodecParser;
}
extern "C" {
    pub fn av_register_codec_parser(parser: *mut AVCodecParser);
}
extern "C" {
    pub fn av_parser_init(codec_id: libc::c_int) -> *mut AVCodecParserContext;
}
extern "C" {
    /// Parse a packet.
    ///
    /// @param s             parser context.
    /// @param avctx         codec context.
    /// @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.
    /// @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.
    /// @param buf           input buffer.
    /// @param buf_size      buffer size in bytes without the padding. I.e. the full buffer
    /// size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.
    /// To signal EOF, this should be 0 (so that the last frame
    /// can be output).
    /// @param pts           input presentation timestamp.
    /// @param dts           input decoding timestamp.
    /// @param pos           input byte position in stream.
    /// @return the number of bytes of the input bitstream used.
    ///
    /// Example:
    /// @code
    /// while(in_len){
    /// len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
    /// in_data, in_len,
    /// pts, dts, pos);
    /// in_data += len;
    /// in_len  -= len;
    ///
    /// if(size)
    /// decode_frame(data, size);
    /// }
    /// @endcode
    pub fn av_parser_parse2(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut libc::c_int,
        buf: *const u8,
        buf_size: libc::c_int,
        pts: i64,
        dts: i64,
        pos: i64,
    ) -> libc::c_int;
}
extern "C" {
    /// @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed
    /// @deprecated use AVBitStreamFilter
    pub fn av_parser_change(
        s: *mut AVCodecParserContext,
        avctx: *mut AVCodecContext,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut libc::c_int,
        buf: *const u8,
        buf_size: libc::c_int,
        keyframe: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_parser_close(s: *mut AVCodecParserContext);
}
extern "C" {
    /// Find a registered encoder with a matching codec ID.
    ///
    /// @param id AVCodecID of the requested encoder
    /// @return An encoder if one was found, NULL otherwise.
    pub fn avcodec_find_encoder(id: AVCodecID) -> *mut AVCodec;
}
extern "C" {
    /// Find a registered encoder with the specified name.
    ///
    /// @param name name of the requested encoder
    /// @return An encoder if one was found, NULL otherwise.
    pub fn avcodec_find_encoder_by_name(name: *const libc::c_char) -> *mut AVCodec;
}
extern "C" {
    /// Encode a frame of audio.
    ///
    /// Takes input samples from frame and writes the next output packet, if
    /// available, to avpkt. The output packet does not necessarily contain data for
    /// the most recent frame, as encoders can delay, split, and combine input frames
    /// internally as needed.
    ///
    /// @param avctx     codec context
    /// @param avpkt     output AVPacket.
    /// The user can supply an output buffer by setting
    /// avpkt->data and avpkt->size prior to calling the
    /// function, but if the size of the user-provided data is not
    /// large enough, encoding will fail. If avpkt->data and
    /// avpkt->size are set, avpkt->destruct must also be set. All
    /// other AVPacket fields will be reset by the encoder using
    /// av_init_packet(). If avpkt->data is NULL, the encoder will
    /// allocate it. The encoder will set avpkt->size to the size
    /// of the output packet.
    ///
    /// If this function fails or produces no output, avpkt will be
    /// freed using av_packet_unref().
    /// @param[in] frame AVFrame containing the raw audio data to be encoded.
    /// May be NULL when flushing an encoder that has the
    /// AV_CODEC_CAP_DELAY capability set.
    /// If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
    /// can have any number of samples.
    /// If it is not set, frame->nb_samples must be equal to
    /// avctx->frame_size for all frames except the last.
    /// The final frame may be smaller than avctx->frame_size.
    /// @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
    /// output packet is non-empty, and to 0 if it is
    /// empty. If the function returns an error, the
    /// packet can be assumed to be invalid, and the
    /// value of got_packet_ptr is undefined and should
    /// not be used.
    /// @return          0 on success, negative error code on failure
    ///
    /// @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead
    pub fn avcodec_encode_audio2(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
        frame: *const AVFrame,
        got_packet_ptr: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Encode a frame of video.
    ///
    /// Takes input raw video data from frame and writes the next output packet, if
    /// available, to avpkt. The output packet does not necessarily contain data for
    /// the most recent frame, as encoders can delay and reorder input frames
    /// internally as needed.
    ///
    /// @param avctx     codec context
    /// @param avpkt     output AVPacket.
    /// The user can supply an output buffer by setting
    /// avpkt->data and avpkt->size prior to calling the
    /// function, but if the size of the user-provided data is not
    /// large enough, encoding will fail. All other AVPacket fields
    /// will be reset by the encoder using av_init_packet(). If
    /// avpkt->data is NULL, the encoder will allocate it.
    /// The encoder will set avpkt->size to the size of the
    /// output packet. The returned data (if any) belongs to the
    /// caller, he is responsible for freeing it.
    ///
    /// If this function fails or produces no output, avpkt will be
    /// freed using av_packet_unref().
    /// @param[in] frame AVFrame containing the raw video data to be encoded.
    /// May be NULL when flushing an encoder that has the
    /// AV_CODEC_CAP_DELAY capability set.
    /// @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
    /// output packet is non-empty, and to 0 if it is
    /// empty. If the function returns an error, the
    /// packet can be assumed to be invalid, and the
    /// value of got_packet_ptr is undefined and should
    /// not be used.
    /// @return          0 on success, negative error code on failure
    ///
    /// @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead
    pub fn avcodec_encode_video2(
        avctx: *mut AVCodecContext,
        avpkt: *mut AVPacket,
        frame: *const AVFrame,
        got_packet_ptr: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avcodec_encode_subtitle(
        avctx: *mut AVCodecContext,
        buf: *mut u8,
        buf_size: libc::c_int,
        sub: *const AVSubtitle,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReSampleContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVResampleContext {
    _unused: [u8; 0],
}
extern "C" {
    /// Initialize audio resampling context.
    ///
    /// @param output_channels  number of output channels
    /// @param input_channels   number of input channels
    /// @param output_rate      output sample rate
    /// @param input_rate       input sample rate
    /// @param sample_fmt_out   requested output sample format
    /// @param sample_fmt_in    input sample format
    /// @param filter_length    length of each FIR filter in the filterbank relative to the cutoff frequency
    /// @param log2_phase_count log2 of the number of entries in the polyphase filterbank
    /// @param linear           if 1 then the used FIR filter will be linearly interpolated
    /// between the 2 closest, if 0 the closest will be used
    /// @param cutoff           cutoff frequency, 1.0 corresponds to half the output sampling rate
    /// @return allocated ReSampleContext, NULL if error occurred
    pub fn av_audio_resample_init(
        output_channels: libc::c_int,
        input_channels: libc::c_int,
        output_rate: libc::c_int,
        input_rate: libc::c_int,
        sample_fmt_out: AVSampleFormat,
        sample_fmt_in: AVSampleFormat,
        filter_length: libc::c_int,
        log2_phase_count: libc::c_int,
        linear: libc::c_int,
        cutoff: f64,
    ) -> *mut ReSampleContext;
}
extern "C" {
    pub fn audio_resample(
        s: *mut ReSampleContext,
        output: *mut libc::c_short,
        input: *mut libc::c_short,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Free resample context.
    ///
    /// @param s a non-NULL pointer to a resample context previously
    /// created with av_audio_resample_init()
    pub fn audio_resample_close(s: *mut ReSampleContext);
}
extern "C" {
    /// Initialize an audio resampler.
    /// Note, if either rate is not an integer then simply scale both rates up so they are.
    /// @param filter_length length of each FIR filter in the filterbank relative to the cutoff freq
    /// @param log2_phase_count log2 of the number of entries in the polyphase filterbank
    /// @param linear If 1 then the used FIR filter will be linearly interpolated
    /// between the 2 closest, if 0 the closest will be used
    /// @param cutoff cutoff frequency, 1.0 corresponds to half the output sampling rate
    pub fn av_resample_init(
        out_rate: libc::c_int,
        in_rate: libc::c_int,
        filter_length: libc::c_int,
        log2_phase_count: libc::c_int,
        linear: libc::c_int,
        cutoff: f64,
    ) -> *mut AVResampleContext;
}
extern "C" {
    /// Resample an array of samples using a previously configured context.
    /// @param src an array of unconsumed samples
    /// @param consumed the number of samples of src which have been consumed are returned here
    /// @param src_size the number of unconsumed samples available
    /// @param dst_size the amount of space in samples available in dst
    /// @param update_ctx If this is 0 then the context will not be modified, that way several channels can be resampled with the same context.
    /// @return the number of samples written in dst or -1 if an error occurred
    pub fn av_resample(
        c: *mut AVResampleContext,
        dst: *mut libc::c_short,
        src: *mut libc::c_short,
        consumed: *mut libc::c_int,
        src_size: libc::c_int,
        dst_size: libc::c_int,
        update_ctx: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Compensate samplerate/timestamp drift. The compensation is done by changing
    /// the resampler parameters, so no audible clicks or similar distortions occur
    /// @param compensation_distance distance in output samples over which the compensation should be performed
    /// @param sample_delta number of output samples which should be output less
    ///
    /// example: av_resample_compensate(c, 10, 500)
    /// here instead of 510 samples only 500 samples would be output
    ///
    /// note, due to rounding the actual compensation might be slightly different,
    /// especially if the compensation_distance is large and the in_rate used during init is small
    pub fn av_resample_compensate(
        c: *mut AVResampleContext,
        sample_delta: libc::c_int,
        compensation_distance: libc::c_int,
    );
}
extern "C" {
    pub fn av_resample_close(c: *mut AVResampleContext);
}
extern "C" {
    /// @deprecated unused
    pub fn avpicture_alloc(
        picture: *mut AVPicture,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @deprecated unused
    pub fn avpicture_free(picture: *mut AVPicture);
}
extern "C" {
    /// @deprecated use av_image_fill_arrays() instead.
    pub fn avpicture_fill(
        picture: *mut AVPicture,
        ptr: *const u8,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @deprecated use av_image_copy_to_buffer() instead.
    pub fn avpicture_layout(
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        dest: *mut libc::c_uchar,
        dest_size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @deprecated use av_image_get_buffer_size() instead.
    pub fn avpicture_get_size(
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @deprecated av_image_copy() instead.
    pub fn av_picture_copy(
        dst: *mut AVPicture,
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    );
}
extern "C" {
    /// @deprecated unused
    pub fn av_picture_crop(
        dst: *mut AVPicture,
        src: *const AVPicture,
        pix_fmt: AVPixelFormat,
        top_band: libc::c_int,
        left_band: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @deprecated unused
    pub fn av_picture_pad(
        dst: *mut AVPicture,
        src: *const AVPicture,
        height: libc::c_int,
        width: libc::c_int,
        pix_fmt: AVPixelFormat,
        padtop: libc::c_int,
        padbottom: libc::c_int,
        padleft: libc::c_int,
        padright: libc::c_int,
        color: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @deprecated Use av_pix_fmt_get_chroma_sub_sample
    pub fn avcodec_get_chroma_sub_sample(
        pix_fmt: AVPixelFormat,
        h_shift: *mut libc::c_int,
        v_shift: *mut libc::c_int,
    );
}
extern "C" {
    /// Return a value representing the fourCC code associated to the
    /// pixel format pix_fmt, or 0 if no associated fourCC code can be
    /// found.
    pub fn avcodec_pix_fmt_to_codec_tag(pix_fmt: AVPixelFormat) -> libc::c_uint;
}
extern "C" {
    /// @deprecated see av_get_pix_fmt_loss()
    pub fn avcodec_get_pix_fmt_loss(
        dst_pix_fmt: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Find the best pixel format to convert to given a certain source pixel
    /// format.  When converting from one pixel format to another, information loss
    /// may occur.  For example, when converting from RGB24 to GRAY, the color
    /// information will be lost. Similarly, other losses occur when converting from
    /// some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of
    /// the given pixel formats should be used to suffer the least amount of loss.
    /// The pixel formats from which it chooses one, are determined by the
    /// pix_fmt_list parameter.
    ///
    ///
    /// @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from
    /// @param[in] src_pix_fmt source pixel format
    /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
    /// @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.
    /// @return The best pixel format to convert to or -1 if none was found.
    pub fn avcodec_find_best_pix_fmt_of_list(
        pix_fmt_list: *const AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
        loss_ptr: *mut libc::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    /// @deprecated see av_find_best_pix_fmt_of_2()
    pub fn avcodec_find_best_pix_fmt_of_2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
        loss_ptr: *mut libc::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_find_best_pix_fmt2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
        loss_ptr: *mut libc::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    pub fn avcodec_default_get_format(
        s: *mut AVCodecContext,
        fmt: *const AVPixelFormat,
    ) -> AVPixelFormat;
}
extern "C" {
    /// @deprecated this function is not supposed to be used from outside of lavc
    pub fn avcodec_set_dimensions(s: *mut AVCodecContext, width: libc::c_int, height: libc::c_int);
}
extern "C" {
    /// Put a string representing the codec tag codec_tag in buf.
    ///
    /// @param buf       buffer to place codec tag in
    /// @param buf_size size in bytes of buf
    /// @param codec_tag codec tag to assign
    /// @return the length of the string that would have been generated if
    /// enough space had been available, excluding the trailing null
    ///
    /// @deprecated see av_fourcc_make_string() and av_fourcc2str().
    pub fn av_get_codec_tag_string(
        buf: *mut libc::c_char,
        buf_size: usize,
        codec_tag: libc::c_uint,
    ) -> usize;
}
extern "C" {
    pub fn avcodec_string(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        enc: *mut AVCodecContext,
        encode: libc::c_int,
    );
}
extern "C" {
    /// Return a name for the specified profile, if available.
    ///
    /// @param codec the codec that is searched for the given profile
    /// @param profile the profile value for which a name is requested
    /// @return A name for the profile if found, NULL otherwise.
    pub fn av_get_profile_name(codec: *const AVCodec, profile: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    /// Return a name for the specified profile, if available.
    ///
    /// @param codec_id the ID of the codec to which the requested profile belongs
    /// @param profile the profile value for which a name is requested
    /// @return A name for the profile if found, NULL otherwise.
    ///
    /// @note unlike av_get_profile_name(), which searches a list of profiles
    /// supported by a specific decoder or encoder implementation, this
    /// function searches the list of profiles from the AVCodecDescriptor
    pub fn avcodec_profile_name(codec_id: AVCodecID, profile: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    pub fn avcodec_default_execute(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(c2: *mut AVCodecContext, arg2: *mut libc::c_void) -> libc::c_int,
        >,
        arg: *mut libc::c_void,
        ret: *mut libc::c_int,
        count: libc::c_int,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avcodec_default_execute2(
        c: *mut AVCodecContext,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                c2: *mut AVCodecContext,
                arg2: *mut libc::c_void,
                arg1: libc::c_int,
                arg2: libc::c_int,
            ) -> libc::c_int,
        >,
        arg: *mut libc::c_void,
        ret: *mut libc::c_int,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Fill AVFrame audio data and linesize pointers.
    ///
    /// The buffer buf must be a preallocated buffer with a size big enough
    /// to contain the specified samples amount. The filled AVFrame data
    /// pointers will point to this buffer.
    ///
    /// AVFrame extended_data channel pointers are allocated if necessary for
    /// planar audio.
    ///
    /// @param frame       the AVFrame
    /// frame->nb_samples must be set prior to calling the
    /// function. This function fills in frame->data,
    /// frame->extended_data, frame->linesize[0].
    /// @param nb_channels channel count
    /// @param sample_fmt  sample format
    /// @param buf         buffer to use for frame data
    /// @param buf_size    size of buffer
    /// @param align       plane size sample alignment (0 = default)
    /// @return            >=0 on success, negative error code on failure
    /// @todo return the size in bytes required to store the samples in
    /// case of success, at the next libavutil bump
    pub fn avcodec_fill_audio_frame(
        frame: *mut AVFrame,
        nb_channels: libc::c_int,
        sample_fmt: AVSampleFormat,
        buf: *const u8,
        buf_size: libc::c_int,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Reset the internal decoder state / flush internal buffers. Should be called
    /// e.g. when seeking or when switching to a different stream.
    ///
    /// @note when refcounted frames are not used (i.e. avctx->refcounted_frames is 0),
    /// this invalidates the frames previously returned from the decoder. When
    /// refcounted frames are used, the decoder just releases any references it might
    /// keep internally, but the caller's reference remains valid.
    pub fn avcodec_flush_buffers(avctx: *mut AVCodecContext);
}
extern "C" {
    /// Return codec bits per sample.
    ///
    /// @param[in] codec_id the codec
    /// @return Number of bits per sample or zero if unknown for the given codec.
    pub fn av_get_bits_per_sample(codec_id: AVCodecID) -> libc::c_int;
}
extern "C" {
    /// Return the PCM codec associated with a sample format.
    /// @param be  endianness, 0 for little, 1 for big,
    /// -1 (or anything else) for native
    /// @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
    pub fn av_get_pcm_codec(fmt: AVSampleFormat, be: libc::c_int) -> AVCodecID;
}
extern "C" {
    /// Return codec bits per sample.
    /// Only return non-zero if the bits per sample is exactly correct, not an
    /// approximation.
    ///
    /// @param[in] codec_id the codec
    /// @return Number of bits per sample or zero if unknown for the given codec.
    pub fn av_get_exact_bits_per_sample(codec_id: AVCodecID) -> libc::c_int;
}
extern "C" {
    /// Return audio frame duration.
    ///
    /// @param avctx        codec context
    /// @param frame_bytes  size of the frame, or 0 if unknown
    /// @return             frame duration, in samples, if known. 0 if not able to
    /// determine.
    pub fn av_get_audio_frame_duration(
        avctx: *mut AVCodecContext,
        frame_bytes: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// This function is the same as av_get_audio_frame_duration(), except it works
    /// with AVCodecParameters instead of an AVCodecContext.
    pub fn av_get_audio_frame_duration2(
        par: *mut AVCodecParameters,
        frame_bytes: libc::c_int,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBitStreamFilterContext {
    pub priv_data: *mut libc::c_void,
    pub filter: *const AVBitStreamFilter,
    pub parser: *mut AVCodecParserContext,
    pub next: *mut AVBitStreamFilterContext,
    /// Internal default arguments, used if NULL is passed to av_bitstream_filter_filter().
    /// Not for access by library users.
    pub args: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_AVBitStreamFilterContext() {
    assert_eq!(
        ::std::mem::size_of::<AVBitStreamFilterContext>(),
        40usize,
        concat!("Size of: ", stringify!(AVBitStreamFilterContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBitStreamFilterContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBitStreamFilterContext))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBitStreamFilterContext>())).priv_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilterContext>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilterContext>())).parser as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilterContext>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilterContext>())).args as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilterContext),
            "::",
            stringify!(args)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFInternal {
    _unused: [u8; 0],
}
/// The bitstream filter state.
///
/// This struct must be allocated with av_bsf_alloc() and freed with
/// av_bsf_free().
///
/// The fields in the struct will only be changed (by the caller or by the
/// filter) as described in their documentation, and are to be considered
/// immutable otherwise.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBSFContext {
    /// A class for logging and AVOptions
    pub av_class: *const AVClass,
    /// The bitstream filter this context is an instance of.
    pub filter: *const AVBitStreamFilter,
    /// Opaque libavcodec internal data. Must not be touched by the caller in any
    /// way.
    pub internal: *mut AVBSFInternal,
    /// Opaque filter-specific private data. If filter->priv_class is non-NULL,
    /// this is an AVOptions-enabled struct.
    pub priv_data: *mut libc::c_void,
    /// Parameters of the input stream. This field is allocated in
    /// av_bsf_alloc(), it needs to be filled by the caller before
    /// av_bsf_init().
    pub par_in: *mut AVCodecParameters,
    /// Parameters of the output stream. This field is allocated in
    /// av_bsf_alloc(), it is set by the filter in av_bsf_init().
    pub par_out: *mut AVCodecParameters,
    /// The timebase used for the timestamps of the input packets. Set by the
    /// caller before av_bsf_init().
    pub time_base_in: AVRational,
    /// The timebase used for the timestamps of the output packets. Set by the
    /// filter in av_bsf_init().
    pub time_base_out: AVRational,
}
#[test]
fn bindgen_test_layout_AVBSFContext() {
    assert_eq!(
        ::std::mem::size_of::<AVBSFContext>(),
        64usize,
        concat!("Size of: ", stringify!(AVBSFContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBSFContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBSFContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).internal as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).priv_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).par_in as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(par_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).par_out as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(par_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).time_base_in as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(time_base_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBSFContext>())).time_base_out as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBSFContext),
            "::",
            stringify!(time_base_out)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBitStreamFilter {
    pub name: *const libc::c_char,
    /// A list of codec ids supported by the filter, terminated by
    /// AV_CODEC_ID_NONE.
    /// May be NULL, in that case the bitstream filter works with any codec id.
    pub codec_ids: *const AVCodecID,
    /// A class for the private data, used to declare bitstream filter private
    /// AVOptions. This field is NULL for bitstream filters that do not declare
    /// any options.
    ///
    /// If this field is non-NULL, the first member of the filter private data
    /// must be a pointer to AVClass, which will be set by libavcodec generic
    /// code to this class.
    pub priv_class: *const AVClass,
    /// No fields below this line are part of the public API. They
    /// may not be used outside of libavcodec and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub priv_data_size: libc::c_int,
    pub init: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVBSFContext) -> libc::c_int>,
    pub filter: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> libc::c_int,
    >,
    pub close: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVBSFContext)>,
}
#[test]
fn bindgen_test_layout_AVBitStreamFilter() {
    assert_eq!(
        ::std::mem::size_of::<AVBitStreamFilter>(),
        56usize,
        concat!("Size of: ", stringify!(AVBitStreamFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBitStreamFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBitStreamFilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).codec_ids as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(codec_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).priv_class as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBitStreamFilter>())).priv_data_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).init as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).filter as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBitStreamFilter>())).close as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBitStreamFilter),
            "::",
            stringify!(close)
        )
    );
}
extern "C" {
    /// Register a bitstream filter.
    ///
    /// The filter will be accessible to the application code through
    /// av_bitstream_filter_next() or can be directly initialized with
    /// av_bitstream_filter_init().
    ///
    /// @see avcodec_register_all()
    pub fn av_register_bitstream_filter(bsf: *mut AVBitStreamFilter);
}
extern "C" {
    /// Create and initialize a bitstream filter context given a bitstream
    /// filter name.
    ///
    /// The returned context must be freed with av_bitstream_filter_close().
    ///
    /// @param name    the name of the bitstream filter
    /// @return a bitstream filter context if a matching filter was found
    /// and successfully initialized, NULL otherwise
    pub fn av_bitstream_filter_init(name: *const libc::c_char) -> *mut AVBitStreamFilterContext;
}
extern "C" {
    /// Filter bitstream.
    ///
    /// This function filters the buffer buf with size buf_size, and places the
    /// filtered buffer in the buffer pointed to by poutbuf.
    ///
    /// The output buffer must be freed by the caller.
    ///
    /// @param bsfc            bitstream filter context created by av_bitstream_filter_init()
    /// @param avctx           AVCodecContext accessed by the filter, may be NULL.
    /// If specified, this must point to the encoder context of the
    /// output stream the packet is sent to.
    /// @param args            arguments which specify the filter configuration, may be NULL
    /// @param poutbuf         pointer which is updated to point to the filtered buffer
    /// @param poutbuf_size    pointer which is updated to the filtered buffer size in bytes
    /// @param buf             buffer containing the data to filter
    /// @param buf_size        size in bytes of buf
    /// @param keyframe        set to non-zero if the buffer to filter corresponds to a key-frame packet data
    /// @return >= 0 in case of success, or a negative error code in case of failure
    ///
    /// If the return value is positive, an output buffer is allocated and
    /// is available in *poutbuf, and is distinct from the input buffer.
    ///
    /// If the return value is 0, the output buffer is not allocated and
    /// should be considered identical to the input buffer, or in case
    /// *poutbuf was set it points to the input buffer (not necessarily to
    /// its starting address). A special case is if *poutbuf was set to NULL and
    /// *poutbuf_size was set to 0, which indicates the packet should be dropped.
    pub fn av_bitstream_filter_filter(
        bsfc: *mut AVBitStreamFilterContext,
        avctx: *mut AVCodecContext,
        args: *const libc::c_char,
        poutbuf: *mut *mut u8,
        poutbuf_size: *mut libc::c_int,
        buf: *const u8,
        buf_size: libc::c_int,
        keyframe: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Release bitstream filter context.
    ///
    /// @param bsf the bitstream filter context created with
    /// av_bitstream_filter_init(), can be NULL
    pub fn av_bitstream_filter_close(bsf: *mut AVBitStreamFilterContext);
}
extern "C" {
    /// If f is NULL, return the first registered bitstream filter,
    /// if f is non-NULL, return the next registered bitstream filter
    /// after f, or NULL if f is the last one.
    ///
    /// This function can be used to iterate over all registered bitstream
    /// filters.
    pub fn av_bitstream_filter_next(f: *const AVBitStreamFilter) -> *mut AVBitStreamFilter;
}
extern "C" {
    /// @return a bitstream filter with the specified name or NULL if no such
    /// bitstream filter exists.
    pub fn av_bsf_get_by_name(name: *const libc::c_char) -> *const AVBitStreamFilter;
}
extern "C" {
    /// Iterate over all registered bitstream filters.
    ///
    /// @param opaque a pointer where libavcodec will store the iteration state. Must
    /// point to NULL to start the iteration.
    ///
    /// @return the next registered bitstream filter or NULL when the iteration is
    /// finished
    pub fn av_bsf_next(opaque: *mut *mut libc::c_void) -> *const AVBitStreamFilter;
}
extern "C" {
    /// Allocate a context for a given bitstream filter. The caller must fill in the
    /// context parameters as described in the documentation and then call
    /// av_bsf_init() before sending any data to the filter.
    ///
    /// @param filter the filter for which to allocate an instance.
    /// @param ctx a pointer into which the pointer to the newly-allocated context
    /// will be written. It must be freed with av_bsf_free() after the
    /// filtering is done.
    ///
    /// @return 0 on success, a negative AVERROR code on failure
    pub fn av_bsf_alloc(
        filter: *const AVBitStreamFilter,
        ctx: *mut *mut AVBSFContext,
    ) -> libc::c_int;
}
extern "C" {
    /// Prepare the filter for use, after all the parameters and options have been
    /// set.
    pub fn av_bsf_init(ctx: *mut AVBSFContext) -> libc::c_int;
}
extern "C" {
    /// Submit a packet for filtering.
    ///
    /// After sending each packet, the filter must be completely drained by calling
    /// av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or
    /// AVERROR_EOF.
    ///
    /// @param pkt the packet to filter. The bitstream filter will take ownership of
    /// the packet and reset the contents of pkt. pkt is not touched if an error occurs.
    /// This parameter may be NULL, which signals the end of the stream (i.e. no more
    /// packets will be sent). That will cause the filter to output any packets it
    /// may have buffered internally.
    ///
    /// @return 0 on success, a negative AVERROR on error.
    pub fn av_bsf_send_packet(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    /// Retrieve a filtered packet.
    ///
    /// @param[out] pkt this struct will be filled with the contents of the filtered
    /// packet. It is owned by the caller and must be freed using
    /// av_packet_unref() when it is no longer needed.
    /// This parameter should be "clean" (i.e. freshly allocated
    /// with av_packet_alloc() or unreffed with av_packet_unref())
    /// when this function is called. If this function returns
    /// successfully, the contents of pkt will be completely
    /// overwritten by the returned data. On failure, pkt is not
    /// touched.
    ///
    /// @return 0 on success. AVERROR(EAGAIN) if more packets need to be sent to the
    /// filter (using av_bsf_send_packet()) to get more output. AVERROR_EOF if there
    /// will be no further output from the filter. Another negative AVERROR value if
    /// an error occurs.
    ///
    /// @note one input packet may result in several output packets, so after sending
    /// a packet with av_bsf_send_packet(), this function needs to be called
    /// repeatedly until it stops returning 0. It is also possible for a filter to
    /// output fewer packets than were sent to it, so this function may return
    /// AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.
    pub fn av_bsf_receive_packet(ctx: *mut AVBSFContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    /// Free a bitstream filter context and everything associated with it; write NULL
    /// into the supplied pointer.
    pub fn av_bsf_free(ctx: *mut *mut AVBSFContext);
}
extern "C" {
    /// Get the AVClass for AVBSFContext. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn av_bsf_get_class() -> *const AVClass;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVBSFList {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate empty list of bitstream filters.
    /// The list must be later freed by av_bsf_list_free()
    /// or finalized by av_bsf_list_finalize().
    ///
    /// @return Pointer to @ref AVBSFList on success, NULL in case of failure
    pub fn av_bsf_list_alloc() -> *mut AVBSFList;
}
extern "C" {
    /// Free list of bitstream filters.
    ///
    /// @param lst Pointer to pointer returned by av_bsf_list_alloc()
    pub fn av_bsf_list_free(lst: *mut *mut AVBSFList);
}
extern "C" {
    /// Append bitstream filter to the list of bitstream filters.
    ///
    /// @param lst List to append to
    /// @param bsf Filter context to be appended
    ///
    /// @return >=0 on success, negative AVERROR in case of failure
    pub fn av_bsf_list_append(lst: *mut AVBSFList, bsf: *mut AVBSFContext) -> libc::c_int;
}
extern "C" {
    /// Construct new bitstream filter context given it's name and options
    /// and append it to the list of bitstream filters.
    ///
    /// @param lst      List to append to
    /// @param bsf_name Name of the bitstream filter
    /// @param options  Options for the bitstream filter, can be set to NULL
    ///
    /// @return >=0 on success, negative AVERROR in case of failure
    pub fn av_bsf_list_append2(
        lst: *mut AVBSFList,
        bsf_name: *const libc::c_char,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    /// Finalize list of bitstream filters.
    ///
    /// This function will transform @ref AVBSFList to single @ref AVBSFContext,
    /// so the whole chain of bitstream filters can be treated as single filter
    /// freshly allocated by av_bsf_alloc().
    /// If the call is successful, @ref AVBSFList structure is freed and lst
    /// will be set to NULL. In case of failure, caller is responsible for
    /// freeing the structure by av_bsf_list_free()
    ///
    /// @param      lst Filter list structure to be transformed
    /// @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
    /// representing the chain of bitstream filters
    ///
    /// @return >=0 on success, negative AVERROR in case of failure
    pub fn av_bsf_list_finalize(
        lst: *mut *mut AVBSFList,
        bsf: *mut *mut AVBSFContext,
    ) -> libc::c_int;
}
extern "C" {
    /// Parse string describing list of bitstream filters and create single
    /// @ref AVBSFContext describing the whole chain of bitstream filters.
    /// Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly
    /// allocated by av_bsf_alloc().
    ///
    /// @param      str String describing chain of bitstream filters in format
    /// `bsf1[=opt1=val1:opt2=val2][,bsf2]`
    /// @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
    /// representing the chain of bitstream filters
    ///
    /// @return >=0 on success, negative AVERROR in case of failure
    pub fn av_bsf_list_parse_str(
        str: *const libc::c_char,
        bsf: *mut *mut AVBSFContext,
    ) -> libc::c_int;
}
extern "C" {
    /// Get null/pass-through bitstream filter.
    ///
    /// @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter
    ///
    /// @return
    pub fn av_bsf_get_null_filter(bsf: *mut *mut AVBSFContext) -> libc::c_int;
}
extern "C" {
    /// Same behaviour av_fast_malloc but the buffer has additional
    /// AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.
    ///
    /// In addition the whole buffer will initially and after resizes
    /// be 0-initialized so that no uninitialized data will ever appear.
    pub fn av_fast_padded_malloc(ptr: *mut libc::c_void, size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    /// Same behaviour av_fast_padded_malloc except that buffer will always
    /// be 0-initialized after call.
    pub fn av_fast_padded_mallocz(ptr: *mut libc::c_void, size: *mut libc::c_uint, min_size: usize);
}
extern "C" {
    /// Encode extradata length to a buffer. Used by xiph codecs.
    ///
    /// @param s buffer to write to; must be at least (v/255+1) bytes long
    /// @param v size of extradata in bytes
    /// @return number of bytes written to the buffer.
    pub fn av_xiphlacing(s: *mut libc::c_uchar, v: libc::c_uint) -> libc::c_uint;
}
extern "C" {
    /// Log a generic warning message about a missing feature. This function is
    /// intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)
    /// only, and would normally not be used by applications.
    /// @param[in] avc a pointer to an arbitrary struct of which the first field is
    /// a pointer to an AVClass struct
    /// @param[in] feature string containing the name of the missing feature
    /// @param[in] want_sample indicates if samples are wanted which exhibit this feature.
    /// If want_sample is non-zero, additional verbiage will be added to the log
    /// message which tells the user how to report samples to the development
    /// mailing list.
    /// @deprecated Use avpriv_report_missing_feature() instead.
    pub fn av_log_missing_feature(
        avc: *mut libc::c_void,
        feature: *const libc::c_char,
        want_sample: libc::c_int,
    );
}
extern "C" {
    /// Log a generic warning message asking for a sample. This function is
    /// intended to be used internally by FFmpeg (libavcodec, libavformat, etc.)
    /// only, and would normally not be used by applications.
    /// @param[in] avc a pointer to an arbitrary struct of which the first field is
    /// a pointer to an AVClass struct
    /// @param[in] msg string containing an optional message, or NULL if no message
    /// @deprecated Use avpriv_request_sample() instead.
    pub fn av_log_ask_for_sample(avc: *mut libc::c_void, msg: *const libc::c_char, ...);
}
extern "C" {
    /// Register the hardware accelerator hwaccel.
    pub fn av_register_hwaccel(hwaccel: *mut AVHWAccel);
}
extern "C" {
    /// If hwaccel is NULL, returns the first registered hardware accelerator,
    /// if hwaccel is non-NULL, returns the next registered hardware accelerator
    /// after hwaccel, or NULL if hwaccel is the last one.
    pub fn av_hwaccel_next(hwaccel: *const AVHWAccel) -> *mut AVHWAccel;
}
#[repr(u32)]
/// Lock operation used by lockmgr
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVLockOp {
    AV_LOCK_CREATE = 0,
    AV_LOCK_OBTAIN = 1,
    AV_LOCK_RELEASE = 2,
    AV_LOCK_DESTROY = 3,
}
extern "C" {
    /// Register a user provided lock manager supporting the operations
    /// specified by AVLockOp. The "mutex" argument to the function points
    /// to a (void *) where the lockmgr should store/get a pointer to a user
    /// allocated mutex. It is NULL upon AV_LOCK_CREATE and equal to the
    /// value left by the last call for all other ops. If the lock manager is
    /// unable to perform the op then it should leave the mutex in the same
    /// state as when it was called and return a non-zero value. However,
    /// when called with AV_LOCK_DESTROY the mutex will always be assumed to
    /// have been successfully destroyed. If av_lockmgr_register succeeds
    /// it will return a non-negative value, if it fails it will return a
    /// negative value and destroy all mutex and unregister all callbacks.
    /// av_lockmgr_register is not thread-safe, it must be called from a
    /// single thread before any calls which make use of locking are used.
    ///
    /// @param cb User defined callback. av_lockmgr_register invokes calls
    /// to this callback and the previously registered callback.
    /// The callback will be used to create more than one mutex
    /// each of which must be backed by its own underlying locking
    /// mechanism (i.e. do not use a single static object to
    /// implement your lock manager). If cb is set to NULL the
    /// lockmgr will be unregistered.
    pub fn av_lockmgr_register(
        cb: ::std::option::Option<
            unsafe extern "C" fn(mutex: *mut *mut libc::c_void, op: AVLockOp) -> libc::c_int,
        >,
    ) -> libc::c_int;
}
extern "C" {
    /// Get the type of the given codec.
    pub fn avcodec_get_type(codec_id: AVCodecID) -> AVMediaType;
}
extern "C" {
    /// Get the name of a codec.
    /// @return  a static string identifying the codec; never NULL
    pub fn avcodec_get_name(id: AVCodecID) -> *const libc::c_char;
}
extern "C" {
    /// @return a positive value if s is open (i.e. avcodec_open2() was called on it
    /// with no corresponding avcodec_close()), 0 otherwise.
    pub fn avcodec_is_open(s: *mut AVCodecContext) -> libc::c_int;
}
extern "C" {
    /// @return a non-zero number if codec is an encoder, zero otherwise
    pub fn av_codec_is_encoder(codec: *const AVCodec) -> libc::c_int;
}
extern "C" {
    /// @return a non-zero number if codec is a decoder, zero otherwise
    pub fn av_codec_is_decoder(codec: *const AVCodec) -> libc::c_int;
}
extern "C" {
    /// @return descriptor for given codec ID or NULL if no descriptor exists.
    pub fn avcodec_descriptor_get(id: AVCodecID) -> *const AVCodecDescriptor;
}
extern "C" {
    /// Iterate over all codec descriptors known to libavcodec.
    ///
    /// @param prev previous descriptor. NULL to get the first descriptor.
    ///
    /// @return next descriptor or NULL after the last descriptor
    pub fn avcodec_descriptor_next(prev: *const AVCodecDescriptor) -> *const AVCodecDescriptor;
}
extern "C" {
    /// @return codec descriptor with the given name or NULL if no such descriptor
    /// exists.
    pub fn avcodec_descriptor_get_by_name(name: *const libc::c_char) -> *const AVCodecDescriptor;
}
extern "C" {
    /// Allocate a CPB properties structure and initialize its fields to default
    /// values.
    ///
    /// @param size if non-NULL, the size of the allocated struct will be written
    /// here. This is useful for embedding it in side data.
    ///
    /// @return the newly allocated struct or NULL on failure
    pub fn av_cpb_properties_alloc(size: *mut usize) -> *mut AVCPBProperties;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDVProfile {
    pub dsf: libc::c_int,
    pub video_stype: libc::c_int,
    pub frame_size: libc::c_int,
    pub difseg_size: libc::c_int,
    pub n_difchan: libc::c_int,
    pub time_base: AVRational,
    pub ltc_divisor: libc::c_int,
    pub height: libc::c_int,
    pub width: libc::c_int,
    pub sar: [AVRational; 2usize],
    pub pix_fmt: AVPixelFormat,
    pub bpm: libc::c_int,
    pub block_sizes: *const u8,
    pub audio_stride: libc::c_int,
    pub audio_min_samples: [libc::c_int; 3usize],
    pub audio_samples_dist: [libc::c_int; 5usize],
    pub audio_shuffle: *const [libc::c_uchar; 9usize],
}
#[test]
fn bindgen_test_layout_AVDVProfile() {
    assert_eq!(
        ::std::mem::size_of::<AVDVProfile>(),
        120usize,
        concat!("Size of: ", stringify!(AVDVProfile))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDVProfile>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDVProfile))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).dsf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(dsf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).video_stype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(video_stype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).frame_size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(frame_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).difseg_size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(difseg_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).n_difchan as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(n_difchan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).time_base as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).ltc_divisor as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(ltc_divisor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).height as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).width as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).sar as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(sar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).pix_fmt as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(pix_fmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).bpm as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(bpm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).block_sizes as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(block_sizes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).audio_stride as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(audio_stride)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).audio_min_samples as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(audio_min_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).audio_samples_dist as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(audio_samples_dist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDVProfile>())).audio_shuffle as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDVProfile),
            "::",
            stringify!(audio_shuffle)
        )
    );
}
extern "C" {
    /// Get a DV profile for the provided compressed frame.
    ///
    /// @param sys the profile used for the previous frame, may be NULL
    /// @param frame the compressed data buffer
    /// @param buf_size size of the buffer in bytes
    /// @return the DV profile for the supplied data or NULL on failure
    pub fn av_dv_frame_profile(
        sys: *const AVDVProfile,
        frame: *const u8,
        buf_size: libc::c_uint,
    ) -> *const AVDVProfile;
}
extern "C" {
    /// Get a DV profile for the provided stream parameters.
    pub fn av_dv_codec_profile(
        width: libc::c_int,
        height: libc::c_int,
        pix_fmt: AVPixelFormat,
    ) -> *const AVDVProfile;
}
extern "C" {
    /// Get a DV profile for the provided stream parameters.
    /// The frame rate is used as a best-effort parameter.
    pub fn av_dv_codec_profile2(
        width: libc::c_int,
        height: libc::c_int,
        pix_fmt: AVPixelFormat,
        frame_rate: AVRational,
    ) -> *const AVDVProfile;
}
/// @defgroup lavc_fft FFT functions
/// @ingroup lavc_misc
///
/// @{
pub type FFTSample = f32;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct FFTComplex {
    pub re: FFTSample,
    pub im: FFTSample,
}
#[test]
fn bindgen_test_layout_FFTComplex() {
    assert_eq!(
        ::std::mem::size_of::<FFTComplex>(),
        8usize,
        concat!("Size of: ", stringify!(FFTComplex))
    );
    assert_eq!(
        ::std::mem::align_of::<FFTComplex>(),
        4usize,
        concat!("Alignment of ", stringify!(FFTComplex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FFTComplex>())).re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FFTComplex),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FFTComplex>())).im as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FFTComplex),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FFTContext {
    _unused: [u8; 0],
}
extern "C" {
    /// Set up a complex FFT.
    /// @param nbits           log2 of the length of the input array
    /// @param inverse         if 0 perform the forward transform, if 1 perform the inverse
    pub fn av_fft_init(nbits: libc::c_int, inverse: libc::c_int) -> *mut FFTContext;
}
extern "C" {
    /// Do the permutation needed BEFORE calling ff_fft_calc().
    pub fn av_fft_permute(s: *mut FFTContext, z: *mut FFTComplex);
}
extern "C" {
    /// Do a complex FFT with the parameters defined in av_fft_init(). The
    /// input data must be permuted before. No 1.0/sqrt(n) normalization is done.
    pub fn av_fft_calc(s: *mut FFTContext, z: *mut FFTComplex);
}
extern "C" {
    pub fn av_fft_end(s: *mut FFTContext);
}
extern "C" {
    pub fn av_mdct_init(nbits: libc::c_int, inverse: libc::c_int, scale: f64) -> *mut FFTContext;
}
extern "C" {
    pub fn av_imdct_calc(s: *mut FFTContext, output: *mut FFTSample, input: *const FFTSample);
}
extern "C" {
    pub fn av_imdct_half(s: *mut FFTContext, output: *mut FFTSample, input: *const FFTSample);
}
extern "C" {
    pub fn av_mdct_calc(s: *mut FFTContext, output: *mut FFTSample, input: *const FFTSample);
}
extern "C" {
    pub fn av_mdct_end(s: *mut FFTContext);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RDFTransformType {
    DFT_R2C = 0,
    IDFT_C2R = 1,
    IDFT_R2C = 2,
    DFT_C2R = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RDFTContext {
    _unused: [u8; 0],
}
extern "C" {
    /// Set up a real FFT.
    /// @param nbits           log2 of the length of the input array
    /// @param trans           the type of transform
    pub fn av_rdft_init(nbits: libc::c_int, trans: RDFTransformType) -> *mut RDFTContext;
}
extern "C" {
    pub fn av_rdft_calc(s: *mut RDFTContext, data: *mut FFTSample);
}
extern "C" {
    pub fn av_rdft_end(s: *mut RDFTContext);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DCTContext {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum DCTTransformType {
    DCT_II = 0,
    DCT_III = 1,
    DCT_I = 2,
    DST_I = 3,
}
extern "C" {
    /// Set up DCT.
    ///
    /// @param nbits           size of the input array:
    /// (1 << nbits)     for DCT-II, DCT-III and DST-I
    /// (1 << nbits) + 1 for DCT-I
    /// @param type            the type of transform
    ///
    /// @note the first element of the input of DST-I is ignored
    pub fn av_dct_init(nbits: libc::c_int, type_: DCTTransformType) -> *mut DCTContext;
}
extern "C" {
    pub fn av_dct_calc(s: *mut DCTContext, data: *mut FFTSample);
}
extern "C" {
    pub fn av_dct_end(s: *mut DCTContext);
}
/// This structure is used to share data between the FFmpeg library and
/// the client video application.
/// This shall be zero-allocated and available as
/// AVCodecContext.hwaccel_context. All user members can be set once
/// during initialization or through each AVCodecContext.get_buffer()
/// function call. In any case, they must be valid prior to calling
/// decoding functions.
///
/// Deprecated: use AVCodecContext.hw_frames_ctx instead.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct vaapi_context {
    /// Window system dependent data
    ///
    /// - encoding: unused
    /// - decoding: Set by user
    pub display: *mut libc::c_void,
    /// Configuration ID
    ///
    /// - encoding: unused
    /// - decoding: Set by user
    pub config_id: u32,
    /// Context ID (video decode pipeline)
    ///
    /// - encoding: unused
    /// - decoding: Set by user
    pub context_id: u32,
    /// VAPictureParameterBuffer ID
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec
    pub pic_param_buf_id: u32,
    /// VAIQMatrixBuffer ID
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec
    pub iq_matrix_buf_id: u32,
    /// VABitPlaneBuffer ID (for VC-1 decoding)
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec
    pub bitplane_buf_id: u32,
    /// Slice parameter/data buffer IDs
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec
    pub slice_buf_ids: *mut u32,
    /// Number of effective slice buffer IDs to send to the HW
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec
    pub n_slice_buf_ids: libc::c_uint,
    /// Size of pre-allocated slice_buf_ids
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec
    pub slice_buf_ids_alloc: libc::c_uint,
    /// Pointer to VASliceParameterBuffers
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec
    pub slice_params: *mut libc::c_void,
    /// Size of a VASliceParameterBuffer element
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec
    pub slice_param_size: libc::c_uint,
    /// Size of pre-allocated slice_params
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec
    pub slice_params_alloc: libc::c_uint,
    /// Number of slices currently filled in
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec
    pub slice_count: libc::c_uint,
    /// Pointer to slice data buffer base
    /// - encoding: unused
    /// - decoding: Set by libavcodec
    pub slice_data: *const u8,
    /// Current size of slice data
    ///
    /// - encoding: unused
    /// - decoding: Set by libavcodec
    pub slice_data_size: u32,
}
#[test]
fn bindgen_test_layout_vaapi_context() {
    assert_eq!(
        ::std::mem::size_of::<vaapi_context>(),
        88usize,
        concat!("Size of: ", stringify!(vaapi_context))
    );
    assert_eq!(
        ::std::mem::align_of::<vaapi_context>(),
        8usize,
        concat!("Alignment of ", stringify!(vaapi_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).display as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).config_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(config_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).context_id as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(context_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).pic_param_buf_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(pic_param_buf_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).iq_matrix_buf_id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(iq_matrix_buf_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).bitplane_buf_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(bitplane_buf_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).slice_buf_ids as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(slice_buf_ids)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).n_slice_buf_ids as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(n_slice_buf_ids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vaapi_context>())).slice_buf_ids_alloc as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(slice_buf_ids_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).slice_params as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(slice_params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).slice_param_size as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(slice_param_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vaapi_context>())).slice_params_alloc as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(slice_params_alloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).slice_count as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(slice_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).slice_data as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(slice_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vaapi_context>())).slice_data_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(vaapi_context),
            "::",
            stringify!(slice_data_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVVorbisParseContext {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate and initialize the Vorbis parser using headers in the extradata.
    pub fn av_vorbis_parse_init(
        extradata: *const u8,
        extradata_size: libc::c_int,
    ) -> *mut AVVorbisParseContext;
}
extern "C" {
    /// Free the parser and everything associated with it.
    pub fn av_vorbis_parse_free(s: *mut *mut AVVorbisParseContext);
}
extern "C" {
    /// Get the duration for a Vorbis packet.
    ///
    /// If @p flags is @c NULL,
    /// special frames are considered invalid.
    ///
    /// @param s        Vorbis parser context
    /// @param buf      buffer containing a Vorbis frame
    /// @param buf_size size of the buffer
    /// @param flags    flags for special frames
    pub fn av_vorbis_parse_frame_flags(
        s: *mut AVVorbisParseContext,
        buf: *const u8,
        buf_size: libc::c_int,
        flags: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Get the duration for a Vorbis packet.
    ///
    /// @param s        Vorbis parser context
    /// @param buf      buffer containing a Vorbis frame
    /// @param buf_size size of the buffer
    pub fn av_vorbis_parse_frame(
        s: *mut AVVorbisParseContext,
        buf: *const u8,
        buf_size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_vorbis_parse_reset(s: *mut AVVorbisParseContext);
}
#[repr(u32)]
/// @defgroup avoptions AVOptions
/// @ingroup lavu_data
/// @{
/// AVOptions provide a generic system to declare options on arbitrary structs
/// ("objects"). An option can have a help text, a type and a range of possible
/// values. Options may then be enumerated, read and written to.
///
/// @section avoptions_implement Implementing AVOptions
/// This section describes how to add AVOptions capabilities to a struct.
///
/// All AVOptions-related information is stored in an AVClass. Therefore
/// the first member of the struct should be a pointer to an AVClass describing it.
/// The option field of the AVClass must be set to a NULL-terminated static array
/// of AVOptions. Each AVOption must have a non-empty name, a type, a default
/// value and for number-type AVOptions also a range of allowed values. It must
/// also declare an offset in bytes from the start of the struct, where the field
/// associated with this AVOption is located. Other fields in the AVOption struct
/// should also be set when applicable, but are not required.
///
/// The following example illustrates an AVOptions-enabled struct:
/// @code
/// typedef struct test_struct {
/// const AVClass *class;
/// int      int_opt;
/// char    *str_opt;
/// uint8_t *bin_opt;
/// int      bin_len;
/// } test_struct;
///
/// static const AVOption test_options[] = {
/// { "test_int", "This is a test option of int type.", offsetof(test_struct, int_opt),
/// AV_OPT_TYPE_INT, { .i64 = -1 }, INT_MIN, INT_MAX },
/// { "test_str", "This is a test option of string type.", offsetof(test_struct, str_opt),
/// AV_OPT_TYPE_STRING },
/// { "test_bin", "This is a test option of binary type.", offsetof(test_struct, bin_opt),
/// AV_OPT_TYPE_BINARY },
/// { NULL },
/// };
///
/// static const AVClass test_class = {
/// .class_name = "test class",
/// .item_name  = av_default_item_name,
/// .option     = test_options,
/// .version    = LIBAVUTIL_VERSION_INT,
/// };
/// @endcode
///
/// Next, when allocating your struct, you must ensure that the AVClass pointer
/// is set to the correct value. Then, av_opt_set_defaults() can be called to
/// initialize defaults. After that the struct is ready to be used with the
/// AVOptions API.
///
/// When cleaning up, you may use the av_opt_free() function to automatically
/// free all the allocated string and binary options.
///
/// Continuing with the above example:
///
/// @code
/// test_struct *alloc_test_struct(void)
/// {
/// test_struct *ret = av_mallocz(sizeof(*ret));
/// ret->class = &test_class;
/// av_opt_set_defaults(ret);
/// return ret;
/// }
/// void free_test_struct(test_struct **foo)
/// {
/// av_opt_free(*foo);
/// av_freep(foo);
/// }
/// @endcode
///
/// @subsection avoptions_implement_nesting Nesting
/// It may happen that an AVOptions-enabled struct contains another
/// AVOptions-enabled struct as a member (e.g. AVCodecContext in
/// libavcodec exports generic options, while its priv_data field exports
/// codec-specific options). In such a case, it is possible to set up the
/// parent struct to export a child's options. To do that, simply
/// implement AVClass.child_next() and AVClass.child_class_next() in the
/// parent struct's AVClass.
/// Assuming that the test_struct from above now also contains a
/// child_struct field:
///
/// @code
/// typedef struct child_struct {
/// AVClass *class;
/// int flags_opt;
/// } child_struct;
/// static const AVOption child_opts[] = {
/// { "test_flags", "This is a test option of flags type.",
/// offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX },
/// { NULL },
/// };
/// static const AVClass child_class = {
/// .class_name = "child class",
/// .item_name  = av_default_item_name,
/// .option     = child_opts,
/// .version    = LIBAVUTIL_VERSION_INT,
/// };
///
/// void *child_next(void *obj, void *prev)
/// {
/// test_struct *t = obj;
/// if (!prev && t->child_struct)
/// return t->child_struct;
/// return NULL
/// }
/// const AVClass child_class_next(const AVClass *prev)
/// {
/// return prev ? NULL : &child_class;
/// }
/// @endcode
/// Putting child_next() and child_class_next() as defined above into
/// test_class will now make child_struct's options accessible through
/// test_struct (again, proper setup as described above needs to be done on
/// child_struct right after it is created).
///
/// From the above example it might not be clear why both child_next()
/// and child_class_next() are needed. The distinction is that child_next()
/// iterates over actually existing objects, while child_class_next()
/// iterates over all possible child classes. E.g. if an AVCodecContext
/// was initialized to use a codec which has private options, then its
/// child_next() will return AVCodecContext.priv_data and finish
/// iterating. OTOH child_class_next() on AVCodecContext.av_class will
/// iterate over all available codecs with private options.
///
/// @subsection avoptions_implement_named_constants Named constants
/// It is possible to create named constants for options. Simply set the unit
/// field of the option the constants should apply to a string and
/// create the constants themselves as options of type AV_OPT_TYPE_CONST
/// with their unit field set to the same string.
/// Their default_val field should contain the value of the named
/// constant.
/// For example, to add some named constants for the test_flags option
/// above, put the following into the child_opts array:
/// @code
/// { "test_flags", "This is a test option of flags type.",
/// offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX, "test_unit" },
/// { "flag1", "This is a flag with value 16", 0, AV_OPT_TYPE_CONST, { .i64 = 16 }, 0, 0, "test_unit" },
/// @endcode
///
/// @section avoptions_use Using AVOptions
/// This section deals with accessing options in an AVOptions-enabled struct.
/// Such structs in FFmpeg are e.g. AVCodecContext in libavcodec or
/// AVFormatContext in libavformat.
///
/// @subsection avoptions_use_examine Examining AVOptions
/// The basic functions for examining options are av_opt_next(), which iterates
/// over all options defined for one object, and av_opt_find(), which searches
/// for an option with the given name.
///
/// The situation is more complicated with nesting. An AVOptions-enabled struct
/// may have AVOptions-enabled children. Passing the AV_OPT_SEARCH_CHILDREN flag
/// to av_opt_find() will make the function search children recursively.
///
/// For enumerating there are basically two cases. The first is when you want to
/// get all options that may potentially exist on the struct and its children
/// (e.g.  when constructing documentation). In that case you should call
/// av_opt_child_class_next() recursively on the parent struct's AVClass.  The
/// second case is when you have an already initialized struct with all its
/// children and you want to get all options that can be actually written or read
/// from it. In that case you should call av_opt_child_next() recursively (and
/// av_opt_next() on each result).
///
/// @subsection avoptions_use_get_set Reading and writing AVOptions
/// When setting options, you often have a string read directly from the
/// user. In such a case, simply passing it to av_opt_set() is enough. For
/// non-string type options, av_opt_set() will parse the string according to the
/// option type.
///
/// Similarly av_opt_get() will read any option type and convert it to a string
/// which will be returned. Do not forget that the string is allocated, so you
/// have to free it with av_free().
///
/// In some cases it may be more convenient to put all options into an
/// AVDictionary and call av_opt_set_dict() on it. A specific case of this
/// are the format/codec open functions in lavf/lavc which take a dictionary
/// filled with option as a parameter. This makes it possible to set some options
/// that cannot be set otherwise, since e.g. the input file format is not known
/// before the file is actually opened.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVOptionType {
    AV_OPT_TYPE_FLAGS = 0,
    AV_OPT_TYPE_INT = 1,
    AV_OPT_TYPE_INT64 = 2,
    AV_OPT_TYPE_DOUBLE = 3,
    AV_OPT_TYPE_FLOAT = 4,
    AV_OPT_TYPE_STRING = 5,
    AV_OPT_TYPE_RATIONAL = 6,
    AV_OPT_TYPE_BINARY = 7,
    AV_OPT_TYPE_DICT = 8,
    AV_OPT_TYPE_UINT64 = 9,
    AV_OPT_TYPE_CONST = 128,
    AV_OPT_TYPE_IMAGE_SIZE = 1397316165,
    AV_OPT_TYPE_PIXEL_FMT = 1346784596,
    AV_OPT_TYPE_SAMPLE_FMT = 1397116244,
    AV_OPT_TYPE_VIDEO_RATE = 1448231252,
    AV_OPT_TYPE_DURATION = 1146442272,
    AV_OPT_TYPE_COLOR = 1129270354,
    AV_OPT_TYPE_CHANNEL_LAYOUT = 1128811585,
    AV_OPT_TYPE_BOOL = 1112493900,
}
/// AVOption
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVOption {
    pub name: *const libc::c_char,
    /// short English help text
    /// @todo What about other languages?
    pub help: *const libc::c_char,
    /// The offset relative to the context structure where the option
    /// value is stored. It should be 0 for named constants.
    pub offset: libc::c_int,
    pub type_: AVOptionType,
    pub default_val: AVOption__bindgen_ty_1,
    /// < minimum valid value for the option
    pub min: f64,
    /// < maximum valid value for the option
    pub max: f64,
    pub flags: libc::c_int,
    /// The logical unit to which the option belongs. Non-constant
    /// options and corresponding named constants share the same
    /// unit. May be NULL.
    pub unit: *const libc::c_char,
}
/// the default value for scalar options
#[repr(C)]
#[derive(Copy, Clone)]
pub union AVOption__bindgen_ty_1 {
    pub i64: i64,
    pub dbl: f64,
    pub str: *const libc::c_char,
    pub q: AVRational,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_AVOption__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<AVOption__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(AVOption__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOption__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOption__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption__bindgen_ty_1>())).i64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(i64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption__bindgen_ty_1>())).dbl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(dbl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption__bindgen_ty_1>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption__bindgen_ty_1>())).q as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption__bindgen_ty_1),
            "::",
            stringify!(q)
        )
    );
}
#[test]
fn bindgen_test_layout_AVOption() {
    assert_eq!(
        ::std::mem::size_of::<AVOption>(),
        64usize,
        concat!("Size of: ", stringify!(AVOption))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOption>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOption))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).help as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(help)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).type_ as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).default_val as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(default_val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).min as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).max as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOption>())).unit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOption),
            "::",
            stringify!(unit)
        )
    );
}
/// A single allowed range of values, or a single allowed value.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct AVOptionRange {
    pub str: *const libc::c_char,
    /// Value range.
    /// For string ranges this represents the min/max length.
    /// For dimensions this represents the min/max pixel count or width/height in multi-component case.
    pub value_min: f64,
    /// Value range.
    /// For string ranges this represents the min/max length.
    /// For dimensions this represents the min/max pixel count or width/height in multi-component case.
    pub value_max: f64,
    /// Value's component range.
    /// For string this represents the unicode range for chars, 0-127 limits to ASCII.
    pub component_min: f64,
    /// Value's component range.
    /// For string this represents the unicode range for chars, 0-127 limits to ASCII.
    pub component_max: f64,
    /// Range flag.
    /// If set to 1 the struct encodes a range, if set to 0 a single value.
    pub is_range: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVOptionRange() {
    assert_eq!(
        ::std::mem::size_of::<AVOptionRange>(),
        48usize,
        concat!("Size of: ", stringify!(AVOptionRange))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOptionRange>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOptionRange))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRange>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRange>())).value_min as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(value_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRange>())).value_max as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(value_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRange>())).component_min as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(component_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRange>())).component_max as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(component_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRange>())).is_range as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRange),
            "::",
            stringify!(is_range)
        )
    );
}
/// List of AVOptionRange structs.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVOptionRanges {
    /// Array of option ranges.
    ///
    /// Most of option types use just one component.
    /// Following describes multi-component option types:
    ///
    /// AV_OPT_TYPE_IMAGE_SIZE:
    /// component index 0: range of pixel count (width * height).
    /// component index 1: range of width.
    /// component index 2: range of height.
    ///
    /// @note To obtain multi-component version of this structure, user must
    /// provide AV_OPT_MULTI_COMPONENT_RANGE to av_opt_query_ranges or
    /// av_opt_query_ranges_default function.
    ///
    /// Multi-component range can be read as in following example:
    ///
    /// @code
    /// int range_index, component_index;
    /// AVOptionRanges *ranges;
    /// AVOptionRange *range[3]; //may require more than 3 in the future.
    /// av_opt_query_ranges(&ranges, obj, key, AV_OPT_MULTI_COMPONENT_RANGE);
    /// for (range_index = 0; range_index < ranges->nb_ranges; range_index++) {
    /// for (component_index = 0; component_index < ranges->nb_components; component_index++)
    /// range[component_index] = ranges->range[ranges->nb_ranges * component_index + range_index];
    /// //do something with range here.
    /// }
    /// av_opt_freep_ranges(&ranges);
    /// @endcode
    pub range: *mut *mut AVOptionRange,
    /// Number of ranges per component.
    pub nb_ranges: libc::c_int,
    /// Number of componentes.
    pub nb_components: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVOptionRanges() {
    assert_eq!(
        ::std::mem::size_of::<AVOptionRanges>(),
        16usize,
        concat!("Size of: ", stringify!(AVOptionRanges))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOptionRanges>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOptionRanges))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRanges>())).range as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRanges),
            "::",
            stringify!(range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRanges>())).nb_ranges as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRanges),
            "::",
            stringify!(nb_ranges)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOptionRanges>())).nb_components as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOptionRanges),
            "::",
            stringify!(nb_components)
        )
    );
}
extern "C" {
    /// Show the obj options.
    ///
    /// @param req_flags requested flags for the options to show. Show only the
    /// options for which it is opt->flags & req_flags.
    /// @param rej_flags rejected flags for the options to show. Show only the
    /// options for which it is !(opt->flags & req_flags).
    /// @param av_log_obj log context to use for showing the options
    pub fn av_opt_show2(
        obj: *mut libc::c_void,
        av_log_obj: *mut libc::c_void,
        req_flags: libc::c_int,
        rej_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Set the values of all AVOption fields to their default values.
    ///
    /// @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)
    pub fn av_opt_set_defaults(s: *mut libc::c_void);
}
extern "C" {
    /// Set the values of all AVOption fields to their default values. Only these
    /// AVOption fields for which (opt->flags & mask) == flags will have their
    /// default applied to s.
    ///
    /// @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)
    /// @param mask combination of AV_OPT_FLAG_*
    /// @param flags combination of AV_OPT_FLAG_*
    pub fn av_opt_set_defaults2(s: *mut libc::c_void, mask: libc::c_int, flags: libc::c_int);
}
extern "C" {
    /// Parse the key/value pairs list in opts. For each key/value pair
    /// found, stores the value in the field in ctx that is named like the
    /// key. ctx must be an AVClass context, storing is done using
    /// AVOptions.
    ///
    /// @param opts options string to parse, may be NULL
    /// @param key_val_sep a 0-terminated list of characters used to
    /// separate key from value
    /// @param pairs_sep a 0-terminated list of characters used to separate
    /// two pairs from each other
    /// @return the number of successfully set key/value pairs, or a negative
    /// value corresponding to an AVERROR code in case of error:
    /// AVERROR(EINVAL) if opts cannot be parsed,
    /// the error code issued by av_opt_set() if a key/value pair
    /// cannot be set
    pub fn av_set_options_string(
        ctx: *mut libc::c_void,
        opts: *const libc::c_char,
        key_val_sep: *const libc::c_char,
        pairs_sep: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    /// Parse the key-value pairs list in opts. For each key=value pair found,
    /// set the value of the corresponding option in ctx.
    ///
    /// @param ctx          the AVClass object to set options on
    /// @param opts         the options string, key-value pairs separated by a
    /// delimiter
    /// @param shorthand    a NULL-terminated array of options names for shorthand
    /// notation: if the first field in opts has no key part,
    /// the key is taken from the first element of shorthand;
    /// then again for the second, etc., until either opts is
    /// finished, shorthand is finished or a named option is
    /// found; after that, all options must be named
    /// @param key_val_sep  a 0-terminated list of characters used to separate
    /// key from value, for example '='
    /// @param pairs_sep    a 0-terminated list of characters used to separate
    /// two pairs from each other, for example ':' or ','
    /// @return  the number of successfully set key=value pairs, or a negative
    /// value corresponding to an AVERROR code in case of error:
    /// AVERROR(EINVAL) if opts cannot be parsed,
    /// the error code issued by av_set_string3() if a key/value pair
    /// cannot be set
    ///
    /// Options names must use only the following characters: a-z A-Z 0-9 - . / _
    /// Separators must use characters distinct from option names and from each
    /// other.
    pub fn av_opt_set_from_string(
        ctx: *mut libc::c_void,
        opts: *const libc::c_char,
        shorthand: *const *const libc::c_char,
        key_val_sep: *const libc::c_char,
        pairs_sep: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    /// Free all allocated objects in obj.
    pub fn av_opt_free(obj: *mut libc::c_void);
}
extern "C" {
    /// Check whether a particular flag is set in a flags field.
    ///
    /// @param field_name the name of the flag field option
    /// @param flag_name the name of the flag to check
    /// @return non-zero if the flag is set, zero if the flag isn't set,
    /// isn't of the right type, or the flags field doesn't exist.
    pub fn av_opt_flag_is_set(
        obj: *mut libc::c_void,
        field_name: *const libc::c_char,
        flag_name: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    /// Set all the options from a given dictionary on an object.
    ///
    /// @param obj a struct whose first element is a pointer to AVClass
    /// @param options options to process. This dictionary will be freed and replaced
    /// by a new one containing all options not found in obj.
    /// Of course this new dictionary needs to be freed by caller
    /// with av_dict_free().
    ///
    /// @return 0 on success, a negative AVERROR if some option was found in obj,
    /// but could not be set.
    ///
    /// @see av_dict_copy()
    pub fn av_opt_set_dict(obj: *mut libc::c_void, options: *mut *mut AVDictionary) -> libc::c_int;
}
extern "C" {
    /// Set all the options from a given dictionary on an object.
    ///
    /// @param obj a struct whose first element is a pointer to AVClass
    /// @param options options to process. This dictionary will be freed and replaced
    /// by a new one containing all options not found in obj.
    /// Of course this new dictionary needs to be freed by caller
    /// with av_dict_free().
    /// @param search_flags A combination of AV_OPT_SEARCH_*.
    ///
    /// @return 0 on success, a negative AVERROR if some option was found in obj,
    /// but could not be set.
    ///
    /// @see av_dict_copy()
    pub fn av_opt_set_dict2(
        obj: *mut libc::c_void,
        options: *mut *mut AVDictionary,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Extract a key-value pair from the beginning of a string.
    ///
    /// @param ropts        pointer to the options string, will be updated to
    /// point to the rest of the string (one of the pairs_sep
    /// or the final NUL)
    /// @param key_val_sep  a 0-terminated list of characters used to separate
    /// key from value, for example '='
    /// @param pairs_sep    a 0-terminated list of characters used to separate
    /// two pairs from each other, for example ':' or ','
    /// @param flags        flags; see the AV_OPT_FLAG_* values below
    /// @param rkey         parsed key; must be freed using av_free()
    /// @param rval         parsed value; must be freed using av_free()
    ///
    /// @return  >=0 for success, or a negative value corresponding to an
    /// AVERROR code in case of error; in particular:
    /// AVERROR(EINVAL) if no key is present
    ///
    pub fn av_opt_get_key_value(
        ropts: *mut *const libc::c_char,
        key_val_sep: *const libc::c_char,
        pairs_sep: *const libc::c_char,
        flags: libc::c_uint,
        rkey: *mut *mut libc::c_char,
        rval: *mut *mut libc::c_char,
    ) -> libc::c_int;
}
pub const AV_OPT_FLAG_IMPLICIT_KEY: _bindgen_ty_2 = _bindgen_ty_2::AV_OPT_FLAG_IMPLICIT_KEY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_2 {
    AV_OPT_FLAG_IMPLICIT_KEY = 1,
}
extern "C" {
    /// @defgroup opt_eval_funcs Evaluating option strings
    /// @{
    /// This group of functions can be used to evaluate option strings
    /// and get numbers out of them. They do the same thing as av_opt_set(),
    /// except the result is written into the caller-supplied pointer.
    ///
    /// @param obj a struct whose first element is a pointer to AVClass.
    /// @param o an option for which the string is to be evaluated.
    /// @param val string to be evaluated.
    /// @param *_out value of the string will be written here.
    ///
    /// @return 0 on success, a negative number on failure.
    pub fn av_opt_eval_flags(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        flags_out: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_int(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        int_out: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_int64(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        int64_out: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_float(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        float_out: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_double(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        double_out: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_eval_q(
        obj: *mut libc::c_void,
        o: *const AVOption,
        val: *const libc::c_char,
        q_out: *mut AVRational,
    ) -> libc::c_int;
}
extern "C" {
    /// Look for an option in an object. Consider only options which
    /// have all the specified flags set.
    ///
    /// @param[in] obj A pointer to a struct whose first element is a
    /// pointer to an AVClass.
    /// Alternatively a double pointer to an AVClass, if
    /// AV_OPT_SEARCH_FAKE_OBJ search flag is set.
    /// @param[in] name The name of the option to look for.
    /// @param[in] unit When searching for named constants, name of the unit
    /// it belongs to.
    /// @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).
    /// @param search_flags A combination of AV_OPT_SEARCH_*.
    ///
    /// @return A pointer to the option found, or NULL if no option
    /// was found.
    ///
    /// @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable
    /// directly with av_opt_set(). Use special calls which take an options
    /// AVDictionary (e.g. avformat_open_input()) to set options found with this
    /// flag.
    pub fn av_opt_find(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        unit: *const libc::c_char,
        opt_flags: libc::c_int,
        search_flags: libc::c_int,
    ) -> *const AVOption;
}
extern "C" {
    /// Look for an option in an object. Consider only options which
    /// have all the specified flags set.
    ///
    /// @param[in] obj A pointer to a struct whose first element is a
    /// pointer to an AVClass.
    /// Alternatively a double pointer to an AVClass, if
    /// AV_OPT_SEARCH_FAKE_OBJ search flag is set.
    /// @param[in] name The name of the option to look for.
    /// @param[in] unit When searching for named constants, name of the unit
    /// it belongs to.
    /// @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).
    /// @param search_flags A combination of AV_OPT_SEARCH_*.
    /// @param[out] target_obj if non-NULL, an object to which the option belongs will be
    /// written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present
    /// in search_flags. This parameter is ignored if search_flags contain
    /// AV_OPT_SEARCH_FAKE_OBJ.
    ///
    /// @return A pointer to the option found, or NULL if no option
    /// was found.
    pub fn av_opt_find2(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        unit: *const libc::c_char,
        opt_flags: libc::c_int,
        search_flags: libc::c_int,
        target_obj: *mut *mut libc::c_void,
    ) -> *const AVOption;
}
extern "C" {
    /// Iterate over all AVOptions belonging to obj.
    ///
    /// @param obj an AVOptions-enabled struct or a double pointer to an
    /// AVClass describing it.
    /// @param prev result of the previous call to av_opt_next() on this object
    /// or NULL
    /// @return next AVOption or NULL
    pub fn av_opt_next(obj: *const libc::c_void, prev: *const AVOption) -> *const AVOption;
}
extern "C" {
    /// Iterate over AVOptions-enabled children of obj.
    ///
    /// @param prev result of a previous call to this function or NULL
    /// @return next AVOptions-enabled child or NULL
    pub fn av_opt_child_next(obj: *mut libc::c_void, prev: *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    /// Iterate over potential AVOptions-enabled children of parent.
    ///
    /// @param prev result of a previous call to this function or NULL
    /// @return AVClass corresponding to next potential child or NULL
    pub fn av_opt_child_class_next(parent: *const AVClass, prev: *const AVClass) -> *const AVClass;
}
extern "C" {
    /// @defgroup opt_set_funcs Option setting functions
    /// @{
    /// Those functions set the field of obj with the given name to value.
    ///
    /// @param[in] obj A struct whose first element is a pointer to an AVClass.
    /// @param[in] name the name of the field to set
    /// @param[in] val The value to set. In case of av_opt_set() if the field is not
    /// of a string type, then the given string is parsed.
    /// SI postfixes and some named scalars are supported.
    /// If the field is of a numeric type, it has to be a numeric or named
    /// scalar. Behavior with more than one scalar and +- infix operators
    /// is undefined.
    /// If the field is of a flags type, it has to be a sequence of numeric
    /// scalars or named flags separated by '+' or '-'. Prefixing a flag
    /// with '+' causes it to be set without affecting the other flags;
    /// similarly, '-' unsets a flag.
    /// @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN
    /// is passed here, then the option may be set on a child of obj.
    ///
    /// @return 0 if the value has been set, or an AVERROR code in case of
    /// error:
    /// AVERROR_OPTION_NOT_FOUND if no matching option exists
    /// AVERROR(ERANGE) if the value is out of range
    /// AVERROR(EINVAL) if the value is not valid
    pub fn av_opt_set(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: *const libc::c_char,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_int(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: i64,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_double(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: f64,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_q(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: AVRational,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_bin(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: *const u8,
        size: libc::c_int,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_image_size(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        w: libc::c_int,
        h: libc::c_int,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_pixel_fmt(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        fmt: AVPixelFormat,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_sample_fmt(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        fmt: AVSampleFormat,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_video_rate(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: AVRational,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_set_channel_layout(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        ch_layout: i64,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @note Any old dictionary present is discarded and replaced with a copy of the new one. The
    /// caller still owns val is and responsible for freeing it.
    pub fn av_opt_set_dict_val(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        val: *const AVDictionary,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @defgroup opt_get_funcs Option getting functions
    /// @{
    /// Those functions get a value of the option with the given name from an object.
    ///
    /// @param[in] obj a struct whose first element is a pointer to an AVClass.
    /// @param[in] name name of the option to get.
    /// @param[in] search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN
    /// is passed here, then the option may be found in a child of obj.
    /// @param[out] out_val value of the option will be written here
    /// @return >=0 on success, a negative error code otherwise
    /// /
    /// /**
    /// @note the returned string will be av_malloc()ed and must be av_free()ed by the caller
    ///
    /// @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the option has
    /// AV_OPT_TYPE_STRING or AV_OPT_TYPE_BINARY and is set to NULL, *out_val will be set
    /// to NULL instead of an allocated empty string.
    pub fn av_opt_get(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut *mut u8,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_int(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_double(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_q(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut AVRational,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_image_size(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        w_out: *mut libc::c_int,
        h_out: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_pixel_fmt(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_fmt: *mut AVPixelFormat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_sample_fmt(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_fmt: *mut AVSampleFormat,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_video_rate(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut AVRational,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_opt_get_channel_layout(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        ch_layout: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    /// @param[out] out_val The returned dictionary is a copy of the actual value and must
    /// be freed with av_dict_free() by the caller
    pub fn av_opt_get_dict_val(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
        out_val: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    /// @}
    /// /
    /// /**
    /// Gets a pointer to the requested field in a struct.
    /// This function allows accessing a struct even when its fields are moved or
    /// renamed since the application making the access has been compiled,
    ///
    /// @returns a pointer to the field, it can be cast to the correct type and read
    /// or written to.
    pub fn av_opt_ptr(
        avclass: *const AVClass,
        obj: *mut libc::c_void,
        name: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    /// Free an AVOptionRanges struct and set it to NULL.
    pub fn av_opt_freep_ranges(ranges: *mut *mut AVOptionRanges);
}
extern "C" {
    /// Get a list of allowed ranges for the given option.
    ///
    /// The returned list may depend on other fields in obj like for example profile.
    ///
    /// @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
    /// AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
    /// AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
    ///
    /// The result must be freed with av_opt_freep_ranges.
    ///
    /// @return number of compontents returned on success, a negative errro code otherwise
    pub fn av_opt_query_ranges(
        arg1: *mut *mut AVOptionRanges,
        obj: *mut libc::c_void,
        key: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Copy options from src object into dest object.
    ///
    /// Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.
    /// Original memory allocated for such options is freed unless both src and dest options points to the same memory.
    ///
    /// @param dest Object to copy from
    /// @param src  Object to copy into
    /// @return 0 on success, negative on error
    pub fn av_opt_copy(dest: *mut libc::c_void, src: *const libc::c_void) -> libc::c_int;
}
extern "C" {
    /// Get a default list of allowed ranges for the given option.
    ///
    /// This list is constructed without using the AVClass.query_ranges() callback
    /// and can be used as fallback from within the callback.
    ///
    /// @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
    /// AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
    /// AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
    ///
    /// The result must be freed with av_opt_free_ranges.
    ///
    /// @return number of compontents returned on success, a negative errro code otherwise
    pub fn av_opt_query_ranges_default(
        arg1: *mut *mut AVOptionRanges,
        obj: *mut libc::c_void,
        key: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Check if given option is set to its default value.
    ///
    /// Options o must belong to the obj. This function must not be called to check child's options state.
    /// @see av_opt_is_set_to_default_by_name().
    ///
    /// @param obj  AVClass object to check option on
    /// @param o    option to be checked
    /// @return     >0 when option is set to its default,
    /// 0 when option is not set its default,
    /// <0 on error
    pub fn av_opt_is_set_to_default(obj: *mut libc::c_void, o: *const AVOption) -> libc::c_int;
}
extern "C" {
    /// Check if given option is set to its default value.
    ///
    /// @param obj          AVClass object to check option on
    /// @param name         option name
    /// @param search_flags combination of AV_OPT_SEARCH_*
    /// @return             >0 when option is set to its default,
    /// 0 when option is not set its default,
    /// <0 on error
    pub fn av_opt_is_set_to_default_by_name(
        obj: *mut libc::c_void,
        name: *const libc::c_char,
        search_flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Serialize object's options.
    ///
    /// Create a string containing object's serialized options.
    /// Such string may be passed back to av_opt_set_from_string() in order to restore option values.
    /// A key/value or pairs separator occurring in the serialized value or
    /// name string are escaped through the av_escape() function.
    ///
    /// @param[in]  obj           AVClass object to serialize
    /// @param[in]  opt_flags     serialize options with all the specified flags set (AV_OPT_FLAG)
    /// @param[in]  flags         combination of AV_OPT_SERIALIZE_* flags
    /// @param[out] buffer        Pointer to buffer that will be allocated with string containg serialized options.
    /// Buffer must be freed by the caller when is no longer needed.
    /// @param[in]  key_val_sep   character used to separate key from value
    /// @param[in]  pairs_sep     character used to separate two pairs from each other
    /// @return                   >= 0 on success, negative on error
    /// @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.
    pub fn av_opt_serialize(
        obj: *mut libc::c_void,
        opt_flags: libc::c_int,
        flags: libc::c_int,
        buffer: *mut *mut libc::c_char,
        key_val_sep: libc::c_char,
        pairs_sep: libc::c_char,
    ) -> libc::c_int;
}
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: __darwin_time_t,
    pub tv_nsec: libc::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct tm {
    pub tm_sec: libc::c_int,
    pub tm_min: libc::c_int,
    pub tm_hour: libc::c_int,
    pub tm_mday: libc::c_int,
    pub tm_mon: libc::c_int,
    pub tm_year: libc::c_int,
    pub tm_wday: libc::c_int,
    pub tm_yday: libc::c_int,
    pub tm_isdst: libc::c_int,
    pub tm_gmtoff: libc::c_long,
    pub tm_zone: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
extern "C" {
    pub static mut tzname: [*mut libc::c_char; 0usize];
}
extern "C" {
    pub static mut getdate_err: libc::c_int;
}
extern "C" {
    pub static mut timezone: libc::c_long;
}
extern "C" {
    pub static mut daylight: libc::c_int;
}
extern "C" {
    pub fn asctime(arg1: *const tm) -> *mut libc::c_char;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn ctime(arg1: *const time_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn difftime(arg1: time_t, arg2: time_t) -> f64;
}
extern "C" {
    pub fn getdate(arg1: *const libc::c_char) -> *mut tm;
}
extern "C" {
    pub fn gmtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(arg1: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn mktime(arg1: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        arg1: *mut libc::c_char,
        arg2: usize,
        arg3: *const libc::c_char,
        arg4: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strptime(
        arg1: *const libc::c_char,
        arg2: *const libc::c_char,
        arg3: *mut tm,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn time(arg1: *mut time_t) -> time_t;
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub fn asctime_r(arg1: *const tm, arg2: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn ctime_r(arg1: *const time_t, arg2: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn gmtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(arg1: *const time_t, arg2: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn posix2time(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn tzsetwall();
}
extern "C" {
    pub fn time2posix(arg1: time_t) -> time_t;
}
extern "C" {
    pub fn timelocal(arg1: *const tm) -> time_t;
}
extern "C" {
    pub fn timegm(arg1: *const tm) -> time_t;
}
extern "C" {
    pub fn nanosleep(__rqtp: *const timespec, __rmtp: *mut timespec) -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum clockid_t {
    _CLOCK_REALTIME = 0,
    _CLOCK_MONOTONIC = 6,
    _CLOCK_MONOTONIC_RAW = 4,
    _CLOCK_MONOTONIC_RAW_APPROX = 5,
    _CLOCK_UPTIME_RAW = 8,
    _CLOCK_UPTIME_RAW_APPROX = 9,
    _CLOCK_PROCESS_CPUTIME_ID = 12,
    _CLOCK_THREAD_CPUTIME_ID = 16,
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> libc::c_int;
}
extern "C" {
    pub fn clock_gettime_nsec_np(__clock_id: clockid_t) -> __uint64_t;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> libc::c_int;
}
/// Callback for checking whether to abort blocking functions.
/// AVERROR_EXIT is returned in this case by the interrupted
/// function. During blocking operations, callback is called with
/// opaque as parameter. If the callback returns 1, the
/// blocking operation will be aborted.
///
/// No members can be added to this struct without a major bump, if
/// new elements have been added after this struct in AVFormatContext
/// or AVIOContext.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIOInterruptCB {
    pub callback:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void) -> libc::c_int>,
    pub opaque: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_AVIOInterruptCB() {
    assert_eq!(
        ::std::mem::size_of::<AVIOInterruptCB>(),
        16usize,
        concat!("Size of: ", stringify!(AVIOInterruptCB))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIOInterruptCB>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIOInterruptCB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOInterruptCB>())).callback as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOInterruptCB),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOInterruptCB>())).opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOInterruptCB),
            "::",
            stringify!(opaque)
        )
    );
}
#[repr(u32)]
/// Directory entry types.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVIODirEntryType {
    AVIO_ENTRY_UNKNOWN = 0,
    AVIO_ENTRY_BLOCK_DEVICE = 1,
    AVIO_ENTRY_CHARACTER_DEVICE = 2,
    AVIO_ENTRY_DIRECTORY = 3,
    AVIO_ENTRY_NAMED_PIPE = 4,
    AVIO_ENTRY_SYMBOLIC_LINK = 5,
    AVIO_ENTRY_SOCKET = 6,
    AVIO_ENTRY_FILE = 7,
    AVIO_ENTRY_SERVER = 8,
    AVIO_ENTRY_SHARE = 9,
    AVIO_ENTRY_WORKGROUP = 10,
}
/// Describes single entry of the directory.
///
/// Only name and type fields are guaranteed be set.
/// Rest of fields are protocol or/and platform dependent and might be unknown.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIODirEntry {
    /// < Filename
    pub name: *mut libc::c_char,
    /// < Type of the entry
    pub type_: libc::c_int,
    /// < Set to 1 when name is encoded with UTF-8, 0 otherwise.
    /// Name can be encoded with UTF-8 even though 0 is set.
    pub utf8: libc::c_int,
    /// < File size in bytes, -1 if unknown.
    pub size: i64,
    /// < Time of last modification in microseconds since unix
    /// epoch, -1 if unknown.
    pub modification_timestamp: i64,
    /// < Time of last access in microseconds since unix epoch,
    /// -1 if unknown.
    pub access_timestamp: i64,
    /// < Time of last status change in microseconds since unix
    /// epoch, -1 if unknown.
    pub status_change_timestamp: i64,
    /// < User ID of owner, -1 if unknown.
    pub user_id: i64,
    /// < Group ID of owner, -1 if unknown.
    pub group_id: i64,
    /// < Unix file mode, -1 if unknown.
    pub filemode: i64,
}
#[test]
fn bindgen_test_layout_AVIODirEntry() {
    assert_eq!(
        ::std::mem::size_of::<AVIODirEntry>(),
        72usize,
        concat!("Size of: ", stringify!(AVIODirEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIODirEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIODirEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).utf8 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(utf8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVIODirEntry>())).modification_timestamp as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(modification_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).access_timestamp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(access_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVIODirEntry>())).status_change_timestamp as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(status_change_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).user_id as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(user_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).group_id as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(group_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirEntry>())).filemode as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirEntry),
            "::",
            stringify!(filemode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIODirContext {
    pub url_context: *mut URLContext,
}
#[test]
fn bindgen_test_layout_AVIODirContext() {
    assert_eq!(
        ::std::mem::size_of::<AVIODirContext>(),
        8usize,
        concat!("Size of: ", stringify!(AVIODirContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIODirContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIODirContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIODirContext>())).url_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIODirContext),
            "::",
            stringify!(url_context)
        )
    );
}
#[repr(u32)]
/// Different data types that can be returned via the AVIO
/// write_data_type callback.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVIODataMarkerType {
    AVIO_DATA_MARKER_HEADER = 0,
    AVIO_DATA_MARKER_SYNC_POINT = 1,
    AVIO_DATA_MARKER_BOUNDARY_POINT = 2,
    AVIO_DATA_MARKER_UNKNOWN = 3,
    AVIO_DATA_MARKER_TRAILER = 4,
    AVIO_DATA_MARKER_FLUSH_POINT = 5,
}
/// Bytestream IO Context.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVIOContext) must not be used outside libav*.
///
/// @note None of the function pointers in AVIOContext should be called
/// directly, they should only be set by the client application
/// when implementing custom I/O. Normally these are set to the
/// function pointers specified in avio_alloc_context()
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIOContext {
    /// A class for private options.
    ///
    /// If this AVIOContext is created by avio_open2(), av_class is set and
    /// passes the options down to protocols.
    ///
    /// If this AVIOContext is manually allocated, then av_class may be set by
    /// the caller.
    ///
    /// warning -- this field can be NULL, be sure to not pass this AVIOContext
    /// to any av_opt_* functions in that case.
    pub av_class: *const AVClass,
    /// < Start of the buffer.
    pub buffer: *mut libc::c_uchar,
    /// < Maximum buffer size
    pub buffer_size: libc::c_int,
    /// < Current position in the buffer
    pub buf_ptr: *mut libc::c_uchar,
    /// < End of the data, may be less than
    /// buffer+buffer_size if the read function returned
    /// less data than requested, e.g. for streams where
    /// no more data has been received yet.
    pub buf_end: *mut libc::c_uchar,
    /// < A private pointer, passed to the read/write/seek/...
    /// functions.
    pub opaque: *mut libc::c_void,
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut libc::c_void, buf: *mut u8, buf_size: libc::c_int)
            -> libc::c_int,
    >,
    pub write_packet: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut libc::c_void, buf: *mut u8, buf_size: libc::c_int)
            -> libc::c_int,
    >,
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut libc::c_void, offset: i64, whence: libc::c_int) -> i64,
    >,
    /// < position in the file of the current buffer
    pub pos: i64,
    /// < unused
    pub must_flush: libc::c_int,
    /// < true if eof reached
    pub eof_reached: libc::c_int,
    /// < true if open for writing
    pub write_flag: libc::c_int,
    pub max_packet_size: libc::c_int,
    pub checksum: libc::c_ulong,
    pub checksum_ptr: *mut libc::c_uchar,
    pub update_checksum: ::std::option::Option<
        unsafe extern "C" fn(checksum: libc::c_ulong, buf: *const u8, size: libc::c_uint)
            -> libc::c_ulong,
    >,
    /// < contains the error code or 0 if no error happened
    pub error: libc::c_int,
    /// Pause or resume playback for network streaming protocols - e.g. MMS.
    pub read_pause: ::std::option::Option<
        unsafe extern "C" fn(opaque: *mut libc::c_void, pause: libc::c_int) -> libc::c_int,
    >,
    /// Seek to a given timestamp in stream with the specified stream_index.
    /// Needed for some network streaming protocols which don't support seeking
    /// to byte position.
    pub read_seek: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut libc::c_void,
            stream_index: libc::c_int,
            timestamp: i64,
            flags: libc::c_int,
        ) -> i64,
    >,
    /// A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.
    pub seekable: libc::c_int,
    /// max filesize, used to limit allocations
    /// This field is internal to libavformat and access from outside is not allowed.
    pub maxsize: i64,
    /// avio_read and avio_write should if possible be satisfied directly
    /// instead of going through a buffer, and avio_seek will always
    /// call the underlying seek function directly.
    pub direct: libc::c_int,
    /// Bytes read statistic
    /// This field is internal to libavformat and access from outside is not allowed.
    pub bytes_read: i64,
    /// seek statistic
    /// This field is internal to libavformat and access from outside is not allowed.
    pub seek_count: libc::c_int,
    /// writeout statistic
    /// This field is internal to libavformat and access from outside is not allowed.
    pub writeout_count: libc::c_int,
    /// Original buffer size
    /// used internally after probing and ensure seekback to reset the buffer size
    /// This field is internal to libavformat and access from outside is not allowed.
    pub orig_buffer_size: libc::c_int,
    /// Threshold to favor readahead over seek.
    /// This is current internal only, do not use from outside.
    pub short_seek_threshold: libc::c_int,
    /// ',' separated list of allowed protocols.
    pub protocol_whitelist: *const libc::c_char,
    /// ',' separated list of disallowed protocols.
    pub protocol_blacklist: *const libc::c_char,
    /// A callback that is used instead of write_packet.
    pub write_data_type: ::std::option::Option<
        unsafe extern "C" fn(
            opaque: *mut libc::c_void,
            buf: *mut u8,
            buf_size: libc::c_int,
            type_: AVIODataMarkerType,
            time: i64,
        ) -> libc::c_int,
    >,
    /// If set, don't call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT,
    /// but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly
    /// small chunks of data returned from the callback).
    pub ignore_boundary_point: libc::c_int,
    /// Internal, not meant to be used from outside of AVIOContext.
    pub current_type: AVIODataMarkerType,
    pub last_time: i64,
    /// A callback that is used instead of short_seek_threshold.
    /// This is current internal only, do not use from outside.
    pub short_seek_get:
        ::std::option::Option<unsafe extern "C" fn(opaque: *mut libc::c_void) -> libc::c_int>,
    pub written: i64,
    /// Maximum reached position before a backward seek in the write buffer,
    /// used keeping track of already written data for a later flush.
    pub buf_ptr_max: *mut libc::c_uchar,
    /// Try to buffer at least this amount of data before flushing it
    pub min_packet_size: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVIOContext() {
    assert_eq!(
        ::std::mem::size_of::<AVIOContext>(),
        264usize,
        concat!("Size of: ", stringify!(AVIOContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIOContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIOContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).buffer_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).buf_ptr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buf_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).buf_end as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).opaque as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).read_packet as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(read_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).write_packet as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(write_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).seek as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).pos as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).must_flush as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(must_flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).eof_reached as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(eof_reached)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).write_flag as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(write_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).max_packet_size as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(max_packet_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).checksum as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).checksum_ptr as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(checksum_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).update_checksum as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(update_checksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).error as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).read_pause as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(read_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).read_seek as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(read_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).seekable as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(seekable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).maxsize as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(maxsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).direct as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(direct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).bytes_read as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(bytes_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).seek_count as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(seek_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).writeout_count as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(writeout_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).orig_buffer_size as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(orig_buffer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVIOContext>())).short_seek_threshold as *const _ as usize
        },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(short_seek_threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).protocol_whitelist as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(protocol_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).protocol_blacklist as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(protocol_blacklist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).write_data_type as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(write_data_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVIOContext>())).ignore_boundary_point as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(ignore_boundary_point)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).current_type as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(current_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).last_time as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(last_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).short_seek_get as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(short_seek_get)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).written as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(written)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).buf_ptr_max as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(buf_ptr_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIOContext>())).min_packet_size as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIOContext),
            "::",
            stringify!(min_packet_size)
        )
    );
}
extern "C" {
    /// Return the name of the protocol that will handle the passed URL.
    ///
    /// NULL is returned if no protocol could be found for the given URL.
    ///
    /// @return Name of the protocol or NULL.
    pub fn avio_find_protocol_name(url: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    /// Return AVIO_FLAG_* access flags corresponding to the access permissions
    /// of the resource in url, or a negative value corresponding to an
    /// AVERROR code in case of failure. The returned access flags are
    /// masked by the value in flags.
    ///
    /// @note This function is intrinsically unsafe, in the sense that the
    /// checked resource may change its existence or permission status from
    /// one call to another. Thus you should not trust the returned value,
    /// unless you are sure that no other processes are accessing the
    /// checked resource.
    pub fn avio_check(url: *const libc::c_char, flags: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// Move or rename a resource.
    ///
    /// @note url_src and url_dst should share the same protocol and authority.
    ///
    /// @param url_src url to resource to be moved
    /// @param url_dst new url to resource if the operation succeeded
    /// @return >=0 on success or negative on error.
    pub fn avpriv_io_move(
        url_src: *const libc::c_char,
        url_dst: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    /// Delete a resource.
    ///
    /// @param url resource to be deleted.
    /// @return >=0 on success or negative on error.
    pub fn avpriv_io_delete(url: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Open directory for reading.
    ///
    /// @param s       directory read context. Pointer to a NULL pointer must be passed.
    /// @param url     directory to be listed.
    /// @param options A dictionary filled with protocol-private options. On return
    /// this parameter will be destroyed and replaced with a dictionary
    /// containing options that were not found. May be NULL.
    /// @return >=0 on success or negative on error.
    pub fn avio_open_dir(
        s: *mut *mut AVIODirContext,
        url: *const libc::c_char,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    /// Get next directory entry.
    ///
    /// Returned entry must be freed with avio_free_directory_entry(). In particular
    /// it may outlive AVIODirContext.
    ///
    /// @param s         directory read context.
    /// @param[out] next next entry or NULL when no more entries.
    /// @return >=0 on success or negative on error. End of list is not considered an
    /// error.
    pub fn avio_read_dir(s: *mut AVIODirContext, next: *mut *mut AVIODirEntry) -> libc::c_int;
}
extern "C" {
    /// Close directory.
    ///
    /// @note Entries created using avio_read_dir() are not deleted and must be
    /// freeded with avio_free_directory_entry().
    ///
    /// @param s         directory read context.
    /// @return >=0 on success or negative on error.
    pub fn avio_close_dir(s: *mut *mut AVIODirContext) -> libc::c_int;
}
extern "C" {
    /// Free entry allocated by avio_read_dir().
    ///
    /// @param entry entry to be freed.
    pub fn avio_free_directory_entry(entry: *mut *mut AVIODirEntry);
}
extern "C" {
    /// Allocate and initialize an AVIOContext for buffered I/O. It must be later
    /// freed with avio_context_free().
    ///
    /// @param buffer Memory block for input/output operations via AVIOContext.
    /// The buffer must be allocated with av_malloc() and friends.
    /// It may be freed and replaced with a new buffer by libavformat.
    /// AVIOContext.buffer holds the buffer currently in use,
    /// which must be later freed with av_free().
    /// @param buffer_size The buffer size is very important for performance.
    /// For protocols with fixed blocksize it should be set to this blocksize.
    /// For others a typical size is a cache page, e.g. 4kb.
    /// @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.
    /// @param opaque An opaque pointer to user-specific data.
    /// @param read_packet  A function for refilling the buffer, may be NULL.
    /// @param write_packet A function for writing the buffer contents, may be NULL.
    /// The function may not change the input buffers content.
    /// @param seek A function for seeking to specified byte position, may be NULL.
    ///
    /// @return Allocated AVIOContext or NULL on failure.
    pub fn avio_alloc_context(
        buffer: *mut libc::c_uchar,
        buffer_size: libc::c_int,
        write_flag: libc::c_int,
        opaque: *mut libc::c_void,
        read_packet: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut libc::c_void, buf: *mut u8, buf_size: libc::c_int)
                -> libc::c_int,
        >,
        write_packet: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut libc::c_void, buf: *mut u8, buf_size: libc::c_int)
                -> libc::c_int,
        >,
        seek: ::std::option::Option<
            unsafe extern "C" fn(opaque: *mut libc::c_void, offset: i64, whence: libc::c_int)
                -> i64,
        >,
    ) -> *mut AVIOContext;
}
extern "C" {
    /// Free the supplied IO context and everything associated with it.
    ///
    /// @param s Double pointer to the IO context. This function will write NULL
    /// into s.
    pub fn avio_context_free(s: *mut *mut AVIOContext);
}
extern "C" {
    pub fn avio_w8(s: *mut AVIOContext, b: libc::c_int);
}
extern "C" {
    pub fn avio_write(s: *mut AVIOContext, buf: *const libc::c_uchar, size: libc::c_int);
}
extern "C" {
    pub fn avio_wl64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wb64(s: *mut AVIOContext, val: u64);
}
extern "C" {
    pub fn avio_wl32(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wb32(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wl24(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wb24(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wl16(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    pub fn avio_wb16(s: *mut AVIOContext, val: libc::c_uint);
}
extern "C" {
    /// Write a NULL-terminated string.
    /// @return number of bytes written.
    pub fn avio_put_str(s: *mut AVIOContext, str: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Convert an UTF-8 string to UTF-16LE and write it.
    /// @param s the AVIOContext
    /// @param str NULL-terminated UTF-8 string
    ///
    /// @return number of bytes written.
    pub fn avio_put_str16le(s: *mut AVIOContext, str: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Convert an UTF-8 string to UTF-16BE and write it.
    /// @param s the AVIOContext
    /// @param str NULL-terminated UTF-8 string
    ///
    /// @return number of bytes written.
    pub fn avio_put_str16be(s: *mut AVIOContext, str: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Mark the written bytestream as a specific type.
    ///
    /// Zero-length ranges are omitted from the output.
    ///
    /// @param time the stream time the current bytestream pos corresponds to
    /// (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not
    /// applicable
    /// @param type the kind of data written starting at the current pos
    pub fn avio_write_marker(s: *mut AVIOContext, time: i64, type_: AVIODataMarkerType);
}
extern "C" {
    /// fseek() equivalent for AVIOContext.
    /// @return new position or AVERROR.
    pub fn avio_seek(s: *mut AVIOContext, offset: i64, whence: libc::c_int) -> i64;
}
extern "C" {
    /// Skip given number of bytes forward
    /// @return new position or AVERROR.
    pub fn avio_skip(s: *mut AVIOContext, offset: i64) -> i64;
}
extern "C" {
    /// Get the filesize.
    /// @return filesize or AVERROR
    pub fn avio_size(s: *mut AVIOContext) -> i64;
}
extern "C" {
    /// feof() equivalent for AVIOContext.
    /// @return non zero if and only if end of file
    pub fn avio_feof(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    /// @deprecated use avio_feof()
    pub fn url_feof(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    /// @warning Writes up to 4 KiB per call
    pub fn avio_printf(s: *mut AVIOContext, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    /// Force flushing of buffered data.
    ///
    /// For write streams, force the buffered data to be immediately written to the output,
    /// without to wait to fill the internal buffer.
    ///
    /// For read streams, discard all currently buffered data, and advance the
    /// reported file position to that of the underlying stream. This does not
    /// read new data, and does not perform any seeks.
    pub fn avio_flush(s: *mut AVIOContext);
}
extern "C" {
    /// Read size bytes from AVIOContext into buf.
    /// @return number of bytes read or AVERROR
    pub fn avio_read(
        s: *mut AVIOContext,
        buf: *mut libc::c_uchar,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Read size bytes from AVIOContext into buf. Unlike avio_read(), this is allowed
    /// to read fewer bytes than requested. The missing bytes can be read in the next
    /// call. This always tries to read at least 1 byte.
    /// Useful to reduce latency in certain cases.
    /// @return number of bytes read or AVERROR
    pub fn avio_read_partial(
        s: *mut AVIOContext,
        buf: *mut libc::c_uchar,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @name Functions for reading from AVIOContext
    /// @{
    ///
    /// @note return 0 if EOF, so you cannot use it if EOF handling is
    /// necessary
    pub fn avio_r8(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    pub fn avio_rl16(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rl24(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rl32(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rl64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    pub fn avio_rb16(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rb24(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rb32(s: *mut AVIOContext) -> libc::c_uint;
}
extern "C" {
    pub fn avio_rb64(s: *mut AVIOContext) -> u64;
}
extern "C" {
    /// Read a string from pb into buf. The reading will terminate when either
    /// a NULL character was encountered, maxlen bytes have been read, or nothing
    /// more can be read from pb. The result is guaranteed to be NULL-terminated, it
    /// will be truncated if buf is too small.
    /// Note that the string is not interpreted or validated in any way, it
    /// might get truncated in the middle of a sequence for multi-byte encodings.
    ///
    /// @return number of bytes read (is always <= maxlen).
    /// If reading ends on EOF or error, the return value will be one more than
    /// bytes actually read.
    pub fn avio_get_str(
        pb: *mut AVIOContext,
        maxlen: libc::c_int,
        buf: *mut libc::c_char,
        buflen: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Read a UTF-16 string from pb and convert it to UTF-8.
    /// The reading will terminate when either a null or invalid character was
    /// encountered or maxlen bytes have been read.
    /// @return number of bytes read (is always <= maxlen)
    pub fn avio_get_str16le(
        pb: *mut AVIOContext,
        maxlen: libc::c_int,
        buf: *mut libc::c_char,
        buflen: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avio_get_str16be(
        pb: *mut AVIOContext,
        maxlen: libc::c_int,
        buf: *mut libc::c_char,
        buflen: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Create and initialize a AVIOContext for accessing the
    /// resource indicated by url.
    /// @note When the resource indicated by url has been opened in
    /// read+write mode, the AVIOContext can be used only for writing.
    ///
    /// @param s Used to return the pointer to the created AVIOContext.
    /// In case of failure the pointed to value is set to NULL.
    /// @param url resource to access
    /// @param flags flags which control how the resource indicated by url
    /// is to be opened
    /// @return >= 0 in case of success, a negative value corresponding to an
    /// AVERROR code in case of failure
    pub fn avio_open(
        s: *mut *mut AVIOContext,
        url: *const libc::c_char,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Create and initialize a AVIOContext for accessing the
    /// resource indicated by url.
    /// @note When the resource indicated by url has been opened in
    /// read+write mode, the AVIOContext can be used only for writing.
    ///
    /// @param s Used to return the pointer to the created AVIOContext.
    /// In case of failure the pointed to value is set to NULL.
    /// @param url resource to access
    /// @param flags flags which control how the resource indicated by url
    /// is to be opened
    /// @param int_cb an interrupt callback to be used at the protocols level
    /// @param options  A dictionary filled with protocol-private options. On return
    /// this parameter will be destroyed and replaced with a dict containing options
    /// that were not found. May be NULL.
    /// @return >= 0 in case of success, a negative value corresponding to an
    /// AVERROR code in case of failure
    pub fn avio_open2(
        s: *mut *mut AVIOContext,
        url: *const libc::c_char,
        flags: libc::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    /// Close the resource accessed by the AVIOContext s and free it.
    /// This function can only be used if s was opened by avio_open().
    ///
    /// The internal buffer is automatically flushed before closing the
    /// resource.
    ///
    /// @return 0 on success, an AVERROR < 0 on error.
    /// @see avio_closep
    pub fn avio_close(s: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    /// Close the resource accessed by the AVIOContext *s, free it
    /// and set the pointer pointing to it to NULL.
    /// This function can only be used if s was opened by avio_open().
    ///
    /// The internal buffer is automatically flushed before closing the
    /// resource.
    ///
    /// @return 0 on success, an AVERROR < 0 on error.
    /// @see avio_close
    pub fn avio_closep(s: *mut *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    /// Open a write only memory stream.
    ///
    /// @param s new IO context
    /// @return zero if no error.
    pub fn avio_open_dyn_buf(s: *mut *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    /// Return the written size and a pointer to the buffer.
    /// The AVIOContext stream is left intact.
    /// The buffer must NOT be freed.
    /// No padding is added to the buffer.
    ///
    /// @param s IO context
    /// @param pbuffer pointer to a byte buffer
    /// @return the length of the byte buffer
    pub fn avio_get_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> libc::c_int;
}
extern "C" {
    /// Return the written size and a pointer to the buffer. The buffer
    /// must be freed with av_free().
    /// Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.
    ///
    /// @param s IO context
    /// @param pbuffer pointer to a byte buffer
    /// @return the length of the byte buffer
    pub fn avio_close_dyn_buf(s: *mut AVIOContext, pbuffer: *mut *mut u8) -> libc::c_int;
}
extern "C" {
    /// Iterate through names of available protocols.
    ///
    /// @param opaque A private pointer representing current protocol.
    /// It must be a pointer to NULL on first iteration and will
    /// be updated by successive calls to avio_enum_protocols.
    /// @param output If set to 1, iterate over output protocols,
    /// otherwise over input protocols.
    ///
    /// @return A static string containing the name of current protocol or NULL
    pub fn avio_enum_protocols(
        opaque: *mut *mut libc::c_void,
        output: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    /// Pause and resume playing - only meaningful if using a network streaming
    /// protocol (e.g. MMS).
    ///
    /// @param h     IO context from which to call the read_pause function pointer
    /// @param pause 1 for pause, 0 for resume
    pub fn avio_pause(h: *mut AVIOContext, pause: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// Seek to a given timestamp relative to some component stream.
    /// Only meaningful if using a network streaming protocol (e.g. MMS.).
    ///
    /// @param h IO context from which to call the seek function pointers
    /// @param stream_index The stream index that the timestamp is relative to.
    /// If stream_index is (-1) the timestamp should be in AV_TIME_BASE
    /// units from the beginning of the presentation.
    /// If a stream_index >= 0 is used and the protocol does not support
    /// seeking based on component streams, the call will fail.
    /// @param timestamp timestamp in AVStream.time_base units
    /// or if there is no stream specified then in AV_TIME_BASE units.
    /// @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE
    /// and AVSEEK_FLAG_ANY. The protocol may silently ignore
    /// AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will
    /// fail if used and not supported.
    /// @return >= 0 on success
    /// @see AVInputFormat::read_seek
    pub fn avio_seek_time(
        h: *mut AVIOContext,
        stream_index: libc::c_int,
        timestamp: i64,
        flags: libc::c_int,
    ) -> i64;
}
extern "C" {
    /// Read contents of h into print buffer, up to max_size bytes, or up to EOF.
    ///
    /// @return 0 for success (max_size bytes read or EOF reached), negative error
    /// code otherwise
    pub fn avio_read_to_bprint(
        h: *mut AVIOContext,
        pb: *mut AVBPrint,
        max_size: usize,
    ) -> libc::c_int;
}
extern "C" {
    /// Accept and allocate a client context on a server context.
    /// @param  s the server context
    /// @param  c the client context, must be unallocated
    /// @return   >= 0 on success or a negative value corresponding
    /// to an AVERROR on failure
    pub fn avio_accept(s: *mut AVIOContext, c: *mut *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    /// Perform one step of the protocol handshake to accept a new client.
    /// This function must be called on a client returned by avio_accept() before
    /// using it as a read/write context.
    /// It is separate from avio_accept() because it may block.
    /// A step of the handshake is defined by places where the application may
    /// decide to change the proceedings.
    /// For example, on a protocol with a request header and a reply header, each
    /// one can constitute a step because the application may use the parameters
    /// from the request to change parameters in the reply; or each individual
    /// chunk of the request can constitute a step.
    /// If the handshake is already finished, avio_handshake() does nothing and
    /// returns 0 immediately.
    ///
    /// @param  c the client context to perform the handshake on
    /// @return   0   on a complete and successful handshake
    /// > 0 if the handshake progressed, but is not complete
    /// < 0 for an AVERROR code
    pub fn avio_handshake(c: *mut AVIOContext) -> libc::c_int;
}
extern "C" {
    /// Allocate and read the payload of a packet and initialize its
    /// fields with default values.
    ///
    /// @param s    associated IO context
    /// @param pkt packet
    /// @param size desired payload size
    /// @return >0 (read size) if OK, AVERROR_xxx otherwise
    pub fn av_get_packet(s: *mut AVIOContext, pkt: *mut AVPacket, size: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    /// Read data and append it to the current content of the AVPacket.
    /// If pkt->size is 0 this is identical to av_get_packet.
    /// Note that this uses av_grow_packet and thus involves a realloc
    /// which is inefficient. Thus this function should only be used
    /// when there is no reasonable way to know (an upper bound of)
    /// the final size.
    ///
    /// @param s    associated IO context
    /// @param pkt packet
    /// @param size amount of data to read
    /// @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data
    /// will not be lost even if an error occurs.
    pub fn av_append_packet(
        s: *mut AVIOContext,
        pkt: *mut AVPacket,
        size: libc::c_int,
    ) -> libc::c_int;
}
/// The exact value of the fractional number is: 'val + num / den'.
/// num is assumed to be 0 <= num < den.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFrac {
    pub val: i64,
    pub num: i64,
    pub den: i64,
}
#[test]
fn bindgen_test_layout_AVFrac() {
    assert_eq!(
        ::std::mem::size_of::<AVFrac>(),
        24usize,
        concat!("Size of: ", stringify!(AVFrac))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFrac>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFrac))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrac>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrac),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrac>())).num as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrac),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFrac>())).den as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFrac),
            "::",
            stringify!(den)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCodecTag {
    _unused: [u8; 0],
}
/// This structure contains the data a format has to probe a file.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVProbeData {
    pub filename: *const libc::c_char,
    /// < Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero.
    pub buf: *mut libc::c_uchar,
    /// < Size of buf except extra allocated bytes
    pub buf_size: libc::c_int,
    /// < mime_type, when known.
    pub mime_type: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_AVProbeData() {
    assert_eq!(
        ::std::mem::size_of::<AVProbeData>(),
        32usize,
        concat!("Size of: ", stringify!(AVProbeData))
    );
    assert_eq!(
        ::std::mem::align_of::<AVProbeData>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProbeData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProbeData>())).filename as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProbeData>())).buf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProbeData>())).buf_size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProbeData>())).mime_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProbeData),
            "::",
            stringify!(mime_type)
        )
    );
}
/// @addtogroup lavf_encoding
/// @{
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVOutputFormat {
    pub name: *const libc::c_char,
    /// Descriptive name for the format, meant to be more human-readable
    /// than name. You should use the NULL_IF_CONFIG_SMALL() macro
    /// to define it.
    pub long_name: *const libc::c_char,
    pub mime_type: *const libc::c_char,
    /// < comma-separated filename extensions
    pub extensions: *const libc::c_char,
    /// < default audio codec
    pub audio_codec: AVCodecID,
    /// < default video codec
    pub video_codec: AVCodecID,
    /// < default subtitle codec
    pub subtitle_codec: AVCodecID,
    /// can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER,
    /// AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,
    /// AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,
    /// AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE
    pub flags: libc::c_int,
    /// List of supported codec_id-codec_tag pairs, ordered by "better
    /// choice first". The arrays are all terminated by AV_CODEC_ID_NONE.
    pub codec_tag: *const *const AVCodecTag,
    /// < AVClass for the private context
    pub priv_class: *const AVClass,
    /// No fields below this line are part of the public API. They
    /// may not be used outside of libavformat and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub next: *mut AVOutputFormat,
    /// size of private data so that it can be allocated in the wrapper
    pub priv_data_size: libc::c_int,
    pub write_header:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    /// Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,
    /// pkt can be NULL in order to flush data buffered in the muxer.
    /// When flushing, return 0 if there still is more data to flush,
    /// or 1 if everything was flushed and there is no more buffered
    /// data.
    pub write_packet: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int,
    >,
    pub write_trailer:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    /// Currently only used to set pixel format if not YUV420P.
    pub interleave_packet: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            out: *mut AVPacket,
            in_: *mut AVPacket,
            flush: libc::c_int,
        ) -> libc::c_int,
    >,
    /// Test if the given codec can be stored in this container.
    ///
    /// @return 1 if the codec is supported, 0 if it is not.
    /// A negative number if unknown.
    /// MKTAG('A', 'P', 'I', 'C') if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC
    pub query_codec: ::std::option::Option<
        unsafe extern "C" fn(id: AVCodecID, std_compliance: libc::c_int) -> libc::c_int,
    >,
    pub get_output_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream: libc::c_int,
            dts: *mut i64,
            wall: *mut i64,
        ),
    >,
    /// Allows sending messages from application to device.
    pub control_message: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            type_: libc::c_int,
            data: *mut libc::c_void,
            data_size: usize,
        ) -> libc::c_int,
    >,
    /// Write an uncoded AVFrame.
    ///
    /// See av_write_uncoded_frame() for details.
    ///
    /// The library will free *frame afterwards, but the muxer can prevent it
    /// by setting the pointer to NULL.
    pub write_uncoded_frame: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: libc::c_int,
            frame: *mut *mut AVFrame,
            flags: libc::c_uint,
        ) -> libc::c_int,
    >,
    /// Returns device list with it properties.
    /// @see avdevice_list_devices() for more details.
    pub get_device_list: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, device_list: *mut AVDeviceInfoList)
            -> libc::c_int,
    >,
    /// Initialize device capabilities submodule.
    /// @see avdevice_capabilities_create() for more details.
    pub create_device_capabilities: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, caps: *mut AVDeviceCapabilitiesQuery)
            -> libc::c_int,
    >,
    /// Free device capabilities submodule.
    /// @see avdevice_capabilities_free() for more details.
    pub free_device_capabilities: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, caps: *mut AVDeviceCapabilitiesQuery)
            -> libc::c_int,
    >,
    /// < default data codec
    pub data_codec: AVCodecID,
    /// Initialize format. May allocate data here, and set any AVFormatContext or
    /// AVStream parameters that need to be set before packets are sent.
    /// This method must not write output.
    ///
    /// Return 0 if streams were fully configured, 1 if not, negative AVERROR on failure
    ///
    /// Any allocations made here must be freed in deinit().
    pub init:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    /// Deinitialize format. If present, this is called whenever the muxer is being
    /// destroyed, regardless of whether or not the header has been written.
    ///
    /// If a trailer is being written, this is called after write_trailer().
    ///
    /// This is called if init() fails as well.
    pub deinit: ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext)>,
    /// Set up any necessary bitstream filtering and extract any extra data needed
    /// for the global header.
    /// Return 0 if more packets from this stream must be checked; 1 if not.
    pub check_bitstream: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext, pkt: *const AVPacket) -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVOutputFormat() {
    assert_eq!(
        ::std::mem::size_of::<AVOutputFormat>(),
        200usize,
        concat!("Size of: ", stringify!(AVOutputFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<AVOutputFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(AVOutputFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).long_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).mime_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(mime_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).extensions as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).audio_codec as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(audio_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).video_codec as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(video_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).subtitle_codec as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(subtitle_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).codec_tag as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).priv_class as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).next as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).priv_data_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).write_header as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(write_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).write_packet as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(write_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).write_trailer as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(write_trailer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVOutputFormat>())).interleave_packet as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(interleave_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).query_codec as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(query_codec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVOutputFormat>())).get_output_timestamp as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(get_output_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).control_message as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(control_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVOutputFormat>())).write_uncoded_frame as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(write_uncoded_frame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).get_device_list as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(get_device_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVOutputFormat>())).create_device_capabilities as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(create_device_capabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVOutputFormat>())).free_device_capabilities as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(free_device_capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).data_codec as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(data_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).init as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).deinit as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(deinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVOutputFormat>())).check_bitstream as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVOutputFormat),
            "::",
            stringify!(check_bitstream)
        )
    );
}
/// @addtogroup lavf_decoding
/// @{
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVInputFormat {
    /// A comma separated list of short names for the format. New names
    /// may be appended with a minor bump.
    pub name: *const libc::c_char,
    /// Descriptive name for the format, meant to be more human-readable
    /// than name. You should use the NULL_IF_CONFIG_SMALL() macro
    /// to define it.
    pub long_name: *const libc::c_char,
    /// Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,
    /// AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,
    /// AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS.
    pub flags: libc::c_int,
    /// If extensions are defined, then no probe is done. You should
    /// usually not use extension format guessing because it is not
    /// reliable enough
    pub extensions: *const libc::c_char,
    pub codec_tag: *const *const AVCodecTag,
    /// < AVClass for the private context
    pub priv_class: *const AVClass,
    /// Comma-separated list of mime types.
    /// It is used check for matching mime types while probing.
    /// @see av_probe_input_format2
    pub mime_type: *const libc::c_char,
    /// No fields below this line are part of the public API. They
    /// may not be used outside of libavformat and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub next: *mut AVInputFormat,
    /// Raw demuxers store their codec ID here.
    pub raw_codec_id: libc::c_int,
    /// Size of private data so that it can be allocated in the wrapper.
    pub priv_data_size: libc::c_int,
    /// Tell if a given file has a chance of being parsed as this format.
    /// The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes
    /// big so you do not have to check for that unless you need more.
    pub read_probe:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVProbeData) -> libc::c_int>,
    /// Read the format header and initialize the AVFormatContext
    /// structure. Return 0 if OK. 'avformat_new_stream' should be
    /// called to create new streams.
    pub read_header:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    /// Read one packet and put it in 'pkt'. pts and flags are also
    /// set. 'avformat_new_stream' can be called only if the flag
    /// AVFMTCTX_NOHEADER is used and only in the calling thread (not in a
    /// background thread).
    /// @return 0 on success, < 0 on error.
    /// When returning an error, pkt must not have been allocated
    /// or must be freed before returning
    pub read_packet: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int,
    >,
    /// Close the stream. The AVFormatContext and AVStreams are not
    /// freed by this function
    pub read_close:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    /// Seek to a given timestamp relative to the frames in
    /// stream component stream_index.
    /// @param stream_index Must not be -1.
    /// @param flags Selects which direction should be preferred if no exact
    /// match is available.
    /// @return >= 0 on success (but not necessarily the new offset)
    pub read_seek: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFormatContext,
            stream_index: libc::c_int,
            timestamp: i64,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    /// Get the next timestamp in stream[stream_index].time_base units.
    /// @return the timestamp or AV_NOPTS_VALUE if an error occurred
    pub read_timestamp: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: libc::c_int,
            pos: *mut i64,
            pos_limit: i64,
        ) -> i64,
    >,
    /// Start/resume playing - only meaningful if using a network-based format
    /// (RTSP).
    pub read_play:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    /// Pause playing - only meaningful if using a network-based format
    /// (RTSP).
    pub read_pause:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFormatContext) -> libc::c_int>,
    /// Seek to timestamp ts.
    /// Seeking will be done so that the point from which all active streams
    /// can be presented successfully will be closest to ts and within min/max_ts.
    /// Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
    pub read_seek2: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            stream_index: libc::c_int,
            min_ts: i64,
            ts: i64,
            max_ts: i64,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    /// Returns device list with it properties.
    /// @see avdevice_list_devices() for more details.
    pub get_device_list: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, device_list: *mut AVDeviceInfoList)
            -> libc::c_int,
    >,
    /// Initialize device capabilities submodule.
    /// @see avdevice_capabilities_create() for more details.
    pub create_device_capabilities: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, caps: *mut AVDeviceCapabilitiesQuery)
            -> libc::c_int,
    >,
    /// Free device capabilities submodule.
    /// @see avdevice_capabilities_free() for more details.
    pub free_device_capabilities: ::std::option::Option<
        unsafe extern "C" fn(s: *mut AVFormatContext, caps: *mut AVDeviceCapabilitiesQuery)
            -> libc::c_int,
    >,
}
#[test]
fn bindgen_test_layout_AVInputFormat() {
    assert_eq!(
        ::std::mem::size_of::<AVInputFormat>(),
        168usize,
        concat!("Size of: ", stringify!(AVInputFormat))
    );
    assert_eq!(
        ::std::mem::align_of::<AVInputFormat>(),
        8usize,
        concat!("Alignment of ", stringify!(AVInputFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).long_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(long_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).extensions as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).codec_tag as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(codec_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).priv_class as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).mime_type as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(mime_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).next as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).raw_codec_id as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(raw_codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).priv_data_size as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(priv_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_probe as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_header as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_packet as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_packet)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_close as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_seek as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_seek)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_timestamp as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_play as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_play)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_pause as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_pause)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).read_seek2 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(read_seek2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVInputFormat>())).get_device_list as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(get_device_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVInputFormat>())).create_device_capabilities as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(create_device_capabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVInputFormat>())).free_device_capabilities as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVInputFormat),
            "::",
            stringify!(free_device_capabilities)
        )
    );
}
#[repr(u32)]
/// @}
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVStreamParseType {
    AVSTREAM_PARSE_NONE = 0,
    AVSTREAM_PARSE_FULL = 1,
    AVSTREAM_PARSE_HEADERS = 2,
    AVSTREAM_PARSE_TIMESTAMPS = 3,
    AVSTREAM_PARSE_FULL_ONCE = 4,
    AVSTREAM_PARSE_FULL_RAW = 1463898624,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVIndexEntry {
    pub pos: i64,
    /// <
    /// Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available
    /// when seeking to this entry. That means preferable PTS on keyframe based formats.
    /// But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better
    /// is known
    pub timestamp: i64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    /// < Minimum distance between this and the previous keyframe, used to avoid unneeded searching.
    pub min_distance: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVIndexEntry() {
    assert_eq!(
        ::std::mem::size_of::<AVIndexEntry>(),
        24usize,
        concat!("Size of: ", stringify!(AVIndexEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<AVIndexEntry>(),
        8usize,
        concat!("Alignment of ", stringify!(AVIndexEntry))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIndexEntry>())).pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIndexEntry),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIndexEntry>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIndexEntry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVIndexEntry>())).min_distance as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVIndexEntry),
            "::",
            stringify!(min_distance)
        )
    );
}
impl AVIndexEntry {
    #[inline]
    pub fn flags(&self) -> libc::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_flags(&mut self, val: libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn size(&self) -> libc::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_size(&mut self, val: libc::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        flags: libc::c_int,
        size: libc::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let flags: u32 = unsafe { ::std::mem::transmute(flags) };
            flags as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let size: u32 = unsafe { ::std::mem::transmute(size) };
            size as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVStreamInternal {
    _unused: [u8; 0],
}
/// Stream structure.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVStream) must not be used outside libav*.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVStream {
    /// < stream index in AVFormatContext
    pub index: libc::c_int,
    /// Format-specific stream ID.
    /// decoding: set by libavformat
    /// encoding: set by the user, replaced by libavformat if left unset
    pub id: libc::c_int,
    /// @deprecated use the codecpar struct instead
    pub codec: *mut AVCodecContext,
    pub priv_data: *mut libc::c_void,
    /// @deprecated this field is unused
    pub pts: AVFrac,
    /// This is the fundamental unit of time (in seconds) in terms
    /// of which frame timestamps are represented.
    ///
    /// decoding: set by libavformat
    /// encoding: May be set by the caller before avformat_write_header() to
    /// provide a hint to the muxer about the desired timebase. In
    /// avformat_write_header(), the muxer will overwrite this field
    /// with the timebase that will actually be used for the timestamps
    /// written into the file (which may or may not be related to the
    /// user-provided one, depending on the format).
    pub time_base: AVRational,
    /// Decoding: pts of the first frame of the stream in presentation order, in stream time base.
    /// Only set this if you are absolutely 100% sure that the value you set
    /// it to really is the pts of the first frame.
    /// This may be undefined (AV_NOPTS_VALUE).
    /// @note The ASF header does NOT contain a correct start_time the ASF
    /// demuxer must NOT set this.
    pub start_time: i64,
    /// Decoding: duration of the stream, in stream time base.
    /// If a source file does not specify a duration, but does specify
    /// a bitrate, this value will be estimated from bitrate and file size.
    ///
    /// Encoding: May be set by the caller before avformat_write_header() to
    /// provide a hint to the muxer about the estimated duration.
    pub duration: i64,
    /// < number of frames in this stream if known or 0
    pub nb_frames: i64,
    /// < AV_DISPOSITION_* bit field
    pub disposition: libc::c_int,
    /// < Selects which packets can be discarded at will and do not need to be demuxed.
    pub discard: AVDiscard,
    /// sample aspect ratio (0 if unknown)
    /// - encoding: Set by user.
    /// - decoding: Set by libavformat.
    pub sample_aspect_ratio: AVRational,
    pub metadata: *mut AVDictionary,
    /// Average framerate
    ///
    /// - demuxing: May be set by libavformat when creating the stream or in
    /// avformat_find_stream_info().
    /// - muxing: May be set by the caller before avformat_write_header().
    pub avg_frame_rate: AVRational,
    /// For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet
    /// will contain the attached picture.
    ///
    /// decoding: set by libavformat, must not be modified by the caller.
    /// encoding: unused
    pub attached_pic: AVPacket,
    /// An array of side data that applies to the whole stream (i.e. the
    /// container does not allow it to change between packets).
    ///
    /// There may be no overlap between the side data in this array and side data
    /// in the packets. I.e. a given side data is either exported by the muxer
    /// (demuxing) / set by the caller (muxing) in this array, then it never
    /// appears in the packets, or the side data is exported / sent through
    /// the packets (always in the first packet where the value becomes known or
    /// changes), then it does not appear in this array.
    ///
    /// - demuxing: Set by libavformat when the stream is created.
    /// - muxing: May be set by the caller before avformat_write_header().
    ///
    /// Freed by libavformat in avformat_free_context().
    ///
    /// @see av_format_inject_global_side_data()
    pub side_data: *mut AVPacketSideData,
    /// The number of elements in the AVStream.side_data array.
    pub nb_side_data: libc::c_int,
    /// Flags for the user to detect events happening on the stream. Flags must
    /// be cleared by the user once the event has been handled.
    /// A combination of AVSTREAM_EVENT_FLAG_*.
    pub event_flags: libc::c_int,
    pub info: *mut AVStream__bindgen_ty_1,
    /// < number of bits in pts (used for wrapping control)
    pub pts_wrap_bits: libc::c_int,
    /// Timestamp corresponding to the last dts sync point.
    ///
    /// Initialized when AVCodecParserContext.dts_sync_point >= 0 and
    /// a DTS is received from the underlying container. Otherwise set to
    /// AV_NOPTS_VALUE by default.
    pub first_dts: i64,
    pub cur_dts: i64,
    pub last_IP_pts: i64,
    pub last_IP_duration: libc::c_int,
    /// Number of packets to buffer for codec probing
    pub probe_packets: libc::c_int,
    /// Number of frames that have been demuxed during avformat_find_stream_info()
    pub codec_info_nb_frames: libc::c_int,
    pub need_parsing: AVStreamParseType,
    pub parser: *mut AVCodecParserContext,
    /// last packet in packet_buffer for this stream when muxing.
    pub last_in_packet_buffer: *mut AVPacketList,
    pub probe_data: AVProbeData,
    pub pts_buffer: [i64; 17usize],
    /// < Only used if the format does not
    /// support seeking natively.
    pub index_entries: *mut AVIndexEntry,
    pub nb_index_entries: libc::c_int,
    pub index_entries_allocated_size: libc::c_uint,
    /// Real base framerate of the stream.
    /// This is the lowest framerate with which all timestamps can be
    /// represented accurately (it is the least common multiple of all
    /// framerates in the stream). Note, this value is just a guess!
    /// For example, if the time base is 1/90000 and all frames have either
    /// approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.
    ///
    /// Code outside avformat should access this field using:
    /// av_stream_get/set_r_frame_rate(stream)
    pub r_frame_rate: AVRational,
    /// Stream Identifier
    /// This is the MPEG-TS stream identifier +1
    /// 0 means unknown
    pub stream_identifier: libc::c_int,
    pub interleaver_chunk_size: i64,
    pub interleaver_chunk_duration: i64,
    /// stream probing state
    /// -1   -> probing finished
    /// 0   -> no probing requested
    /// rest -> perform probing with request_probe being the minimum score to accept.
    /// NOT PART OF PUBLIC API
    pub request_probe: libc::c_int,
    /// Indicates that everything up to the next keyframe
    /// should be discarded.
    pub skip_to_keyframe: libc::c_int,
    /// Number of samples to skip at the start of the frame decoded from the next packet.
    pub skip_samples: libc::c_int,
    /// If not 0, the number of samples that should be skipped from the start of
    /// the stream (the samples are removed from packets with pts==0, which also
    /// assumes negative timestamps do not happen).
    /// Intended for use with formats such as mp3 with ad-hoc gapless audio
    /// support.
    pub start_skip_samples: i64,
    /// If not 0, the first audio sample that should be discarded from the stream.
    /// This is broken by design (needs global sample count), but can't be
    /// avoided for broken by design formats such as mp3 with ad-hoc gapless
    /// audio support.
    pub first_discard_sample: i64,
    /// The sample after last sample that is intended to be discarded after
    /// first_discard_sample. Works on frame boundaries only. Used to prevent
    /// early EOF if the gapless info is broken (considered concatenated mp3s).
    pub last_discard_sample: i64,
    /// Number of internally decoded frames, used internally in libavformat, do not access
    /// its lifetime differs from info which is why it is not in that structure.
    pub nb_decoded_frames: libc::c_int,
    /// Timestamp offset added to timestamps before muxing
    /// NOT PART OF PUBLIC API
    pub mux_ts_offset: i64,
    /// Internal data to check for wrapping of the time stamp
    pub pts_wrap_reference: i64,
    /// Options for behavior, when a wrap is detected.
    ///
    /// Defined by AV_PTS_WRAP_ values.
    ///
    /// If correction is enabled, there are two possibilities:
    /// If the first time stamp is near the wrap point, the wrap offset
    /// will be subtracted, which will create negative time stamps.
    /// Otherwise the offset will be added.
    pub pts_wrap_behavior: libc::c_int,
    /// Internal data to prevent doing update_initial_durations() twice
    pub update_initial_durations_done: libc::c_int,
    /// Internal data to generate dts from pts
    pub pts_reorder_error: [i64; 17usize],
    pub pts_reorder_error_count: [u8; 17usize],
    /// Internal data to analyze DTS and detect faulty mpeg streams
    pub last_dts_for_order_check: i64,
    pub dts_ordered: u8,
    pub dts_misordered: u8,
    /// Internal data to inject global side data
    pub inject_global_side_data: libc::c_int,
    /// String containing paris of key and values describing recommended encoder configuration.
    /// Paris are separated by ','.
    /// Keys are separated from values by '='.
    pub recommended_encoder_configuration: *mut libc::c_char,
    /// display aspect ratio (0 if unknown)
    /// - encoding: unused
    /// - decoding: Set by libavformat to calculate sample_aspect_ratio internally
    pub display_aspect_ratio: AVRational,
    pub priv_pts: *mut FFFrac,
    /// An opaque field for libavformat internal usage.
    /// Must not be accessed in any way by callers.
    pub internal: *mut AVStreamInternal,
    pub codecpar: *mut AVCodecParameters,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVStream__bindgen_ty_1 {
    pub last_dts: i64,
    pub duration_gcd: i64,
    pub duration_count: libc::c_int,
    pub rfps_duration_sum: i64,
    pub duration_error: *mut [[f64; 399usize]; 2usize],
    pub codec_info_duration: i64,
    pub codec_info_duration_fields: i64,
    /// 0  -> decoder has not been searched for yet.
    /// >0 -> decoder found
    /// <0 -> decoder with codec_id == -found_decoder has not been found
    pub found_decoder: libc::c_int,
    pub last_duration: i64,
    /// Those are used for average framerate estimation.
    pub fps_first_dts: i64,
    pub fps_first_dts_idx: libc::c_int,
    pub fps_last_dts: i64,
    pub fps_last_dts_idx: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVStream__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<AVStream__bindgen_ty_1>(),
        104usize,
        concat!("Size of: ", stringify!(AVStream__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<AVStream__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(AVStream__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).last_dts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(last_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).duration_gcd as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(duration_gcd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).duration_count as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(duration_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).rfps_duration_sum as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(rfps_duration_sum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).duration_error as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(duration_error)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).codec_info_duration as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(codec_info_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).codec_info_duration_fields
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(codec_info_duration_fields)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).found_decoder as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(found_decoder)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).last_duration as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(last_duration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).fps_first_dts as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(fps_first_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).fps_first_dts_idx as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(fps_first_dts_idx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).fps_last_dts as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(fps_last_dts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream__bindgen_ty_1>())).fps_last_dts_idx as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream__bindgen_ty_1),
            "::",
            stringify!(fps_last_dts_idx)
        )
    );
}
#[test]
fn bindgen_test_layout_AVStream() {
    assert_eq!(
        ::std::mem::size_of::<AVStream>(),
        792usize,
        concat!("Size of: ", stringify!(AVStream))
    );
    assert_eq!(
        ::std::mem::align_of::<AVStream>(),
        8usize,
        concat!("Alignment of ", stringify!(AVStream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).codec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).priv_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).pts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).time_base as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).start_time as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).duration as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).nb_frames as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(nb_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).disposition as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(disposition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).discard as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(discard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).sample_aspect_ratio as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).metadata as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).avg_frame_rate as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(avg_frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).attached_pic as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(attached_pic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).side_data as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).nb_side_data as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(nb_side_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).event_flags as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(event_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).info as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).pts_wrap_bits as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_wrap_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).first_dts as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(first_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).cur_dts as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(cur_dts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).last_IP_pts as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(last_IP_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).last_IP_duration as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(last_IP_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).probe_packets as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(probe_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).codec_info_nb_frames as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(codec_info_nb_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).need_parsing as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(need_parsing)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).parser as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).last_in_packet_buffer as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(last_in_packet_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).probe_data as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(probe_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).pts_buffer as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).index_entries as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(index_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).nb_index_entries as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(nb_index_entries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream>())).index_entries_allocated_size as *const _ as usize
        },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(index_entries_allocated_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).r_frame_rate as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(r_frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).stream_identifier as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(stream_identifier)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).interleaver_chunk_size as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(interleaver_chunk_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream>())).interleaver_chunk_duration as *const _ as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(interleaver_chunk_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).request_probe as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(request_probe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).skip_to_keyframe as *const _ as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(skip_to_keyframe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).skip_samples as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(skip_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).start_skip_samples as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(start_skip_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).first_discard_sample as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(first_discard_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).last_discard_sample as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(last_discard_sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).nb_decoded_frames as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(nb_decoded_frames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).mux_ts_offset as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(mux_ts_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).pts_wrap_reference as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_wrap_reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).pts_wrap_behavior as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_wrap_behavior)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream>())).update_initial_durations_done as *const _ as usize
        },
        572usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(update_initial_durations_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).pts_reorder_error as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_reorder_error)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream>())).pts_reorder_error_count as *const _ as usize
        },
        712usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(pts_reorder_error_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream>())).last_dts_for_order_check as *const _ as usize
        },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(last_dts_for_order_check)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).dts_ordered as *const _ as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(dts_ordered)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).dts_misordered as *const _ as usize },
        745usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(dts_misordered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream>())).inject_global_side_data as *const _ as usize
        },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(inject_global_side_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVStream>())).recommended_encoder_configuration as *const _
                as usize
        },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(recommended_encoder_configuration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).display_aspect_ratio as *const _ as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(display_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).priv_pts as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(priv_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).internal as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStream>())).codecpar as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStream),
            "::",
            stringify!(codecpar)
        )
    );
}
extern "C" {
    pub fn av_stream_get_r_frame_rate(s: *const AVStream) -> AVRational;
}
extern "C" {
    pub fn av_stream_set_r_frame_rate(s: *mut AVStream, r: AVRational);
}
extern "C" {
    pub fn av_stream_get_parser(s: *const AVStream) -> *mut AVCodecParserContext;
}
extern "C" {
    pub fn av_stream_get_recommended_encoder_configuration(s: *const AVStream)
        -> *mut libc::c_char;
}
extern "C" {
    pub fn av_stream_set_recommended_encoder_configuration(
        s: *mut AVStream,
        configuration: *mut libc::c_char,
    );
}
extern "C" {
    /// Returns the pts of the last muxed packet + its duration
    ///
    /// the retuned value is undefined when used with a demuxer.
    pub fn av_stream_get_end_pts(st: *const AVStream) -> i64;
}
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVProgram) must not be used outside libav*.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVProgram {
    pub id: libc::c_int,
    pub flags: libc::c_int,
    /// < selects which program to discard and which to feed to the caller
    pub discard: AVDiscard,
    pub stream_index: *mut libc::c_uint,
    pub nb_stream_indexes: libc::c_uint,
    pub metadata: *mut AVDictionary,
    pub program_num: libc::c_int,
    pub pmt_pid: libc::c_int,
    pub pcr_pid: libc::c_int,
    /// All fields below this line are not part of the public API. They
    /// may not be used outside of libavformat and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    pub start_time: i64,
    pub end_time: i64,
    /// < reference dts for wrap detection
    pub pts_wrap_reference: i64,
    /// < behavior on wrap detection
    pub pts_wrap_behavior: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVProgram() {
    assert_eq!(
        ::std::mem::size_of::<AVProgram>(),
        88usize,
        concat!("Size of: ", stringify!(AVProgram))
    );
    assert_eq!(
        ::std::mem::align_of::<AVProgram>(),
        8usize,
        concat!("Alignment of ", stringify!(AVProgram))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).discard as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(discard)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).stream_index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(stream_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).nb_stream_indexes as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(nb_stream_indexes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).metadata as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).program_num as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(program_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).pmt_pid as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pmt_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).pcr_pid as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pcr_pid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).start_time as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).end_time as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(end_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).pts_wrap_reference as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pts_wrap_reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVProgram>())).pts_wrap_behavior as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVProgram),
            "::",
            stringify!(pts_wrap_behavior)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVChapter {
    /// < unique ID to identify the chapter
    pub id: libc::c_int,
    /// < time base in which the start/end timestamps are specified
    pub time_base: AVRational,
    /// < chapter start/end time in time_base units
    pub start: i64,
    /// < chapter start/end time in time_base units
    pub end: i64,
    pub metadata: *mut AVDictionary,
}
#[test]
fn bindgen_test_layout_AVChapter() {
    assert_eq!(
        ::std::mem::size_of::<AVChapter>(),
        40usize,
        concat!("Size of: ", stringify!(AVChapter))
    );
    assert_eq!(
        ::std::mem::align_of::<AVChapter>(),
        8usize,
        concat!("Alignment of ", stringify!(AVChapter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChapter>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChapter>())).time_base as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChapter>())).start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChapter>())).end as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVChapter>())).metadata as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVChapter),
            "::",
            stringify!(metadata)
        )
    );
}
/// Callback used by devices to communicate with application.
pub type av_format_control_message = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        type_: libc::c_int,
        data: *mut libc::c_void,
        data_size: usize,
    ) -> libc::c_int,
>;
pub type AVOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        s: *mut AVFormatContext,
        pb: *mut *mut AVIOContext,
        url: *const libc::c_char,
        flags: libc::c_int,
        int_cb: *const AVIOInterruptCB,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int,
>;
#[repr(u32)]
/// The duration of a video can be estimated through various ways, and this enum can be used
/// to know how the duration was estimated.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVDurationEstimationMethod {
    AVFMT_DURATION_FROM_PTS = 0,
    AVFMT_DURATION_FROM_STREAM = 1,
    AVFMT_DURATION_FROM_BITRATE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFormatInternal {
    _unused: [u8; 0],
}
/// Format I/O context.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVFormatContext) must not be used outside libav*, use
/// avformat_alloc_context() to create an AVFormatContext.
///
/// Fields can be accessed through AVOptions (av_opt*),
/// the name string used matches the associated command line parameter name and
/// can be found in libavformat/options_table.h.
/// The AVOption/command line parameter names differ in some cases from the C
/// structure field names for historic reasons or brevity.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFormatContext {
    /// A class for logging and @ref avoptions. Set by avformat_alloc_context().
    /// Exports (de)muxer private options if they exist.
    pub av_class: *const AVClass,
    /// The input container format.
    ///
    /// Demuxing only, set by avformat_open_input().
    pub iformat: *mut AVInputFormat,
    /// The output container format.
    ///
    /// Muxing only, must be set by the caller before avformat_write_header().
    pub oformat: *mut AVOutputFormat,
    /// Format private data. This is an AVOptions-enabled struct
    /// if and only if iformat/oformat.priv_class is not NULL.
    ///
    /// - muxing: set by avformat_write_header()
    /// - demuxing: set by avformat_open_input()
    pub priv_data: *mut libc::c_void,
    /// I/O context.
    ///
    /// - demuxing: either set by the user before avformat_open_input() (then
    /// the user must close it manually) or set by avformat_open_input().
    /// - muxing: set by the user before avformat_write_header(). The caller must
    /// take care of closing / freeing the IO context.
    ///
    /// Do NOT set this field if AVFMT_NOFILE flag is set in
    /// iformat/oformat.flags. In such a case, the (de)muxer will handle
    /// I/O in some other way and this field will be NULL.
    pub pb: *mut AVIOContext,
    /// Flags signalling stream properties. A combination of AVFMTCTX_*.
    /// Set by libavformat.
    pub ctx_flags: libc::c_int,
    /// Number of elements in AVFormatContext.streams.
    ///
    /// Set by avformat_new_stream(), must not be modified by any other code.
    pub nb_streams: libc::c_uint,
    /// A list of all streams in the file. New streams are created with
    /// avformat_new_stream().
    ///
    /// - demuxing: streams are created by libavformat in avformat_open_input().
    /// If AVFMTCTX_NOHEADER is set in ctx_flags, then new streams may also
    /// appear in av_read_frame().
    /// - muxing: streams are created by the user before avformat_write_header().
    ///
    /// Freed by libavformat in avformat_free_context().
    pub streams: *mut *mut AVStream,
    /// input or output filename
    ///
    /// - demuxing: set by avformat_open_input()
    /// - muxing: may be set by the caller before avformat_write_header()
    pub filename: [libc::c_char; 1024usize],
    /// Position of the first frame of the component, in
    /// AV_TIME_BASE fractional seconds. NEVER set this value directly:
    /// It is deduced from the AVStream values.
    ///
    /// Demuxing only, set by libavformat.
    pub start_time: i64,
    /// Duration of the stream, in AV_TIME_BASE fractional
    /// seconds. Only set this value if you know none of the individual stream
    /// durations and also do not set any of them. This is deduced from the
    /// AVStream values if not set.
    ///
    /// Demuxing only, set by libavformat.
    pub duration: i64,
    /// Total stream bitrate in bit/s, 0 if not
    /// available. Never set it directly if the file_size and the
    /// duration are known as FFmpeg can compute it automatically.
    pub bit_rate: i64,
    pub packet_size: libc::c_uint,
    pub max_delay: libc::c_int,
    /// Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*.
    /// Set by the user before avformat_open_input() / avformat_write_header().
    pub flags: libc::c_int,
    /// Maximum size of the data read from input for determining
    /// the input container format.
    /// Demuxing only, set by the caller before avformat_open_input().
    pub probesize: i64,
    /// Maximum duration (in AV_TIME_BASE units) of the data read
    /// from input in avformat_find_stream_info().
    /// Demuxing only, set by the caller before avformat_find_stream_info().
    /// Can be set to 0 to let avformat choose using a heuristic.
    pub max_analyze_duration: i64,
    pub key: *const u8,
    pub keylen: libc::c_int,
    pub nb_programs: libc::c_uint,
    pub programs: *mut *mut AVProgram,
    /// Forced video codec_id.
    /// Demuxing: Set by user.
    pub video_codec_id: AVCodecID,
    /// Forced audio codec_id.
    /// Demuxing: Set by user.
    pub audio_codec_id: AVCodecID,
    /// Forced subtitle codec_id.
    /// Demuxing: Set by user.
    pub subtitle_codec_id: AVCodecID,
    /// Maximum amount of memory in bytes to use for the index of each stream.
    /// If the index exceeds this size, entries will be discarded as
    /// needed to maintain a smaller size. This can lead to slower or less
    /// accurate seeking (depends on demuxer).
    /// Demuxers for which a full in-memory index is mandatory will ignore
    /// this.
    /// - muxing: unused
    /// - demuxing: set by user
    pub max_index_size: libc::c_uint,
    /// Maximum amount of memory in bytes to use for buffering frames
    /// obtained from realtime capture devices.
    pub max_picture_buffer: libc::c_uint,
    /// Number of chapters in AVChapter array.
    /// When muxing, chapters are normally written in the file header,
    /// so nb_chapters should normally be initialized before write_header
    /// is called. Some muxers (e.g. mov and mkv) can also write chapters
    /// in the trailer.  To write chapters in the trailer, nb_chapters
    /// must be zero when write_header is called and non-zero when
    /// write_trailer is called.
    /// - muxing: set by user
    /// - demuxing: set by libavformat
    pub nb_chapters: libc::c_uint,
    pub chapters: *mut *mut AVChapter,
    /// Metadata that applies to the whole file.
    ///
    /// - demuxing: set by libavformat in avformat_open_input()
    /// - muxing: may be set by the caller before avformat_write_header()
    ///
    /// Freed by libavformat in avformat_free_context().
    pub metadata: *mut AVDictionary,
    /// Start time of the stream in real world time, in microseconds
    /// since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the
    /// stream was captured at this real world time.
    /// - muxing: Set by the caller before avformat_write_header(). If set to
    /// either 0 or AV_NOPTS_VALUE, then the current wall-time will
    /// be used.
    /// - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that
    /// the value may become known after some number of frames
    /// have been received.
    pub start_time_realtime: i64,
    /// The number of frames used for determining the framerate in
    /// avformat_find_stream_info().
    /// Demuxing only, set by the caller before avformat_find_stream_info().
    pub fps_probe_size: libc::c_int,
    /// Error recognition; higher values will detect more errors but may
    /// misdetect some more or less valid parts as errors.
    /// Demuxing only, set by the caller before avformat_open_input().
    pub error_recognition: libc::c_int,
    /// Custom interrupt callbacks for the I/O layer.
    ///
    /// demuxing: set by the user before avformat_open_input().
    /// muxing: set by the user before avformat_write_header()
    /// (mainly useful for AVFMT_NOFILE formats). The callback
    /// should also be passed to avio_open2() if it's used to
    /// open the file.
    pub interrupt_callback: AVIOInterruptCB,
    /// Flags to enable debugging.
    pub debug: libc::c_int,
    /// Maximum buffering duration for interleaving.
    ///
    /// To ensure all the streams are interleaved correctly,
    /// av_interleaved_write_frame() will wait until it has at least one packet
    /// for each stream before actually writing any packets to the output file.
    /// When some streams are "sparse" (i.e. there are large gaps between
    /// successive packets), this can result in excessive buffering.
    ///
    /// This field specifies the maximum difference between the timestamps of the
    /// first and the last packet in the muxing queue, above which libavformat
    /// will output a packet regardless of whether it has queued a packet for all
    /// the streams.
    ///
    /// Muxing only, set by the caller before avformat_write_header().
    pub max_interleave_delta: i64,
    /// Allow non-standard and experimental extension
    /// @see AVCodecContext.strict_std_compliance
    pub strict_std_compliance: libc::c_int,
    /// Flags for the user to detect events happening on the file. Flags must
    /// be cleared by the user once the event has been handled.
    /// A combination of AVFMT_EVENT_FLAG_*.
    pub event_flags: libc::c_int,
    /// Maximum number of packets to read while waiting for the first timestamp.
    /// Decoding only.
    pub max_ts_probe: libc::c_int,
    /// Avoid negative timestamps during muxing.
    /// Any value of the AVFMT_AVOID_NEG_TS_* constants.
    /// Note, this only works when using av_interleaved_write_frame. (interleave_packet_per_dts is in use)
    /// - muxing: Set by user
    /// - demuxing: unused
    pub avoid_negative_ts: libc::c_int,
    /// Transport stream id.
    /// This will be moved into demuxer private options. Thus no API/ABI compatibility
    pub ts_id: libc::c_int,
    /// Audio preload in microseconds.
    /// Note, not all formats support this and unpredictable things may happen if it is used when not supported.
    /// - encoding: Set by user
    /// - decoding: unused
    pub audio_preload: libc::c_int,
    /// Max chunk time in microseconds.
    /// Note, not all formats support this and unpredictable things may happen if it is used when not supported.
    /// - encoding: Set by user
    /// - decoding: unused
    pub max_chunk_duration: libc::c_int,
    /// Max chunk size in bytes
    /// Note, not all formats support this and unpredictable things may happen if it is used when not supported.
    /// - encoding: Set by user
    /// - decoding: unused
    pub max_chunk_size: libc::c_int,
    /// forces the use of wallclock timestamps as pts/dts of packets
    /// This has undefined results in the presence of B frames.
    /// - encoding: unused
    /// - decoding: Set by user
    pub use_wallclock_as_timestamps: libc::c_int,
    /// avio flags, used to force AVIO_FLAG_DIRECT.
    /// - encoding: unused
    /// - decoding: Set by user
    pub avio_flags: libc::c_int,
    /// The duration field can be estimated through various ways, and this field can be used
    /// to know how the duration was estimated.
    /// - encoding: unused
    /// - decoding: Read by user
    pub duration_estimation_method: AVDurationEstimationMethod,
    /// Skip initial bytes when opening stream
    /// - encoding: unused
    /// - decoding: Set by user
    pub skip_initial_bytes: i64,
    /// Correct single timestamp overflows
    /// - encoding: unused
    /// - decoding: Set by user
    pub correct_ts_overflow: libc::c_uint,
    /// Force seeking to any (also non key) frames.
    /// - encoding: unused
    /// - decoding: Set by user
    pub seek2any: libc::c_int,
    /// Flush the I/O context after each packet.
    /// - encoding: Set by user
    /// - decoding: unused
    pub flush_packets: libc::c_int,
    /// format probing score.
    /// The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes
    /// the format.
    /// - encoding: unused
    /// - decoding: set by avformat, read by user
    pub probe_score: libc::c_int,
    /// number of bytes to read maximally to identify format.
    /// - encoding: unused
    /// - decoding: set by user
    pub format_probesize: libc::c_int,
    /// ',' separated list of allowed decoders.
    /// If NULL then all are allowed
    /// - encoding: unused
    /// - decoding: set by user
    pub codec_whitelist: *mut libc::c_char,
    /// ',' separated list of allowed demuxers.
    /// If NULL then all are allowed
    /// - encoding: unused
    /// - decoding: set by user
    pub format_whitelist: *mut libc::c_char,
    /// An opaque field for libavformat internal usage.
    /// Must not be accessed in any way by callers.
    pub internal: *mut AVFormatInternal,
    /// IO repositioned flag.
    /// This is set by avformat when the underlaying IO context read pointer
    /// is repositioned, for example when doing byte based seeking.
    /// Demuxers can use the flag to detect such changes.
    pub io_repositioned: libc::c_int,
    /// Forced video codec.
    /// This allows forcing a specific decoder, even when there are multiple with
    /// the same codec_id.
    /// Demuxing: Set by user
    pub video_codec: *mut AVCodec,
    /// Forced audio codec.
    /// This allows forcing a specific decoder, even when there are multiple with
    /// the same codec_id.
    /// Demuxing: Set by user
    pub audio_codec: *mut AVCodec,
    /// Forced subtitle codec.
    /// This allows forcing a specific decoder, even when there are multiple with
    /// the same codec_id.
    /// Demuxing: Set by user
    pub subtitle_codec: *mut AVCodec,
    /// Forced data codec.
    /// This allows forcing a specific decoder, even when there are multiple with
    /// the same codec_id.
    /// Demuxing: Set by user
    pub data_codec: *mut AVCodec,
    /// Number of bytes to be written as padding in a metadata header.
    /// Demuxing: Unused.
    /// Muxing: Set by user via av_format_set_metadata_header_padding.
    pub metadata_header_padding: libc::c_int,
    /// User data.
    /// This is a place for some private data of the user.
    pub opaque: *mut libc::c_void,
    /// Callback used by devices to communicate with application.
    pub control_message_cb: av_format_control_message,
    /// Output timestamp offset, in microseconds.
    /// Muxing: set by user
    pub output_ts_offset: i64,
    /// dump format separator.
    /// can be ", " or "\n      " or anything else
    /// - muxing: Set by user.
    /// - demuxing: Set by user.
    pub dump_separator: *mut u8,
    /// Forced Data codec_id.
    /// Demuxing: Set by user.
    pub data_codec_id: AVCodecID,
    /// Called to open further IO contexts when needed for demuxing.
    ///
    /// This can be set by the user application to perform security checks on
    /// the URLs before opening them.
    /// The function should behave like avio_open2(), AVFormatContext is provided
    /// as contextual information and to reach AVFormatContext.opaque.
    ///
    /// If NULL then some simple checks are used together with avio_open2().
    ///
    /// Must not be accessed directly from outside avformat.
    /// @See av_format_set_open_cb()
    ///
    /// Demuxing: Set by user.
    ///
    /// @deprecated Use io_open and io_close.
    pub open_cb: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            p: *mut *mut AVIOContext,
            url: *const libc::c_char,
            flags: libc::c_int,
            int_cb: *const AVIOInterruptCB,
            options: *mut *mut AVDictionary,
        ) -> libc::c_int,
    >,
    /// ',' separated list of allowed protocols.
    /// - encoding: unused
    /// - decoding: set by user
    pub protocol_whitelist: *mut libc::c_char,
    pub io_open: ::std::option::Option<
        unsafe extern "C" fn(
            s: *mut AVFormatContext,
            pb: *mut *mut AVIOContext,
            url: *const libc::c_char,
            flags: libc::c_int,
            options: *mut *mut AVDictionary,
        ) -> libc::c_int,
    >,
    /// A callback for closing the streams opened with AVFormatContext.io_open().
    pub io_close:
        ::std::option::Option<unsafe extern "C" fn(s: *mut AVFormatContext, pb: *mut AVIOContext)>,
    /// ',' separated list of disallowed protocols.
    /// - encoding: unused
    /// - decoding: set by user
    pub protocol_blacklist: *mut libc::c_char,
    /// The maximum number of streams.
    /// - encoding: unused
    /// - decoding: set by user
    pub max_streams: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVFormatContext() {
    assert_eq!(
        ::std::mem::size_of::<AVFormatContext>(),
        1488usize,
        concat!("Size of: ", stringify!(AVFormatContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFormatContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFormatContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).iformat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(iformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).oformat as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(oformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).priv_data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(priv_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).pb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(pb)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).ctx_flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(ctx_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).nb_streams as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(nb_streams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).streams as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(streams)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).filename as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).start_time as *const _ as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(start_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).duration as *const _ as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).bit_rate as *const _ as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(bit_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).packet_size as *const _ as usize },
        1104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(packet_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).max_delay as *const _ as usize },
        1108usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).flags as *const _ as usize },
        1112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).probesize as *const _ as usize },
        1120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(probesize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).max_analyze_duration as *const _ as usize
        },
        1128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_analyze_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).key as *const _ as usize },
        1136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).keylen as *const _ as usize },
        1144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).nb_programs as *const _ as usize },
        1148usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(nb_programs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).programs as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(programs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).video_codec_id as *const _ as usize },
        1160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(video_codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).audio_codec_id as *const _ as usize },
        1164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(audio_codec_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).subtitle_codec_id as *const _ as usize
        },
        1168usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(subtitle_codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).max_index_size as *const _ as usize },
        1172usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_index_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).max_picture_buffer as *const _ as usize
        },
        1176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_picture_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).nb_chapters as *const _ as usize },
        1180usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(nb_chapters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).chapters as *const _ as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(chapters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).metadata as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(metadata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).start_time_realtime as *const _ as usize
        },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(start_time_realtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).fps_probe_size as *const _ as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(fps_probe_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).error_recognition as *const _ as usize
        },
        1212usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(error_recognition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).interrupt_callback as *const _ as usize
        },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(interrupt_callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).debug as *const _ as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(debug)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).max_interleave_delta as *const _ as usize
        },
        1240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_interleave_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).strict_std_compliance as *const _ as usize
        },
        1248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(strict_std_compliance)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).event_flags as *const _ as usize },
        1252usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(event_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).max_ts_probe as *const _ as usize },
        1256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_ts_probe)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).avoid_negative_ts as *const _ as usize
        },
        1260usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(avoid_negative_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).ts_id as *const _ as usize },
        1264usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(ts_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).audio_preload as *const _ as usize },
        1268usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(audio_preload)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).max_chunk_duration as *const _ as usize
        },
        1272usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_chunk_duration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).max_chunk_size as *const _ as usize },
        1276usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_chunk_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).use_wallclock_as_timestamps as *const _
                as usize
        },
        1280usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(use_wallclock_as_timestamps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).avio_flags as *const _ as usize },
        1284usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(avio_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).duration_estimation_method as *const _
                as usize
        },
        1288usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(duration_estimation_method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).skip_initial_bytes as *const _ as usize
        },
        1296usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(skip_initial_bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).correct_ts_overflow as *const _ as usize
        },
        1304usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(correct_ts_overflow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).seek2any as *const _ as usize },
        1308usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(seek2any)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).flush_packets as *const _ as usize },
        1312usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(flush_packets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).probe_score as *const _ as usize },
        1316usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(probe_score)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).format_probesize as *const _ as usize
        },
        1320usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(format_probesize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).codec_whitelist as *const _ as usize },
        1328usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(codec_whitelist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).format_whitelist as *const _ as usize
        },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(format_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).internal as *const _ as usize },
        1344usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).io_repositioned as *const _ as usize },
        1352usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_repositioned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).video_codec as *const _ as usize },
        1360usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(video_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).audio_codec as *const _ as usize },
        1368usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(audio_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).subtitle_codec as *const _ as usize },
        1376usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(subtitle_codec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).data_codec as *const _ as usize },
        1384usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(data_codec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).metadata_header_padding as *const _ as usize
        },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(metadata_header_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).opaque as *const _ as usize },
        1400usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).control_message_cb as *const _ as usize
        },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(control_message_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).output_ts_offset as *const _ as usize
        },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(output_ts_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).dump_separator as *const _ as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(dump_separator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).data_codec_id as *const _ as usize },
        1432usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(data_codec_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).open_cb as *const _ as usize },
        1440usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(open_cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).protocol_whitelist as *const _ as usize
        },
        1448usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(protocol_whitelist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).io_open as *const _ as usize },
        1456usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_open)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).io_close as *const _ as usize },
        1464usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(io_close)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFormatContext>())).protocol_blacklist as *const _ as usize
        },
        1472usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(protocol_blacklist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFormatContext>())).max_streams as *const _ as usize },
        1480usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFormatContext),
            "::",
            stringify!(max_streams)
        )
    );
}
extern "C" {
    /// Accessors for some AVFormatContext fields. These used to be provided for ABI
    /// compatibility, and do not need to be used anymore.
    pub fn av_format_get_probe_score(s: *const AVFormatContext) -> libc::c_int;
}
extern "C" {
    pub fn av_format_get_video_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_video_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_audio_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_audio_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_subtitle_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_subtitle_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_data_codec(s: *const AVFormatContext) -> *mut AVCodec;
}
extern "C" {
    pub fn av_format_set_data_codec(s: *mut AVFormatContext, c: *mut AVCodec);
}
extern "C" {
    pub fn av_format_get_metadata_header_padding(s: *const AVFormatContext) -> libc::c_int;
}
extern "C" {
    pub fn av_format_set_metadata_header_padding(s: *mut AVFormatContext, c: libc::c_int);
}
extern "C" {
    pub fn av_format_get_opaque(s: *const AVFormatContext) -> *mut libc::c_void;
}
extern "C" {
    pub fn av_format_set_opaque(s: *mut AVFormatContext, opaque: *mut libc::c_void);
}
extern "C" {
    pub fn av_format_get_control_message_cb(s: *const AVFormatContext)
        -> av_format_control_message;
}
extern "C" {
    pub fn av_format_set_control_message_cb(
        s: *mut AVFormatContext,
        callback: av_format_control_message,
    );
}
extern "C" {
    pub fn av_format_get_open_cb(s: *const AVFormatContext) -> AVOpenCallback;
}
extern "C" {
    pub fn av_format_set_open_cb(s: *mut AVFormatContext, callback: AVOpenCallback);
}
extern "C" {
    /// This function will cause global side data to be injected in the next packet
    /// of each stream as well as after any subsequent seek.
    pub fn av_format_inject_global_side_data(s: *mut AVFormatContext);
}
extern "C" {
    /// Returns the method used to set ctx->duration.
    ///
    /// @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.
    pub fn av_fmt_ctx_get_duration_estimation_method(
        ctx: *const AVFormatContext,
    ) -> AVDurationEstimationMethod;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPacketList {
    pub pkt: AVPacket,
    pub next: *mut AVPacketList,
}
#[test]
fn bindgen_test_layout_AVPacketList() {
    assert_eq!(
        ::std::mem::size_of::<AVPacketList>(),
        96usize,
        concat!("Size of: ", stringify!(AVPacketList))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPacketList>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPacketList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketList>())).pkt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketList),
            "::",
            stringify!(pkt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPacketList>())).next as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPacketList),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    /// Return the LIBAVFORMAT_VERSION_INT constant.
    pub fn avformat_version() -> libc::c_uint;
}
extern "C" {
    /// Return the libavformat build-time configuration.
    pub fn avformat_configuration() -> *const libc::c_char;
}
extern "C" {
    /// Return the libavformat license.
    pub fn avformat_license() -> *const libc::c_char;
}
extern "C" {
    /// Initialize libavformat and register all the muxers, demuxers and
    /// protocols. If you do not call this function, then you can select
    /// exactly which formats you want to support.
    ///
    /// @see av_register_input_format()
    /// @see av_register_output_format()
    pub fn av_register_all();
}
extern "C" {
    pub fn av_register_input_format(format: *mut AVInputFormat);
}
extern "C" {
    pub fn av_register_output_format(format: *mut AVOutputFormat);
}
extern "C" {
    /// Do global initialization of network components. This is optional,
    /// but recommended, since it avoids the overhead of implicitly
    /// doing the setup for each session.
    ///
    /// Calling this function will become mandatory if using network
    /// protocols at some major version bump.
    pub fn avformat_network_init() -> libc::c_int;
}
extern "C" {
    /// Undo the initialization done by avformat_network_init.
    pub fn avformat_network_deinit() -> libc::c_int;
}
extern "C" {
    /// If f is NULL, returns the first registered input format,
    /// if f is non-NULL, returns the next registered input format after f
    /// or NULL if f is the last one.
    pub fn av_iformat_next(f: *const AVInputFormat) -> *mut AVInputFormat;
}
extern "C" {
    /// If f is NULL, returns the first registered output format,
    /// if f is non-NULL, returns the next registered output format after f
    /// or NULL if f is the last one.
    pub fn av_oformat_next(f: *const AVOutputFormat) -> *mut AVOutputFormat;
}
extern "C" {
    /// Allocate an AVFormatContext.
    /// avformat_free_context() can be used to free the context and everything
    /// allocated by the framework within it.
    pub fn avformat_alloc_context() -> *mut AVFormatContext;
}
extern "C" {
    /// Free an AVFormatContext and all its streams.
    /// @param s context to free
    pub fn avformat_free_context(s: *mut AVFormatContext);
}
extern "C" {
    /// Get the AVClass for AVFormatContext. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn avformat_get_class() -> *const AVClass;
}
extern "C" {
    /// Add a new stream to a media file.
    ///
    /// When demuxing, it is called by the demuxer in read_header(). If the
    /// flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also
    /// be called in read_packet().
    ///
    /// When muxing, should be called by the user before avformat_write_header().
    ///
    /// User is required to call avcodec_close() and avformat_free_context() to
    /// clean up the allocation by avformat_new_stream().
    ///
    /// @param s media file handle
    /// @param c If non-NULL, the AVCodecContext corresponding to the new stream
    /// will be initialized to use this codec. This is needed for e.g. codec-specific
    /// defaults to be set, so codec should be provided if it is known.
    ///
    /// @return newly created stream or NULL on error.
    pub fn avformat_new_stream(s: *mut AVFormatContext, c: *const AVCodec) -> *mut AVStream;
}
extern "C" {
    /// Wrap an existing array as stream side data.
    ///
    /// @param st stream
    /// @param type side information type
    /// @param data the side data array. It must be allocated with the av_malloc()
    /// family of functions. The ownership of the data is transferred to
    /// st.
    /// @param size side information size
    /// @return zero on success, a negative AVERROR code on failure. On failure,
    /// the stream is unchanged and the data remains owned by the caller.
    pub fn av_stream_add_side_data(
        st: *mut AVStream,
        type_: AVPacketSideDataType,
        data: *mut u8,
        size: usize,
    ) -> libc::c_int;
}
extern "C" {
    /// Allocate new information from stream.
    ///
    /// @param stream stream
    /// @param type desired side information type
    /// @param size side information size
    /// @return pointer to fresh allocated data or NULL otherwise
    pub fn av_stream_new_side_data(
        stream: *mut AVStream,
        type_: AVPacketSideDataType,
        size: libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_stream_get_side_data(
        stream: *mut AVStream,
        type_: AVPacketSideDataType,
        size: *mut libc::c_int,
    ) -> *mut u8;
}
extern "C" {
    pub fn av_new_program(s: *mut AVFormatContext, id: libc::c_int) -> *mut AVProgram;
}
extern "C" {
    /// Allocate an AVFormatContext for an output format.
    /// avformat_free_context() can be used to free the context and
    /// everything allocated by the framework within it.
    ///
    /// @param *ctx is set to the created format context, or to NULL in
    /// case of failure
    /// @param oformat format to use for allocating the context, if NULL
    /// format_name and filename are used instead
    /// @param format_name the name of output format to use for allocating the
    /// context, if NULL filename is used instead
    /// @param filename the name of the filename to use for allocating the
    /// context, may be NULL
    /// @return >= 0 in case of success, a negative AVERROR code in case of
    /// failure
    pub fn avformat_alloc_output_context2(
        ctx: *mut *mut AVFormatContext,
        oformat: *mut AVOutputFormat,
        format_name: *const libc::c_char,
        filename: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    /// Find AVInputFormat based on the short name of the input format.
    pub fn av_find_input_format(short_name: *const libc::c_char) -> *mut AVInputFormat;
}
extern "C" {
    /// Guess the file format.
    ///
    /// @param pd        data to be probed
    /// @param is_opened Whether the file is already opened; determines whether
    /// demuxers with or without AVFMT_NOFILE are probed.
    pub fn av_probe_input_format(
        pd: *mut AVProbeData,
        is_opened: libc::c_int,
    ) -> *mut AVInputFormat;
}
extern "C" {
    /// Guess the file format.
    ///
    /// @param pd        data to be probed
    /// @param is_opened Whether the file is already opened; determines whether
    /// demuxers with or without AVFMT_NOFILE are probed.
    /// @param score_max A probe score larger that this is required to accept a
    /// detection, the variable is set to the actual detection
    /// score afterwards.
    /// If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended
    /// to retry with a larger probe buffer.
    pub fn av_probe_input_format2(
        pd: *mut AVProbeData,
        is_opened: libc::c_int,
        score_max: *mut libc::c_int,
    ) -> *mut AVInputFormat;
}
extern "C" {
    /// Guess the file format.
    ///
    /// @param is_opened Whether the file is already opened; determines whether
    /// demuxers with or without AVFMT_NOFILE are probed.
    /// @param score_ret The score of the best detection.
    pub fn av_probe_input_format3(
        pd: *mut AVProbeData,
        is_opened: libc::c_int,
        score_ret: *mut libc::c_int,
    ) -> *mut AVInputFormat;
}
extern "C" {
    /// Probe a bytestream to determine the input format. Each time a probe returns
    /// with a score that is too low, the probe buffer size is increased and another
    /// attempt is made. When the maximum probe size is reached, the input format
    /// with the highest score is returned.
    ///
    /// @param pb the bytestream to probe
    /// @param fmt the input format is put here
    /// @param url the url of the stream
    /// @param logctx the log context
    /// @param offset the offset within the bytestream to probe from
    /// @param max_probe_size the maximum probe buffer size (zero for default)
    /// @return the score in case of success, a negative value corresponding to an
    /// the maximal score is AVPROBE_SCORE_MAX
    /// AVERROR code otherwise
    pub fn av_probe_input_buffer2(
        pb: *mut AVIOContext,
        fmt: *mut *mut AVInputFormat,
        url: *const libc::c_char,
        logctx: *mut libc::c_void,
        offset: libc::c_uint,
        max_probe_size: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    /// Like av_probe_input_buffer2() but returns 0 on success
    pub fn av_probe_input_buffer(
        pb: *mut AVIOContext,
        fmt: *mut *mut AVInputFormat,
        url: *const libc::c_char,
        logctx: *mut libc::c_void,
        offset: libc::c_uint,
        max_probe_size: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    /// Open an input stream and read the header. The codecs are not opened.
    /// The stream must be closed with avformat_close_input().
    ///
    /// @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).
    /// May be a pointer to NULL, in which case an AVFormatContext is allocated by this
    /// function and written into ps.
    /// Note that a user-supplied AVFormatContext will be freed on failure.
    /// @param url URL of the stream to open.
    /// @param fmt If non-NULL, this parameter forces a specific input format.
    /// Otherwise the format is autodetected.
    /// @param options  A dictionary filled with AVFormatContext and demuxer-private options.
    /// On return this parameter will be destroyed and replaced with a dict containing
    /// options that were not found. May be NULL.
    ///
    /// @return 0 on success, a negative AVERROR on failure.
    ///
    /// @note If you want to use custom IO, preallocate the format context and set its pb field.
    pub fn avformat_open_input(
        ps: *mut *mut AVFormatContext,
        url: *const libc::c_char,
        fmt: *mut AVInputFormat,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_demuxer_open(ic: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    /// Read packets of a media file to get stream information. This
    /// is useful for file formats with no headers such as MPEG. This
    /// function also computes the real framerate in case of MPEG-2 repeat
    /// frame mode.
    /// The logical file position is not changed by this function;
    /// examined packets may be buffered for later processing.
    ///
    /// @param ic media file handle
    /// @param options  If non-NULL, an ic.nb_streams long array of pointers to
    /// dictionaries, where i-th member contains options for
    /// codec corresponding to i-th stream.
    /// On return each dictionary will be filled with options that were not found.
    /// @return >=0 if OK, AVERROR_xxx on error
    ///
    /// @note this function isn't guaranteed to open all the codecs, so
    /// options being non-empty at return is a perfectly normal behavior.
    ///
    /// @todo Let the user decide somehow what information is needed so that
    /// we do not waste time getting stuff the user does not need.
    pub fn avformat_find_stream_info(
        ic: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    /// Find the programs which belong to a given stream.
    ///
    /// @param ic    media file handle
    /// @param last  the last found program, the search will start after this
    /// program, or from the beginning if it is NULL
    /// @param s     stream index
    /// @return the next program which belongs to s, NULL if no program is found or
    /// the last program is not among the programs of ic.
    pub fn av_find_program_from_stream(
        ic: *mut AVFormatContext,
        last: *mut AVProgram,
        s: libc::c_int,
    ) -> *mut AVProgram;
}
extern "C" {
    pub fn av_program_add_stream_index(
        ac: *mut AVFormatContext,
        progid: libc::c_int,
        idx: libc::c_uint,
    );
}
extern "C" {
    /// Find the "best" stream in the file.
    /// The best stream is determined according to various heuristics as the most
    /// likely to be what the user expects.
    /// If the decoder parameter is non-NULL, av_find_best_stream will find the
    /// default decoder for the stream's codec; streams for which no decoder can
    /// be found are ignored.
    ///
    /// @param ic                media file handle
    /// @param type              stream type: video, audio, subtitles, etc.
    /// @param wanted_stream_nb  user-requested stream number,
    /// or -1 for automatic selection
    /// @param related_stream    try to find a stream related (eg. in the same
    /// program) to this one, or -1 if none
    /// @param decoder_ret       if non-NULL, returns the decoder for the
    /// selected stream
    /// @param flags             flags; none are currently defined
    /// @return  the non-negative stream number in case of success,
    /// AVERROR_STREAM_NOT_FOUND if no stream with the requested type
    /// could be found,
    /// AVERROR_DECODER_NOT_FOUND if streams were found but no decoder
    /// @note  If av_find_best_stream returns successfully and decoder_ret is not
    /// NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.
    pub fn av_find_best_stream(
        ic: *mut AVFormatContext,
        type_: AVMediaType,
        wanted_stream_nb: libc::c_int,
        related_stream: libc::c_int,
        decoder_ret: *mut *mut AVCodec,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Return the next frame of a stream.
    /// This function returns what is stored in the file, and does not validate
    /// that what is there are valid frames for the decoder. It will split what is
    /// stored in the file into frames and return one for each call. It will not
    /// omit invalid data between valid frames so as to give the decoder the maximum
    /// information possible for decoding.
    ///
    /// If pkt->buf is NULL, then the packet is valid until the next
    /// av_read_frame() or until avformat_close_input(). Otherwise the packet
    /// is valid indefinitely. In both cases the packet must be freed with
    /// av_packet_unref when it is no longer needed. For video, the packet contains
    /// exactly one frame. For audio, it contains an integer number of frames if each
    /// frame has a known fixed size (e.g. PCM or ADPCM data). If the audio frames
    /// have a variable size (e.g. MPEG audio), then it contains one frame.
    ///
    /// pkt->pts, pkt->dts and pkt->duration are always set to correct
    /// values in AVStream.time_base units (and guessed if the format cannot
    /// provide them). pkt->pts can be AV_NOPTS_VALUE if the video format
    /// has B-frames, so it is better to rely on pkt->dts if you do not
    /// decompress the payload.
    ///
    /// @return 0 if OK, < 0 on error or end of file
    pub fn av_read_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    /// Seek to the keyframe at timestamp.
    /// 'timestamp' in 'stream_index'.
    ///
    /// @param s media file handle
    /// @param stream_index If stream_index is (-1), a default
    /// stream is selected, and timestamp is automatically converted
    /// from AV_TIME_BASE units to the stream specific time_base.
    /// @param timestamp Timestamp in AVStream.time_base units
    /// or, if no stream is specified, in AV_TIME_BASE units.
    /// @param flags flags which select direction and seeking mode
    /// @return >= 0 on success
    pub fn av_seek_frame(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        timestamp: i64,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Seek to timestamp ts.
    /// Seeking will be done so that the point from which all active streams
    /// can be presented successfully will be closest to ts and within min/max_ts.
    /// Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
    ///
    /// If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and
    /// are the file position (this may not be supported by all demuxers).
    /// If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames
    /// in the stream with stream_index (this may not be supported by all demuxers).
    /// Otherwise all timestamps are in units of the stream selected by stream_index
    /// or if stream_index is -1, in AV_TIME_BASE units.
    /// If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as
    /// keyframes (this may not be supported by all demuxers).
    /// If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.
    ///
    /// @param s media file handle
    /// @param stream_index index of the stream which is used as time base reference
    /// @param min_ts smallest acceptable timestamp
    /// @param ts target timestamp
    /// @param max_ts largest acceptable timestamp
    /// @param flags flags
    /// @return >=0 on success, error code otherwise
    ///
    /// @note This is part of the new seek API which is still under construction.
    /// Thus do not use this yet. It may change at any time, do not expect
    /// ABI compatibility yet!
    pub fn avformat_seek_file(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        min_ts: i64,
        ts: i64,
        max_ts: i64,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Discard all internally buffered data. This can be useful when dealing with
    /// discontinuities in the byte stream. Generally works only with formats that
    /// can resync. This includes headerless formats like MPEG-TS/TS but should also
    /// work with NUT, Ogg and in a limited way AVI for example.
    ///
    /// The set of streams, the detected duration, stream parameters and codecs do
    /// not change when calling this function. If you want a complete reset, it's
    /// better to open a new AVFormatContext.
    ///
    /// This does not flush the AVIOContext (s->pb). If necessary, call
    /// avio_flush(s->pb) before calling this function.
    ///
    /// @param s media file handle
    /// @return >=0 on success, error code otherwise
    pub fn avformat_flush(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    /// Start playing a network-based stream (e.g. RTSP stream) at the
    /// current position.
    pub fn av_read_play(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    /// Pause a network-based stream (e.g. RTSP stream).
    ///
    /// Use av_read_play() to resume it.
    pub fn av_read_pause(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    /// Close an opened input AVFormatContext. Free it and all its contents
    /// and set *s to NULL.
    pub fn avformat_close_input(s: *mut *mut AVFormatContext);
}
extern "C" {
    /// Allocate the stream private data and write the stream header to
    /// an output media file.
    ///
    /// @param s Media file handle, must be allocated with avformat_alloc_context().
    /// Its oformat field must be set to the desired output format;
    /// Its pb field must be set to an already opened AVIOContext.
    /// @param options  An AVDictionary filled with AVFormatContext and muxer-private options.
    /// On return this parameter will be destroyed and replaced with a dict containing
    /// options that were not found. May be NULL.
    ///
    /// @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init,
    /// AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init,
    /// negative AVERROR on failure.
    ///
    /// @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output.
    pub fn avformat_write_header(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    /// Allocate the stream private data and initialize the codec, but do not write the header.
    /// May optionally be used before avformat_write_header to initialize stream parameters
    /// before actually writing the header.
    /// If using this function, do not pass the same options to avformat_write_header.
    ///
    /// @param s Media file handle, must be allocated with avformat_alloc_context().
    /// Its oformat field must be set to the desired output format;
    /// Its pb field must be set to an already opened AVIOContext.
    /// @param options  An AVDictionary filled with AVFormatContext and muxer-private options.
    /// On return this parameter will be destroyed and replaced with a dict containing
    /// options that were not found. May be NULL.
    ///
    /// @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize,
    /// AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized,
    /// negative AVERROR on failure.
    ///
    /// @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header.
    pub fn avformat_init_output(
        s: *mut AVFormatContext,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    /// Write a packet to an output media file.
    ///
    /// This function passes the packet directly to the muxer, without any buffering
    /// or reordering. The caller is responsible for correctly interleaving the
    /// packets if the format requires it. Callers that want libavformat to handle
    /// the interleaving should call av_interleaved_write_frame() instead of this
    /// function.
    ///
    /// @param s media file handle
    /// @param pkt The packet containing the data to be written. Note that unlike
    /// av_interleaved_write_frame(), this function does not take
    /// ownership of the packet passed to it (though some muxers may make
    /// an internal reference to the input packet).
    /// <br>
    /// This parameter can be NULL (at any time, not just at the end), in
    /// order to immediately flush data buffered within the muxer, for
    /// muxers that buffer up data internally before writing it to the
    /// output.
    /// <br>
    /// Packet's @ref AVPacket.stream_index "stream_index" field must be
    /// set to the index of the corresponding stream in @ref
    /// AVFormatContext.streams "s->streams".
    /// <br>
    /// The timestamps (@ref AVPacket.pts "pts", @ref AVPacket.dts "dts")
    /// must be set to correct values in the stream's timebase (unless the
    /// output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
    /// they can be set to AV_NOPTS_VALUE).
    /// The dts for subsequent packets passed to this function must be strictly
    /// increasing when compared in their respective timebases (unless the
    /// output format is flagged with the AVFMT_TS_NONSTRICT, then they
    /// merely have to be nondecreasing).  @ref AVPacket.duration
    /// "duration") should also be set if known.
    /// @return < 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush
    ///
    /// @see av_interleaved_write_frame()
    pub fn av_write_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    /// Write a packet to an output media file ensuring correct interleaving.
    ///
    /// This function will buffer the packets internally as needed to make sure the
    /// packets in the output file are properly interleaved in the order of
    /// increasing dts. Callers doing their own interleaving should call
    /// av_write_frame() instead of this function.
    ///
    /// Using this function instead of av_write_frame() can give muxers advance
    /// knowledge of future packets, improving e.g. the behaviour of the mp4
    /// muxer for VFR content in fragmenting mode.
    ///
    /// @param s media file handle
    /// @param pkt The packet containing the data to be written.
    /// <br>
    /// If the packet is reference-counted, this function will take
    /// ownership of this reference and unreference it later when it sees
    /// fit.
    /// The caller must not access the data through this reference after
    /// this function returns. If the packet is not reference-counted,
    /// libavformat will make a copy.
    /// <br>
    /// This parameter can be NULL (at any time, not just at the end), to
    /// flush the interleaving queues.
    /// <br>
    /// Packet's @ref AVPacket.stream_index "stream_index" field must be
    /// set to the index of the corresponding stream in @ref
    /// AVFormatContext.streams "s->streams".
    /// <br>
    /// The timestamps (@ref AVPacket.pts "pts", @ref AVPacket.dts "dts")
    /// must be set to correct values in the stream's timebase (unless the
    /// output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
    /// they can be set to AV_NOPTS_VALUE).
    /// The dts for subsequent packets in one stream must be strictly
    /// increasing (unless the output format is flagged with the
    /// AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).
    /// @ref AVPacket.duration "duration") should also be set if known.
    ///
    /// @return 0 on success, a negative AVERROR on error. Libavformat will always
    /// take care of freeing the packet, even if this function fails.
    ///
    /// @see av_write_frame(), AVFormatContext.max_interleave_delta
    pub fn av_interleaved_write_frame(s: *mut AVFormatContext, pkt: *mut AVPacket) -> libc::c_int;
}
extern "C" {
    /// Write an uncoded frame to an output media file.
    ///
    /// The frame must be correctly interleaved according to the container
    /// specification; if not, then av_interleaved_write_frame() must be used.
    ///
    /// See av_interleaved_write_frame() for details.
    pub fn av_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        frame: *mut AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    /// Write an uncoded frame to an output media file.
    ///
    /// If the muxer supports it, this function makes it possible to write an AVFrame
    /// structure directly, without encoding it into a packet.
    /// It is mostly useful for devices and similar special muxers that use raw
    /// video or PCM data and will not serialize it into a byte stream.
    ///
    /// To test whether it is possible to use it with a given muxer and stream,
    /// use av_write_uncoded_frame_query().
    ///
    /// The caller gives up ownership of the frame and must not access it
    /// afterwards.
    ///
    /// @return  >=0 for success, a negative code on error
    pub fn av_interleaved_write_uncoded_frame(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
        frame: *mut AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    /// Test whether a muxer supports uncoded frame.
    ///
    /// @return  >=0 if an uncoded frame can be written to that muxer and stream,
    /// <0 if not
    pub fn av_write_uncoded_frame_query(
        s: *mut AVFormatContext,
        stream_index: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Write the stream trailer to an output media file and free the
    /// file private data.
    ///
    /// May only be called after a successful call to avformat_write_header.
    ///
    /// @param s media file handle
    /// @return 0 if OK, AVERROR_xxx on error
    pub fn av_write_trailer(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    /// Return the output format in the list of registered output formats
    /// which best matches the provided parameters, or return NULL if
    /// there is no match.
    ///
    /// @param short_name if non-NULL checks if short_name matches with the
    /// names of the registered formats
    /// @param filename if non-NULL checks if filename terminates with the
    /// extensions of the registered formats
    /// @param mime_type if non-NULL checks if mime_type matches with the
    /// MIME type of the registered formats
    pub fn av_guess_format(
        short_name: *const libc::c_char,
        filename: *const libc::c_char,
        mime_type: *const libc::c_char,
    ) -> *mut AVOutputFormat;
}
extern "C" {
    /// Guess the codec ID based upon muxer and filename.
    pub fn av_guess_codec(
        fmt: *mut AVOutputFormat,
        short_name: *const libc::c_char,
        filename: *const libc::c_char,
        mime_type: *const libc::c_char,
        type_: AVMediaType,
    ) -> AVCodecID;
}
extern "C" {
    /// Get timing information for the data currently output.
    /// The exact meaning of "currently output" depends on the format.
    /// It is mostly relevant for devices that have an internal buffer and/or
    /// work in real time.
    /// @param s          media file handle
    /// @param stream     stream in the media file
    /// @param[out] dts   DTS of the last packet output for the stream, in stream
    /// time_base units
    /// @param[out] wall  absolute time when that packet whas output,
    /// in microsecond
    /// @return  0 if OK, AVERROR(ENOSYS) if the format does not support it
    /// Note: some formats or devices may not allow to measure dts and wall
    /// atomically.
    pub fn av_get_output_timestamp(
        s: *mut AVFormatContext,
        stream: libc::c_int,
        dts: *mut i64,
        wall: *mut i64,
    ) -> libc::c_int;
}
extern "C" {
    /// Send a nice hexadecimal dump of a buffer to the specified file stream.
    ///
    /// @param f The file stream pointer where the dump should be sent to.
    /// @param buf buffer
    /// @param size buffer size
    ///
    /// @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2
    pub fn av_hex_dump(f: *mut FILE, buf: *const u8, size: libc::c_int);
}
extern "C" {
    /// Send a nice hexadecimal dump of a buffer to the log.
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    /// pointer to an AVClass struct.
    /// @param level The importance level of the message, lower values signifying
    /// higher importance.
    /// @param buf buffer
    /// @param size buffer size
    ///
    /// @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2
    pub fn av_hex_dump_log(
        avcl: *mut libc::c_void,
        level: libc::c_int,
        buf: *const u8,
        size: libc::c_int,
    );
}
extern "C" {
    /// Send a nice dump of a packet to the specified file stream.
    ///
    /// @param f The file stream pointer where the dump should be sent to.
    /// @param pkt packet to dump
    /// @param dump_payload True if the payload must be displayed, too.
    /// @param st AVStream that the packet belongs to
    pub fn av_pkt_dump2(
        f: *mut FILE,
        pkt: *const AVPacket,
        dump_payload: libc::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    /// Send a nice dump of a packet to the log.
    ///
    /// @param avcl A pointer to an arbitrary struct of which the first field is a
    /// pointer to an AVClass struct.
    /// @param level The importance level of the message, lower values signifying
    /// higher importance.
    /// @param pkt packet to dump
    /// @param dump_payload True if the payload must be displayed, too.
    /// @param st AVStream that the packet belongs to
    pub fn av_pkt_dump_log2(
        avcl: *mut libc::c_void,
        level: libc::c_int,
        pkt: *const AVPacket,
        dump_payload: libc::c_int,
        st: *const AVStream,
    );
}
extern "C" {
    /// Get the AVCodecID for the given codec tag tag.
    /// If no codec id is found returns AV_CODEC_ID_NONE.
    ///
    /// @param tags list of supported codec_id-codec_tag pairs, as stored
    /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
    /// @param tag  codec tag to match to a codec ID
    pub fn av_codec_get_id(tags: *const *const AVCodecTag, tag: libc::c_uint) -> AVCodecID;
}
extern "C" {
    /// Get the codec tag for the given codec id id.
    /// If no codec tag is found returns 0.
    ///
    /// @param tags list of supported codec_id-codec_tag pairs, as stored
    /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
    /// @param id   codec ID to match to a codec tag
    pub fn av_codec_get_tag(tags: *const *const AVCodecTag, id: AVCodecID) -> libc::c_uint;
}
extern "C" {
    /// Get the codec tag for the given codec id.
    ///
    /// @param tags list of supported codec_id - codec_tag pairs, as stored
    /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
    /// @param id codec id that should be searched for in the list
    /// @param tag A pointer to the found tag
    /// @return 0 if id was not found in tags, > 0 if it was found
    pub fn av_codec_get_tag2(
        tags: *const *const AVCodecTag,
        id: AVCodecID,
        tag: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_find_default_stream_index(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    /// Get the index for a specific timestamp.
    ///
    /// @param st        stream that the timestamp belongs to
    /// @param timestamp timestamp to retrieve the index for
    /// @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond
    /// to the timestamp which is <= the requested one, if backward
    /// is 0, then it will be >=
    /// if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise
    /// @return < 0 if no such timestamp could be found
    pub fn av_index_search_timestamp(
        st: *mut AVStream,
        timestamp: i64,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Add an index entry into a sorted list. Update the entry if the list
    /// already contains it.
    ///
    /// @param timestamp timestamp in the time base of the given stream
    pub fn av_add_index_entry(
        st: *mut AVStream,
        pos: i64,
        timestamp: i64,
        size: libc::c_int,
        distance: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Split a URL string into components.
    ///
    /// The pointers to buffers for storing individual components may be null,
    /// in order to ignore that component. Buffers for components not found are
    /// set to empty strings. If the port is not found, it is set to a negative
    /// value.
    ///
    /// @param proto the buffer for the protocol
    /// @param proto_size the size of the proto buffer
    /// @param authorization the buffer for the authorization
    /// @param authorization_size the size of the authorization buffer
    /// @param hostname the buffer for the host name
    /// @param hostname_size the size of the hostname buffer
    /// @param port_ptr a pointer to store the port number in
    /// @param path the buffer for the path
    /// @param path_size the size of the path buffer
    /// @param url the URL to split
    pub fn av_url_split(
        proto: *mut libc::c_char,
        proto_size: libc::c_int,
        authorization: *mut libc::c_char,
        authorization_size: libc::c_int,
        hostname: *mut libc::c_char,
        hostname_size: libc::c_int,
        port_ptr: *mut libc::c_int,
        path: *mut libc::c_char,
        path_size: libc::c_int,
        url: *const libc::c_char,
    );
}
extern "C" {
    /// Print detailed information about the input or output format, such as
    /// duration, bitrate, streams, container, programs, metadata, side data,
    /// codec and time base.
    ///
    /// @param ic        the context to analyze
    /// @param index     index of the stream to dump information about
    /// @param url       the URL to print, such as source or destination file
    /// @param is_output Select whether the specified context is an input(0) or output(1)
    pub fn av_dump_format(
        ic: *mut AVFormatContext,
        index: libc::c_int,
        url: *const libc::c_char,
        is_output: libc::c_int,
    );
}
extern "C" {
    /// Return in 'buf' the path with '%d' replaced by a number.
    ///
    /// Also handles the '%0nd' format where 'n' is the total number
    /// of digits and '%%'.
    ///
    /// @param buf destination buffer
    /// @param buf_size destination buffer size
    /// @param path numbered sequence string
    /// @param number frame number
    /// @param flags AV_FRAME_FILENAME_FLAGS_*
    /// @return 0 if OK, -1 on format error
    pub fn av_get_frame_filename2(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        path: *const libc::c_char,
        number: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn av_get_frame_filename(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        path: *const libc::c_char,
        number: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Check whether filename actually is a numbered sequence generator.
    ///
    /// @param filename possible numbered sequence string
    /// @return 1 if a valid numbered sequence string, 0 otherwise
    pub fn av_filename_number_test(filename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Generate an SDP for an RTP session.
    ///
    /// Note, this overwrites the id values of AVStreams in the muxer contexts
    /// for getting unique dynamic payload types.
    ///
    /// @param ac array of AVFormatContexts describing the RTP streams. If the
    /// array is composed by only one context, such context can contain
    /// multiple AVStreams (one AVStream per RTP stream). Otherwise,
    /// all the contexts in the array (an AVCodecContext per RTP stream)
    /// must contain only one AVStream.
    /// @param n_files number of AVCodecContexts contained in ac
    /// @param buf buffer where the SDP will be stored (must be allocated by
    /// the caller)
    /// @param size the size of the buffer
    /// @return 0 if OK, AVERROR_xxx on error
    pub fn av_sdp_create(
        ac: *mut *mut AVFormatContext,
        n_files: libc::c_int,
        buf: *mut libc::c_char,
        size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Return a positive value if the given filename has one of the given
    /// extensions, 0 otherwise.
    ///
    /// @param filename   file name to check against the given extensions
    /// @param extensions a comma-separated list of filename extensions
    pub fn av_match_ext(
        filename: *const libc::c_char,
        extensions: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    /// Test if the given container can store a codec.
    ///
    /// @param ofmt           container to check for compatibility
    /// @param codec_id       codec to potentially store in container
    /// @param std_compliance standards compliance level, one of FF_COMPLIANCE_*
    ///
    /// @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.
    /// A negative number if this information is not available.
    pub fn avformat_query_codec(
        ofmt: *const AVOutputFormat,
        codec_id: AVCodecID,
        std_compliance: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @defgroup riff_fourcc RIFF FourCCs
    /// @{
    /// Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are
    /// meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the
    /// following code:
    /// @code
    /// uint32_t tag = MKTAG('H', '2', '6', '4');
    /// const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };
    /// enum AVCodecID id = av_codec_get_id(table, tag);
    /// @endcode
    /// /
    /// /**
    /// @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID.
    pub fn avformat_get_riff_video_tags() -> *const AVCodecTag;
}
extern "C" {
    /// @return the table mapping RIFF FourCCs for audio to AVCodecID.
    pub fn avformat_get_riff_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    /// @return the table mapping MOV FourCCs for video to libavcodec AVCodecID.
    pub fn avformat_get_mov_video_tags() -> *const AVCodecTag;
}
extern "C" {
    /// @return the table mapping MOV FourCCs for audio to AVCodecID.
    pub fn avformat_get_mov_audio_tags() -> *const AVCodecTag;
}
extern "C" {
    /// Guess the sample aspect ratio of a frame, based on both the stream and the
    /// frame aspect ratio.
    ///
    /// Since the frame aspect ratio is set by the codec but the stream aspect ratio
    /// is set by the demuxer, these two may not be equal. This function tries to
    /// return the value that you should use if you would like to display the frame.
    ///
    /// Basic logic is to use the stream aspect ratio if it is set to something sane
    /// otherwise use the frame aspect ratio. This way a container setting, which is
    /// usually easy to modify can override the coded value in the frames.
    ///
    /// @param format the format context which the stream is part of
    /// @param stream the stream which the frame is part of
    /// @param frame the frame with the aspect ratio to be determined
    /// @return the guessed (valid) sample_aspect_ratio, 0/1 if no idea
    pub fn av_guess_sample_aspect_ratio(
        format: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    /// Guess the frame rate, based on both the container and codec information.
    ///
    /// @param ctx the format context which the stream is part of
    /// @param stream the stream which the frame is part of
    /// @param frame the frame for which the frame rate should be determined, may be NULL
    /// @return the guessed (valid) frame rate, 0/1 if no idea
    pub fn av_guess_frame_rate(
        ctx: *mut AVFormatContext,
        stream: *mut AVStream,
        frame: *mut AVFrame,
    ) -> AVRational;
}
extern "C" {
    /// Check if the stream st contained in s is matched by the stream specifier
    /// spec.
    ///
    /// See the "stream specifiers" chapter in the documentation for the syntax
    /// of spec.
    ///
    /// @return  >0 if st is matched by spec;
    /// 0  if st is not matched by spec;
    /// AVERROR code if spec is invalid
    ///
    /// @note  A stream specifier can match several streams in the format.
    pub fn avformat_match_stream_specifier(
        s: *mut AVFormatContext,
        st: *mut AVStream,
        spec: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avformat_queue_attached_pictures(s: *mut AVFormatContext) -> libc::c_int;
}
extern "C" {
    /// Apply a list of bitstream filters to a packet.
    ///
    /// @param codec AVCodecContext, usually from an AVStream
    /// @param pkt the packet to apply filters to. If, on success, the returned
    /// packet has size == 0 and side_data_elems == 0, it indicates that
    /// the packet should be dropped
    /// @param bsfc a NULL-terminated list of filters to apply
    /// @return  >=0 on success;
    /// AVERROR code on failure
    pub fn av_apply_bitstream_filters(
        codec: *mut AVCodecContext,
        pkt: *mut AVPacket,
        bsfc: *mut AVBitStreamFilterContext,
    ) -> libc::c_int;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVTimebaseSource {
    AVFMT_TBCF_AUTO = -1,
    AVFMT_TBCF_DECODER = 0,
    AVFMT_TBCF_DEMUXER = 1,
    AVFMT_TBCF_R_FRAMERATE = 2,
}
extern "C" {
    /// Transfer internal timing information from one stream to another.
    ///
    /// This function is useful when doing stream copy.
    ///
    /// @param ofmt     target output format for ost
    /// @param ost      output stream which needs timings copy and adjustments
    /// @param ist      reference input stream to copy timings from
    /// @param copy_tb  define from where the stream codec timebase needs to be imported
    pub fn avformat_transfer_internal_stream_timing_info(
        ofmt: *const AVOutputFormat,
        ost: *mut AVStream,
        ist: *const AVStream,
        copy_tb: AVTimebaseSource,
    ) -> libc::c_int;
}
extern "C" {
    /// Get the internal codec timebase from a stream.
    ///
    /// @param st  input stream to extract the timebase from
    pub fn av_stream_get_codec_timebase(st: *const AVStream) -> AVRational;
}
extern "C" {
    /// Return the LIBAVDEVICE_VERSION_INT constant.
    pub fn avdevice_version() -> libc::c_uint;
}
extern "C" {
    /// Return the libavdevice build-time configuration.
    pub fn avdevice_configuration() -> *const libc::c_char;
}
extern "C" {
    /// Return the libavdevice license.
    pub fn avdevice_license() -> *const libc::c_char;
}
extern "C" {
    /// Initialize libavdevice and register all the input and output devices.
    pub fn avdevice_register_all();
}
extern "C" {
    /// Audio input devices iterator.
    ///
    /// If d is NULL, returns the first registered input audio/video device,
    /// if d is non-NULL, returns the next registered input audio/video device after d
    /// or NULL if d is the last one.
    pub fn av_input_audio_device_next(d: *mut AVInputFormat) -> *mut AVInputFormat;
}
extern "C" {
    /// Video input devices iterator.
    ///
    /// If d is NULL, returns the first registered input audio/video device,
    /// if d is non-NULL, returns the next registered input audio/video device after d
    /// or NULL if d is the last one.
    pub fn av_input_video_device_next(d: *mut AVInputFormat) -> *mut AVInputFormat;
}
extern "C" {
    /// Audio output devices iterator.
    ///
    /// If d is NULL, returns the first registered output audio/video device,
    /// if d is non-NULL, returns the next registered output audio/video device after d
    /// or NULL if d is the last one.
    pub fn av_output_audio_device_next(d: *mut AVOutputFormat) -> *mut AVOutputFormat;
}
extern "C" {
    /// Video output devices iterator.
    ///
    /// If d is NULL, returns the first registered output audio/video device,
    /// if d is non-NULL, returns the next registered output audio/video device after d
    /// or NULL if d is the last one.
    pub fn av_output_video_device_next(d: *mut AVOutputFormat) -> *mut AVOutputFormat;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDeviceRect {
    /// < x coordinate of top left corner
    pub x: libc::c_int,
    /// < y coordinate of top left corner
    pub y: libc::c_int,
    /// < width
    pub width: libc::c_int,
    /// < height
    pub height: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVDeviceRect() {
    assert_eq!(
        ::std::mem::size_of::<AVDeviceRect>(),
        16usize,
        concat!("Size of: ", stringify!(AVDeviceRect))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDeviceRect>(),
        4usize,
        concat!("Alignment of ", stringify!(AVDeviceRect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceRect>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceRect>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceRect>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceRect),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceRect>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceRect),
            "::",
            stringify!(height)
        )
    );
}
#[repr(u32)]
/// Message types used by avdevice_app_to_dev_control_message().
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVAppToDevMessageType {
    AV_APP_TO_DEV_NONE = 1313820229,
    AV_APP_TO_DEV_WINDOW_SIZE = 1195724621,
    AV_APP_TO_DEV_WINDOW_REPAINT = 1380274241,
    AV_APP_TO_DEV_PAUSE = 1346458912,
    AV_APP_TO_DEV_PLAY = 1347174745,
    AV_APP_TO_DEV_TOGGLE_PAUSE = 1346458964,
    AV_APP_TO_DEV_SET_VOLUME = 1398165324,
    AV_APP_TO_DEV_MUTE = 541939028,
    AV_APP_TO_DEV_UNMUTE = 1431131476,
    AV_APP_TO_DEV_TOGGLE_MUTE = 1414354260,
    AV_APP_TO_DEV_GET_VOLUME = 1196838732,
    AV_APP_TO_DEV_GET_MUTE = 1196250452,
}
#[repr(u32)]
/// Message types used by avdevice_dev_to_app_control_message().
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVDevToAppMessageType {
    AV_DEV_TO_APP_NONE = 1313820229,
    AV_DEV_TO_APP_CREATE_WINDOW_BUFFER = 1111708229,
    AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER = 1112560197,
    AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER = 1111771475,
    AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER = 1111770451,
    AV_DEV_TO_APP_BUFFER_OVERFLOW = 1112491596,
    AV_DEV_TO_APP_BUFFER_UNDERFLOW = 1112884812,
    AV_DEV_TO_APP_BUFFER_READABLE = 1112687648,
    AV_DEV_TO_APP_BUFFER_WRITABLE = 1113018912,
    AV_DEV_TO_APP_MUTE_STATE_CHANGED = 1129141588,
    AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED = 1129729868,
}
extern "C" {
    /// Send control message from application to device.
    ///
    /// @param s         device context.
    /// @param type      message type.
    /// @param data      message data. Exact type depends on message type.
    /// @param data_size size of message data.
    /// @return >= 0 on success, negative on error.
    /// AVERROR(ENOSYS) when device doesn't implement handler of the message.
    pub fn avdevice_app_to_dev_control_message(
        s: *mut AVFormatContext,
        type_: AVAppToDevMessageType,
        data: *mut libc::c_void,
        data_size: usize,
    ) -> libc::c_int;
}
extern "C" {
    /// Send control message from device to application.
    ///
    /// @param s         device context.
    /// @param type      message type.
    /// @param data      message data. Can be NULL.
    /// @param data_size size of message data.
    /// @return >= 0 on success, negative on error.
    /// AVERROR(ENOSYS) when application doesn't implement handler of the message.
    pub fn avdevice_dev_to_app_control_message(
        s: *mut AVFormatContext,
        type_: AVDevToAppMessageType,
        data: *mut libc::c_void,
        data_size: usize,
    ) -> libc::c_int;
}
/// Structure describes device capabilities.
///
/// It is used by devices in conjunction with av_device_capabilities AVOption table
/// to implement capabilities probing API based on AVOption API. Should not be used directly.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDeviceCapabilitiesQuery {
    pub av_class: *const AVClass,
    pub device_context: *mut AVFormatContext,
    pub codec: AVCodecID,
    pub sample_format: AVSampleFormat,
    pub pixel_format: AVPixelFormat,
    pub sample_rate: libc::c_int,
    pub channels: libc::c_int,
    pub channel_layout: i64,
    pub window_width: libc::c_int,
    pub window_height: libc::c_int,
    pub frame_width: libc::c_int,
    pub frame_height: libc::c_int,
    pub fps: AVRational,
}
#[test]
fn bindgen_test_layout_AVDeviceCapabilitiesQuery() {
    assert_eq!(
        ::std::mem::size_of::<AVDeviceCapabilitiesQuery>(),
        72usize,
        concat!("Size of: ", stringify!(AVDeviceCapabilitiesQuery))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDeviceCapabilitiesQuery>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDeviceCapabilitiesQuery))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).av_class as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).device_context as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(device_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).codec as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(codec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).sample_format as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(sample_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).pixel_format as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(pixel_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).sample_rate as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).channels as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).channel_layout as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).window_width as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(window_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).window_height as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(window_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).frame_width as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(frame_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).frame_height as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(frame_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceCapabilitiesQuery>())).fps as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceCapabilitiesQuery),
            "::",
            stringify!(fps)
        )
    );
}
extern "C" {
    pub static mut av_device_capabilities: [AVOption; 0usize];
}
extern "C" {
    /// Initialize capabilities probing API based on AVOption API.
    ///
    /// avdevice_capabilities_free() must be called when query capabilities API is
    /// not used anymore.
    ///
    /// @param[out] caps      Device capabilities data. Pointer to a NULL pointer must be passed.
    /// @param s              Context of the device.
    /// @param device_options An AVDictionary filled with device-private options.
    /// On return this parameter will be destroyed and replaced with a dict
    /// containing options that were not found. May be NULL.
    /// The same options must be passed later to avformat_write_header() for output
    /// devices or avformat_open_input() for input devices, or at any other place
    /// that affects device-private options.
    ///
    /// @return >= 0 on success, negative otherwise.
    pub fn avdevice_capabilities_create(
        caps: *mut *mut AVDeviceCapabilitiesQuery,
        s: *mut AVFormatContext,
        device_options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    /// Free resources created by avdevice_capabilities_create()
    ///
    /// @param caps Device capabilities data to be freed.
    /// @param s    Context of the device.
    pub fn avdevice_capabilities_free(
        caps: *mut *mut AVDeviceCapabilitiesQuery,
        s: *mut AVFormatContext,
    );
}
/// Structure describes basic parameters of the device.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDeviceInfo {
    /// < device name, format depends on device
    pub device_name: *mut libc::c_char,
    /// < human friendly name
    pub device_description: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout_AVDeviceInfo() {
    assert_eq!(
        ::std::mem::size_of::<AVDeviceInfo>(),
        16usize,
        concat!("Size of: ", stringify!(AVDeviceInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDeviceInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDeviceInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceInfo>())).device_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfo),
            "::",
            stringify!(device_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceInfo>())).device_description as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfo),
            "::",
            stringify!(device_description)
        )
    );
}
/// List of devices.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVDeviceInfoList {
    /// < list of autodetected devices
    pub devices: *mut *mut AVDeviceInfo,
    /// < number of autodetected devices
    pub nb_devices: libc::c_int,
    /// < index of default device or -1 if no default
    pub default_device: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVDeviceInfoList() {
    assert_eq!(
        ::std::mem::size_of::<AVDeviceInfoList>(),
        16usize,
        concat!("Size of: ", stringify!(AVDeviceInfoList))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDeviceInfoList>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDeviceInfoList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceInfoList>())).devices as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfoList),
            "::",
            stringify!(devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceInfoList>())).nb_devices as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfoList),
            "::",
            stringify!(nb_devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDeviceInfoList>())).default_device as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDeviceInfoList),
            "::",
            stringify!(default_device)
        )
    );
}
extern "C" {
    /// List devices.
    ///
    /// Returns available device names and their parameters.
    ///
    /// @note: Some devices may accept system-dependent device names that cannot be
    /// autodetected. The list returned by this function cannot be assumed to
    /// be always completed.
    ///
    /// @param s                device context.
    /// @param[out] device_list list of autodetected devices.
    /// @return count of autodetected devices, negative on error.
    pub fn avdevice_list_devices(
        s: *mut AVFormatContext,
        device_list: *mut *mut AVDeviceInfoList,
    ) -> libc::c_int;
}
extern "C" {
    /// Convenient function to free result of avdevice_list_devices().
    ///
    /// @param devices device list to be freed.
    pub fn avdevice_free_list_devices(device_list: *mut *mut AVDeviceInfoList);
}
extern "C" {
    /// List devices.
    ///
    /// Returns available device names and their parameters.
    /// These are convinient wrappers for avdevice_list_devices().
    /// Device context is allocated and deallocated internally.
    ///
    /// @param device           device format. May be NULL if device name is set.
    /// @param device_name      device name. May be NULL if device format is set.
    /// @param device_options   An AVDictionary filled with device-private options. May be NULL.
    /// The same options must be passed later to avformat_write_header() for output
    /// devices or avformat_open_input() for input devices, or at any other place
    /// that affects device-private options.
    /// @param[out] device_list list of autodetected devices
    /// @return count of autodetected devices, negative on error.
    /// @note device argument takes precedence over device_name when both are set.
    pub fn avdevice_list_input_sources(
        device: *mut AVInputFormat,
        device_name: *const libc::c_char,
        device_options: *mut AVDictionary,
        device_list: *mut *mut AVDeviceInfoList,
    ) -> libc::c_int;
}
extern "C" {
    pub fn avdevice_list_output_sinks(
        device: *mut AVOutputFormat,
        device_name: *const libc::c_char,
        device_options: *mut AVDictionary,
        device_list: *mut *mut AVDeviceInfoList,
    ) -> libc::c_int;
}
extern "C" {
    /// Return the LIBAVFILTER_VERSION_INT constant.
    pub fn avfilter_version() -> libc::c_uint;
}
extern "C" {
    /// Return the libavfilter build-time configuration.
    pub fn avfilter_configuration() -> *const libc::c_char;
}
extern "C" {
    /// Return the libavfilter license.
    pub fn avfilter_license() -> *const libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterPad {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterFormats {
    _unused: [u8; 0],
}
extern "C" {
    /// Get the number of elements in a NULL-terminated array of AVFilterPads (e.g.
    /// AVFilter.inputs/outputs).
    pub fn avfilter_pad_count(pads: *const AVFilterPad) -> libc::c_int;
}
extern "C" {
    /// Get the name of an AVFilterPad.
    ///
    /// @param pads an array of AVFilterPads
    /// @param pad_idx index of the pad in the array it; is the caller's
    /// responsibility to ensure the index is valid
    ///
    /// @return name of the pad_idx'th pad in pads
    pub fn avfilter_pad_get_name(
        pads: *const AVFilterPad,
        pad_idx: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    /// Get the type of an AVFilterPad.
    ///
    /// @param pads an array of AVFilterPads
    /// @param pad_idx index of the pad in the array; it is the caller's
    /// responsibility to ensure the index is valid
    ///
    /// @return type of the pad_idx'th pad in pads
    pub fn avfilter_pad_get_type(pads: *const AVFilterPad, pad_idx: libc::c_int) -> AVMediaType;
}
/// Filter definition. This defines the pads a filter contains, and all the
/// callback functions used to interact with the filter.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFilter {
    /// Filter name. Must be non-NULL and unique among filters.
    pub name: *const libc::c_char,
    /// A description of the filter. May be NULL.
    ///
    /// You should use the NULL_IF_CONFIG_SMALL() macro to define it.
    pub description: *const libc::c_char,
    /// List of inputs, terminated by a zeroed element.
    ///
    /// NULL if there are no (static) inputs. Instances of filters with
    /// AVFILTER_FLAG_DYNAMIC_INPUTS set may have more inputs than present in
    /// this list.
    pub inputs: *const AVFilterPad,
    /// List of outputs, terminated by a zeroed element.
    ///
    /// NULL if there are no (static) outputs. Instances of filters with
    /// AVFILTER_FLAG_DYNAMIC_OUTPUTS set may have more outputs than present in
    /// this list.
    pub outputs: *const AVFilterPad,
    /// A class for the private data, used to declare filter private AVOptions.
    /// This field is NULL for filters that do not declare any options.
    ///
    /// If this field is non-NULL, the first member of the filter private data
    /// must be a pointer to AVClass, which will be set by libavfilter generic
    /// code to this class.
    pub priv_class: *const AVClass,
    /// A combination of AVFILTER_FLAG_*
    pub flags: libc::c_int,
    /// Filter pre-initialization function
    ///
    /// This callback will be called immediately after the filter context is
    /// allocated, to allow allocating and initing sub-objects.
    ///
    /// If this callback is not NULL, the uninit callback will be called on
    /// allocation failure.
    ///
    /// @return 0 on success,
    /// AVERROR code on failure (but the code will be
    /// dropped and treated as ENOMEM by the calling code)
    pub preinit:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVFilterContext) -> libc::c_int>,
    /// Filter initialization function.
    ///
    /// This callback will be called only once during the filter lifetime, after
    /// all the options have been set, but before links between filters are
    /// established and format negotiation is done.
    ///
    /// Basic filter initialization should be done here. Filters with dynamic
    /// inputs and/or outputs should create those inputs/outputs here based on
    /// provided options. No more changes to this filter's inputs/outputs can be
    /// done after this callback.
    ///
    /// This callback must not assume that the filter links exist or frame
    /// parameters are known.
    ///
    /// @ref AVFilter.uninit "uninit" is guaranteed to be called even if
    /// initialization fails, so this callback does not have to clean up on
    /// failure.
    ///
    /// @return 0 on success, a negative AVERROR on failure
    pub init: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVFilterContext) -> libc::c_int>,
    /// Should be set instead of @ref AVFilter.init "init" by the filters that
    /// want to pass a dictionary of AVOptions to nested contexts that are
    /// allocated during init.
    ///
    /// On return, the options dict should be freed and replaced with one that
    /// contains all the options which could not be processed by this filter (or
    /// with NULL if all the options were processed).
    ///
    /// Otherwise the semantics is the same as for @ref AVFilter.init "init".
    pub init_dict: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVFilterContext, options: *mut *mut AVDictionary)
            -> libc::c_int,
    >,
    /// Filter uninitialization function.
    ///
    /// Called only once right before the filter is freed. Should deallocate any
    /// memory held by the filter, release any buffer references, etc. It does
    /// not need to deallocate the AVFilterContext.priv memory itself.
    ///
    /// This callback may be called even if @ref AVFilter.init "init" was not
    /// called or failed, so it must be prepared to handle such a situation.
    pub uninit: ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVFilterContext)>,
    /// Query formats supported by the filter on its inputs and outputs.
    ///
    /// This callback is called after the filter is initialized (so the inputs
    /// and outputs are fixed), shortly before the format negotiation. This
    /// callback may be called more than once.
    ///
    /// This callback must set AVFilterLink.out_formats on every input link and
    /// AVFilterLink.in_formats on every output link to a list of pixel/sample
    /// formats that the filter supports on that link. For audio links, this
    /// filter must also set @ref AVFilterLink.in_samplerates "in_samplerates" /
    /// @ref AVFilterLink.out_samplerates "out_samplerates" and
    /// @ref AVFilterLink.in_channel_layouts "in_channel_layouts" /
    /// @ref AVFilterLink.out_channel_layouts "out_channel_layouts" analogously.
    ///
    /// This callback may be NULL for filters with one input, in which case
    /// libavfilter assumes that it supports all input formats and preserves
    /// them on output.
    ///
    /// @return zero on success, a negative value corresponding to an
    /// AVERROR code otherwise
    pub query_formats:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut AVFilterContext) -> libc::c_int>,
    /// < size of private data to allocate for the filter
    pub priv_size: libc::c_int,
    /// < Additional flags for avfilter internal use only.
    pub flags_internal: libc::c_int,
    /// Used by the filter registration system. Must not be touched by any other
    /// code.
    pub next: *mut AVFilter,
    /// Make the filter instance process a command.
    ///
    /// @param cmd    the command to process, for handling simplicity all commands must be alphanumeric only
    /// @param arg    the argument for the command
    /// @param res    a buffer with size res_size where the filter(s) can return a response. This must not change when the command is not supported.
    /// @param flags  if AVFILTER_CMD_FLAG_FAST is set and the command would be
    /// time consuming then a filter should treat it like an unsupported command
    ///
    /// @returns >=0 on success otherwise an error code.
    /// AVERROR(ENOSYS) on unsupported commands
    pub process_command: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut AVFilterContext,
            cmd: *const libc::c_char,
            arg: *const libc::c_char,
            res: *mut libc::c_char,
            res_len: libc::c_int,
            flags: libc::c_int,
        ) -> libc::c_int,
    >,
    /// Filter initialization function, alternative to the init()
    /// callback. Args contains the user-supplied parameters, opaque is
    /// used for providing binary data.
    pub init_opaque: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut AVFilterContext, opaque: *mut libc::c_void) -> libc::c_int,
    >,
    /// Filter activation function.
    ///
    /// Called when any processing is needed from the filter, instead of any
    /// filter_frame and request_frame on pads.
    ///
    /// The function must examine inlinks and outlinks and perform a single
    /// step of processing. If there is nothing to do, the function must do
    /// nothing and not return an error. If more steps are or may be
    /// possible, it must use ff_filter_set_ready() to schedule another
    /// activation.
    pub activate:
        ::std::option::Option<unsafe extern "C" fn(ctx: *mut AVFilterContext) -> libc::c_int>,
}
#[test]
fn bindgen_test_layout_AVFilter() {
    assert_eq!(
        ::std::mem::size_of::<AVFilter>(),
        128usize,
        concat!("Size of: ", stringify!(AVFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).description as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).inputs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).outputs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(outputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).priv_class as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(priv_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).preinit as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(preinit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).init as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).init_dict as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(init_dict)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).uninit as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(uninit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).query_formats as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(query_formats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).priv_size as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(priv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).flags_internal as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(flags_internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).next as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).process_command as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(process_command)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).init_opaque as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(init_opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilter>())).activate as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilter),
            "::",
            stringify!(activate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterInternal {
    _unused: [u8; 0],
}
/// An instance of a filter
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFilterContext {
    /// < needed for av_log() and filters common options
    pub av_class: *const AVClass,
    /// < the AVFilter of which this is an instance
    pub filter: *const AVFilter,
    /// < name of this filter instance
    pub name: *mut libc::c_char,
    /// < array of input pads
    pub input_pads: *mut AVFilterPad,
    /// < array of pointers to input links
    pub inputs: *mut *mut AVFilterLink,
    /// < number of input pads
    pub nb_inputs: libc::c_uint,
    /// < array of output pads
    pub output_pads: *mut AVFilterPad,
    /// < array of pointers to output links
    pub outputs: *mut *mut AVFilterLink,
    /// < number of output pads
    pub nb_outputs: libc::c_uint,
    /// < private data for use by the filter
    pub priv_: *mut libc::c_void,
    /// < filtergraph this filter belongs to
    pub graph: *mut AVFilterGraph,
    /// Type of multithreading being allowed/used. A combination of
    /// AVFILTER_THREAD_* flags.
    ///
    /// May be set by the caller before initializing the filter to forbid some
    /// or all kinds of multithreading for this filter. The default is allowing
    /// everything.
    ///
    /// When the filter is initialized, this field is combined using bit AND with
    /// AVFilterGraph.thread_type to get the final mask used for determining
    /// allowed threading types. I.e. a threading type needs to be set in both
    /// to be allowed.
    ///
    /// After the filter is initialized, libavfilter sets this field to the
    /// threading type that is actually used (0 for no multithreading).
    pub thread_type: libc::c_int,
    /// An opaque struct for libavfilter internal use.
    pub internal: *mut AVFilterInternal,
    pub command_queue: *mut AVFilterCommand,
    /// < enable expression string
    pub enable_str: *mut libc::c_char,
    /// < parsed expression (AVExpr*)
    pub enable: *mut libc::c_void,
    /// < variable values for the enable expression
    pub var_values: *mut f64,
    /// < the enabled state from the last expression evaluation
    pub is_disabled: libc::c_int,
    /// For filters which will create hardware frames, sets the device the
    /// filter should create them in.  All other filters will ignore this field:
    /// in particular, a filter which consumes or processes hardware frames will
    /// instead use the hw_frames_ctx field in AVFilterLink to carry the
    /// hardware context information.
    pub hw_device_ctx: *mut AVBufferRef,
    /// Max number of threads allowed in this filter instance.
    /// If <= 0, its value is ignored.
    /// Overrides global number of threads set per filter graph.
    pub nb_threads: libc::c_int,
    /// Ready status of the filter.
    /// A non-0 value means that the filter needs activating;
    /// a higher value suggests a more urgent activation.
    pub ready: libc::c_uint,
}
#[test]
fn bindgen_test_layout_AVFilterContext() {
    assert_eq!(
        ::std::mem::size_of::<AVFilterContext>(),
        160usize,
        concat!("Size of: ", stringify!(AVFilterContext))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterContext>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).filter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(filter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).input_pads as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(input_pads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).inputs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).nb_inputs as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(nb_inputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).output_pads as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(output_pads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).outputs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(outputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).nb_outputs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(nb_outputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).priv_ as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).graph as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).thread_type as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(thread_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).internal as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).command_queue as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(command_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).enable_str as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(enable_str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).enable as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).var_values as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(var_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).is_disabled as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(is_disabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).hw_device_ctx as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(hw_device_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).nb_threads as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(nb_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterContext>())).ready as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterContext),
            "::",
            stringify!(ready)
        )
    );
}
/// A link between two filters. This contains pointers to the source and
/// destination filters between which this link exists, and the indexes of
/// the pads involved. In addition, this link also contains the parameters
/// which have been negotiated and agreed upon between the filter, such as
/// image dimensions, format, etc.
///
/// Applications must not normally access the link structure directly.
/// Use the buffersrc and buffersink API instead.
/// In the future, access to the header may be reserved for filters
/// implementation.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVFilterLink {
    /// < source filter
    pub src: *mut AVFilterContext,
    /// < output pad on the source filter
    pub srcpad: *mut AVFilterPad,
    /// < dest filter
    pub dst: *mut AVFilterContext,
    /// < input pad on the dest filter
    pub dstpad: *mut AVFilterPad,
    /// < filter media type
    pub type_: AVMediaType,
    /// < agreed upon image width
    pub w: libc::c_int,
    /// < agreed upon image height
    pub h: libc::c_int,
    /// < agreed upon sample aspect ratio
    pub sample_aspect_ratio: AVRational,
    /// < channel layout of current buffer (see libavutil/channel_layout.h)
    pub channel_layout: u64,
    /// < samples per second
    pub sample_rate: libc::c_int,
    /// < agreed upon media format
    pub format: libc::c_int,
    /// Define the time base used by the PTS of the frames/samples
    /// which will pass through this link.
    /// During the configuration stage, each filter is supposed to
    /// change only the output timebase, while the timebase of the
    /// input link is assumed to be an unchangeable property.
    pub time_base: AVRational,
    /// All fields below this line are not part of the public API. They
    /// may not be used outside of libavfilter and can be changed and
    /// removed at will.
    /// New public fields should be added right above.
    ///
    /// /
    /// /**
    /// Lists of formats and channel layouts supported by the input and output
    /// filters respectively. These lists are used for negotiating the format
    /// to actually be used, which will be loaded into the format and
    /// channel_layout members, above, when chosen.
    ///
    pub in_formats: *mut AVFilterFormats,
    pub out_formats: *mut AVFilterFormats,
    /// Lists of channel layouts and sample rates used for automatic
    /// negotiation.
    pub in_samplerates: *mut AVFilterFormats,
    pub out_samplerates: *mut AVFilterFormats,
    pub in_channel_layouts: *mut AVFilterChannelLayouts,
    pub out_channel_layouts: *mut AVFilterChannelLayouts,
    /// Audio only, the destination filter sets this to a non-zero value to
    /// request that buffers with the given number of samples should be sent to
    /// it. AVFilterPad.needs_fifo must also be set on the corresponding input
    /// pad.
    /// Last buffer before EOF will be padded with silence.
    pub request_samples: libc::c_int,
    pub init_state: AVFilterLink__bindgen_ty_1,
    /// Graph the filter belongs to.
    pub graph: *mut AVFilterGraph,
    /// Current timestamp of the link, as defined by the most recent
    /// frame(s), in link time_base units.
    pub current_pts: i64,
    /// Current timestamp of the link, as defined by the most recent
    /// frame(s), in AV_TIME_BASE units.
    pub current_pts_us: i64,
    /// Index in the age array.
    pub age_index: libc::c_int,
    /// Frame rate of the stream on the link, or 1/0 if unknown or variable;
    /// if left to 0/0, will be automatically copied from the first input
    /// of the source filter if it exists.
    ///
    /// Sources should set it to the best estimation of the real frame rate.
    /// If the source frame rate is unknown or variable, set this to 1/0.
    /// Filters should update it if necessary depending on their function.
    /// Sinks can use it to set a default output frame rate.
    /// It is similar to the r_frame_rate field in AVStream.
    pub frame_rate: AVRational,
    /// Buffer partially filled with samples to achieve a fixed/minimum size.
    pub partial_buf: *mut AVFrame,
    /// Size of the partial buffer to allocate.
    /// Must be between min_samples and max_samples.
    pub partial_buf_size: libc::c_int,
    /// Minimum number of samples to filter at once. If filter_frame() is
    /// called with fewer samples, it will accumulate them in partial_buf.
    /// This field and the related ones must not be changed after filtering
    /// has started.
    /// If 0, all related fields are ignored.
    pub min_samples: libc::c_int,
    /// Maximum number of samples to filter at once. If filter_frame() is
    /// called with more samples, it will split them.
    pub max_samples: libc::c_int,
    /// Number of channels.
    pub channels: libc::c_int,
    /// Link processing flags.
    pub flags: libc::c_uint,
    /// Number of past frames sent through the link.
    pub frame_count_in: i64,
    /// Number of past frames sent through the link.
    pub frame_count_out: i64,
    /// A pointer to a FFFramePool struct.
    pub frame_pool: *mut libc::c_void,
    /// True if a frame is currently wanted on the output of this filter.
    /// Set when ff_request_frame() is called by the output,
    /// cleared when a frame is filtered.
    pub frame_wanted_out: libc::c_int,
    /// For hwaccel pixel formats, this should be a reference to the
    /// AVHWFramesContext describing the frames.
    pub hw_frames_ctx: *mut AVBufferRef,
    /// Internal structure members.
    /// The fields below this limit are internal for libavfilter's use
    /// and must in no way be accessed by applications.
    pub reserved: [libc::c_char; 61440usize],
}
pub const AVFilterLink_AVLINK_UNINIT: AVFilterLink__bindgen_ty_1 =
    AVFilterLink__bindgen_ty_1::AVLINK_UNINIT;
pub const AVFilterLink_AVLINK_STARTINIT: AVFilterLink__bindgen_ty_1 =
    AVFilterLink__bindgen_ty_1::AVLINK_STARTINIT;
pub const AVFilterLink_AVLINK_INIT: AVFilterLink__bindgen_ty_1 =
    AVFilterLink__bindgen_ty_1::AVLINK_INIT;
#[repr(u32)]
/// stage of the initialization of the link properties (dimensions, etc)
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVFilterLink__bindgen_ty_1 {
    AVLINK_UNINIT = 0,
    AVLINK_STARTINIT = 1,
    AVLINK_INIT = 2,
}
#[test]
fn bindgen_test_layout_AVFilterLink() {
    assert_eq!(
        ::std::mem::size_of::<AVFilterLink>(),
        61688usize,
        concat!("Size of: ", stringify!(AVFilterLink))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterLink>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterLink))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).src as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).srcpad as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(srcpad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).dst as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).dstpad as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(dstpad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).type_ as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).w as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).h as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilterLink>())).sample_aspect_ratio as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).channel_layout as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(channel_layout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).sample_rate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).format as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).time_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).in_formats as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(in_formats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).out_formats as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(out_formats)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).in_samplerates as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(in_samplerates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).out_samplerates as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(out_samplerates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).in_channel_layouts as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(in_channel_layouts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilterLink>())).out_channel_layouts as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(out_channel_layouts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).request_samples as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(request_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).init_state as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(init_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).graph as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(graph)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).current_pts as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(current_pts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).current_pts_us as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(current_pts_us)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).age_index as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(age_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).frame_rate as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).partial_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(partial_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).partial_buf_size as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(partial_buf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).min_samples as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(min_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).max_samples as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(max_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).channels as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).flags as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).frame_count_in as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_count_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).frame_count_out as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_count_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).frame_pool as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).frame_wanted_out as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(frame_wanted_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).hw_frames_ctx as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterLink>())).reserved as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterLink),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    /// Link two filters together.
    ///
    /// @param src    the source filter
    /// @param srcpad index of the output pad on the source filter
    /// @param dst    the destination filter
    /// @param dstpad index of the input pad on the destination filter
    /// @return       zero on success
    pub fn avfilter_link(
        src: *mut AVFilterContext,
        srcpad: libc::c_uint,
        dst: *mut AVFilterContext,
        dstpad: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    /// Free the link in *link, and set its pointer to NULL.
    pub fn avfilter_link_free(link: *mut *mut AVFilterLink);
}
extern "C" {
    /// Get the number of channels of a link.
    pub fn avfilter_link_get_channels(link: *mut AVFilterLink) -> libc::c_int;
}
extern "C" {
    /// Set the closed field of a link.
    /// @deprecated applications are not supposed to mess with links, they should
    /// close the sinks.
    pub fn avfilter_link_set_closed(link: *mut AVFilterLink, closed: libc::c_int);
}
extern "C" {
    /// Negotiate the media format, dimensions, etc of all inputs to a filter.
    ///
    /// @param filter the filter to negotiate the properties for its inputs
    /// @return       zero on successful negotiation
    pub fn avfilter_config_links(filter: *mut AVFilterContext) -> libc::c_int;
}
extern "C" {
    /// Make the filter instance process a command.
    /// It is recommended to use avfilter_graph_send_command().
    pub fn avfilter_process_command(
        filter: *mut AVFilterContext,
        cmd: *const libc::c_char,
        arg: *const libc::c_char,
        res: *mut libc::c_char,
        res_len: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Initialize the filter system. Register all builtin filters.
    pub fn avfilter_register_all();
}
extern "C" {
    /// Uninitialize the filter system. Unregister all filters.
    pub fn avfilter_uninit();
}
extern "C" {
    /// Register a filter. This is only needed if you plan to use
    /// avfilter_get_by_name later to lookup the AVFilter structure by name. A
    /// filter can still by instantiated with avfilter_graph_alloc_filter even if it
    /// is not registered.
    ///
    /// @param filter the filter to register
    /// @return 0 if the registration was successful, a negative value
    /// otherwise
    pub fn avfilter_register(filter: *mut AVFilter) -> libc::c_int;
}
extern "C" {
    pub fn avfilter_get_by_name(name: *const libc::c_char) -> *mut AVFilter;
}
extern "C" {
    /// Iterate over all registered filters.
    /// @return If prev is non-NULL, next registered filter after prev or NULL if
    /// prev is the last filter. If prev is NULL, return the first registered filter.
    pub fn avfilter_next(prev: *const AVFilter) -> *const AVFilter;
}
extern "C" {
    /// If filter is NULL, returns a pointer to the first registered filter pointer,
    /// if filter is non-NULL, returns the next pointer after filter.
    /// If the returned pointer points to NULL, the last registered filter
    /// was already reached.
    /// @deprecated use avfilter_next()
    pub fn av_filter_next(filter: *mut *mut AVFilter) -> *mut *mut AVFilter;
}
extern "C" {
    /// Create a filter instance.
    ///
    /// @param filter_ctx put here a pointer to the created filter context
    /// on success, NULL on failure
    /// @param filter    the filter to create an instance of
    /// @param inst_name Name to give to the new instance. Can be NULL for none.
    /// @return >= 0 in case of success, a negative error code otherwise
    /// @deprecated use avfilter_graph_alloc_filter() instead
    pub fn avfilter_open(
        filter_ctx: *mut *mut AVFilterContext,
        filter: *mut AVFilter,
        inst_name: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    /// Initialize a filter.
    ///
    /// @param filter the filter to initialize
    /// @param args   A string of parameters to use when initializing the filter.
    /// The format and meaning of this string varies by filter.
    /// @param opaque Any extra non-string data needed by the filter. The meaning
    /// of this parameter varies by filter.
    /// @return       zero on success
    pub fn avfilter_init_filter(
        filter: *mut AVFilterContext,
        args: *const libc::c_char,
        opaque: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Initialize a filter with the supplied parameters.
    ///
    /// @param ctx  uninitialized filter context to initialize
    /// @param args Options to initialize the filter with. This must be a
    /// ':'-separated list of options in the 'key=value' form.
    /// May be NULL if the options have been set directly using the
    /// AVOptions API or there are no options that need to be set.
    /// @return 0 on success, a negative AVERROR on failure
    pub fn avfilter_init_str(ctx: *mut AVFilterContext, args: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Initialize a filter with the supplied dictionary of options.
    ///
    /// @param ctx     uninitialized filter context to initialize
    /// @param options An AVDictionary filled with options for this filter. On
    /// return this parameter will be destroyed and replaced with
    /// a dict containing options that were not found. This dictionary
    /// must be freed by the caller.
    /// May be NULL, then this function is equivalent to
    /// avfilter_init_str() with the second parameter set to NULL.
    /// @return 0 on success, a negative AVERROR on failure
    ///
    /// @note This function and avfilter_init_str() do essentially the same thing,
    /// the difference is in manner in which the options are passed. It is up to the
    /// calling code to choose whichever is more preferable. The two functions also
    /// behave differently when some of the provided options are not declared as
    /// supported by the filter. In such a case, avfilter_init_str() will fail, but
    /// this function will leave those extra options in the options AVDictionary and
    /// continue as usual.
    pub fn avfilter_init_dict(
        ctx: *mut AVFilterContext,
        options: *mut *mut AVDictionary,
    ) -> libc::c_int;
}
extern "C" {
    /// Free a filter context. This will also remove the filter from its
    /// filtergraph's list of filters.
    ///
    /// @param filter the filter to free
    pub fn avfilter_free(filter: *mut AVFilterContext);
}
extern "C" {
    /// Insert a filter in the middle of an existing link.
    ///
    /// @param link the link into which the filter should be inserted
    /// @param filt the filter to be inserted
    /// @param filt_srcpad_idx the input pad on the filter to connect
    /// @param filt_dstpad_idx the output pad on the filter to connect
    /// @return     zero on success
    pub fn avfilter_insert_filter(
        link: *mut AVFilterLink,
        filt: *mut AVFilterContext,
        filt_srcpad_idx: libc::c_uint,
        filt_dstpad_idx: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    /// @return AVClass for AVFilterContext.
    ///
    /// @see av_opt_find().
    pub fn avfilter_get_class() -> *const AVClass;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVFilterGraphInternal {
    _unused: [u8; 0],
}
/// A function pointer passed to the @ref AVFilterGraph.execute callback to be
/// executed multiple times, possibly in parallel.
///
/// @param ctx the filter context the job belongs to
/// @param arg an opaque parameter passed through from @ref
/// AVFilterGraph.execute
/// @param jobnr the index of the job being executed
/// @param nb_jobs the total number of jobs
///
/// @return 0 on success, a negative AVERROR on error
pub type avfilter_action_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut AVFilterContext,
        arg: *mut libc::c_void,
        jobnr: libc::c_int,
        nb_jobs: libc::c_int,
    ) -> libc::c_int,
>;
/// A function executing multiple jobs, possibly in parallel.
///
/// @param ctx the filter context to which the jobs belong
/// @param func the function to be called multiple times
/// @param arg the argument to be passed to func
/// @param ret a nb_jobs-sized array to be filled with return values from each
/// invocation of func
/// @param nb_jobs the number of jobs to execute
///
/// @return 0 on success, a negative AVERROR on error
pub type avfilter_execute_func = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut AVFilterContext,
        func: avfilter_action_func,
        arg: *mut libc::c_void,
        ret: *mut libc::c_int,
        nb_jobs: libc::c_int,
    ) -> libc::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFilterGraph {
    pub av_class: *const AVClass,
    pub filters: *mut *mut AVFilterContext,
    pub nb_filters: libc::c_uint,
    /// < sws options to use for the auto-inserted scale filters
    pub scale_sws_opts: *mut libc::c_char,
    /// < libavresample options to use for the auto-inserted resample filters
    pub resample_lavr_opts: *mut libc::c_char,
    /// Type of multithreading allowed for filters in this graph. A combination
    /// of AVFILTER_THREAD_* flags.
    ///
    /// May be set by the caller at any point, the setting will apply to all
    /// filters initialized after that. The default is allowing everything.
    ///
    /// When a filter in this graph is initialized, this field is combined using
    /// bit AND with AVFilterContext.thread_type to get the final mask used for
    /// determining allowed threading types. I.e. a threading type needs to be
    /// set in both to be allowed.
    pub thread_type: libc::c_int,
    /// Maximum number of threads used by filters in this graph. May be set by
    /// the caller before adding any filters to the filtergraph. Zero (the
    /// default) means that the number of threads is determined automatically.
    pub nb_threads: libc::c_int,
    /// Opaque object for libavfilter internal use.
    pub internal: *mut AVFilterGraphInternal,
    /// Opaque user data. May be set by the caller to an arbitrary value, e.g. to
    /// be used from callbacks like @ref AVFilterGraph.execute.
    /// Libavfilter will not touch this field in any way.
    pub opaque: *mut libc::c_void,
    /// This callback may be set by the caller immediately after allocating the
    /// graph and before adding any filters to it, to provide a custom
    /// multithreading implementation.
    ///
    /// If set, filters with slice threading capability will call this callback
    /// to execute multiple jobs in parallel.
    ///
    /// If this field is left unset, libavfilter will use its internal
    /// implementation, which may or may not be multithreaded depending on the
    /// platform and build options.
    pub execute: avfilter_execute_func,
    /// < swr options to use for the auto-inserted aresample filters, Access ONLY through AVOptions
    pub aresample_swr_opts: *mut libc::c_char,
    /// Private fields
    ///
    /// The following fields are for internal use only.
    /// Their type, offset, number and semantic can change without notice.
    pub sink_links: *mut *mut AVFilterLink,
    pub sink_links_count: libc::c_int,
    pub disable_auto_convert: libc::c_uint,
}
#[test]
fn bindgen_test_layout_AVFilterGraph() {
    assert_eq!(
        ::std::mem::size_of::<AVFilterGraph>(),
        96usize,
        concat!("Size of: ", stringify!(AVFilterGraph))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterGraph>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterGraph))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).av_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(av_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).filters as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(filters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).nb_filters as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(nb_filters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).scale_sws_opts as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(scale_sws_opts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilterGraph>())).resample_lavr_opts as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(resample_lavr_opts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).thread_type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(thread_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).nb_threads as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(nb_threads)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).internal as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(internal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).opaque as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).execute as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(execute)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilterGraph>())).aresample_swr_opts as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(aresample_swr_opts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).sink_links as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(sink_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterGraph>())).sink_links_count as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(sink_links_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVFilterGraph>())).disable_auto_convert as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterGraph),
            "::",
            stringify!(disable_auto_convert)
        )
    );
}
extern "C" {
    /// Allocate a filter graph.
    ///
    /// @return the allocated filter graph on success or NULL.
    pub fn avfilter_graph_alloc() -> *mut AVFilterGraph;
}
extern "C" {
    /// Create a new filter instance in a filter graph.
    ///
    /// @param graph graph in which the new filter will be used
    /// @param filter the filter to create an instance of
    /// @param name Name to give to the new instance (will be copied to
    /// AVFilterContext.name). This may be used by the caller to identify
    /// different filters, libavfilter itself assigns no semantics to
    /// this parameter. May be NULL.
    ///
    /// @return the context of the newly created filter instance (note that it is
    /// also retrievable directly through AVFilterGraph.filters or with
    /// avfilter_graph_get_filter()) on success or NULL on failure.
    pub fn avfilter_graph_alloc_filter(
        graph: *mut AVFilterGraph,
        filter: *const AVFilter,
        name: *const libc::c_char,
    ) -> *mut AVFilterContext;
}
extern "C" {
    /// Get a filter instance identified by instance name from graph.
    ///
    /// @param graph filter graph to search through.
    /// @param name filter instance name (should be unique in the graph).
    /// @return the pointer to the found filter instance or NULL if it
    /// cannot be found.
    pub fn avfilter_graph_get_filter(
        graph: *mut AVFilterGraph,
        name: *const libc::c_char,
    ) -> *mut AVFilterContext;
}
extern "C" {
    /// Add an existing filter instance to a filter graph.
    ///
    /// @param graphctx  the filter graph
    /// @param filter the filter to be added
    ///
    /// @deprecated use avfilter_graph_alloc_filter() to allocate a filter in a
    /// filter graph
    pub fn avfilter_graph_add_filter(
        graphctx: *mut AVFilterGraph,
        filter: *mut AVFilterContext,
    ) -> libc::c_int;
}
extern "C" {
    /// Create and add a filter instance into an existing graph.
    /// The filter instance is created from the filter filt and inited
    /// with the parameters args and opaque.
    ///
    /// In case of success put in *filt_ctx the pointer to the created
    /// filter instance, otherwise set *filt_ctx to NULL.
    ///
    /// @param name the instance name to give to the created filter instance
    /// @param graph_ctx the filter graph
    /// @return a negative AVERROR error code in case of failure, a non
    /// negative value otherwise
    pub fn avfilter_graph_create_filter(
        filt_ctx: *mut *mut AVFilterContext,
        filt: *const AVFilter,
        name: *const libc::c_char,
        args: *const libc::c_char,
        opaque: *mut libc::c_void,
        graph_ctx: *mut AVFilterGraph,
    ) -> libc::c_int;
}
extern "C" {
    /// Enable or disable automatic format conversion inside the graph.
    ///
    /// Note that format conversion can still happen inside explicitly inserted
    /// scale and aresample filters.
    ///
    /// @param flags  any of the AVFILTER_AUTO_CONVERT_* constants
    pub fn avfilter_graph_set_auto_convert(graph: *mut AVFilterGraph, flags: libc::c_uint);
}
pub const AVFILTER_AUTO_CONVERT_ALL: _bindgen_ty_3 = _bindgen_ty_3::AVFILTER_AUTO_CONVERT_ALL;
pub const AVFILTER_AUTO_CONVERT_NONE: _bindgen_ty_3 = _bindgen_ty_3::AVFILTER_AUTO_CONVERT_NONE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_3 {
    AVFILTER_AUTO_CONVERT_ALL = 0,
    AVFILTER_AUTO_CONVERT_NONE = -1,
}
extern "C" {
    /// Check validity and configure all the links and formats in the graph.
    ///
    /// @param graphctx the filter graph
    /// @param log_ctx context used for logging
    /// @return >= 0 in case of success, a negative AVERROR code otherwise
    pub fn avfilter_graph_config(
        graphctx: *mut AVFilterGraph,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Free a graph, destroy its links, and set *graph to NULL.
    /// If *graph is NULL, do nothing.
    pub fn avfilter_graph_free(graph: *mut *mut AVFilterGraph);
}
/// A linked-list of the inputs/outputs of the filter chain.
///
/// This is mainly useful for avfilter_graph_parse() / avfilter_graph_parse2(),
/// where it is used to communicate open (unlinked) inputs and outputs from and
/// to the caller.
/// This struct specifies, per each not connected pad contained in the graph, the
/// filter context and the pad index required for establishing a link.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFilterInOut {
    /// unique name for this input/output in the list
    pub name: *mut libc::c_char,
    /// filter context associated to this input/output
    pub filter_ctx: *mut AVFilterContext,
    /// index of the filt_ctx pad to use for linking
    pub pad_idx: libc::c_int,
    /// next input/input in the list, NULL if this is the last
    pub next: *mut AVFilterInOut,
}
#[test]
fn bindgen_test_layout_AVFilterInOut() {
    assert_eq!(
        ::std::mem::size_of::<AVFilterInOut>(),
        32usize,
        concat!("Size of: ", stringify!(AVFilterInOut))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFilterInOut>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFilterInOut))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterInOut>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterInOut),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterInOut>())).filter_ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterInOut),
            "::",
            stringify!(filter_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterInOut>())).pad_idx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterInOut),
            "::",
            stringify!(pad_idx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFilterInOut>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFilterInOut),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    /// Allocate a single AVFilterInOut entry.
    /// Must be freed with avfilter_inout_free().
    /// @return allocated AVFilterInOut on success, NULL on failure.
    pub fn avfilter_inout_alloc() -> *mut AVFilterInOut;
}
extern "C" {
    /// Free the supplied list of AVFilterInOut and set *inout to NULL.
    /// If *inout is NULL, do nothing.
    pub fn avfilter_inout_free(inout: *mut *mut AVFilterInOut);
}
extern "C" {
    /// Add a graph described by a string to a graph.
    ///
    /// @note The caller must provide the lists of inputs and outputs,
    /// which therefore must be known before calling the function.
    ///
    /// @note The inputs parameter describes inputs of the already existing
    /// part of the graph; i.e. from the point of view of the newly created
    /// part, they are outputs. Similarly the outputs parameter describes
    /// outputs of the already existing filters, which are provided as
    /// inputs to the parsed filters.
    ///
    /// @param graph   the filter graph where to link the parsed graph context
    /// @param filters string to be parsed
    /// @param inputs  linked list to the inputs of the graph
    /// @param outputs linked list to the outputs of the graph
    /// @return zero on success, a negative AVERROR code on error
    pub fn avfilter_graph_parse(
        graph: *mut AVFilterGraph,
        filters: *const libc::c_char,
        inputs: *mut AVFilterInOut,
        outputs: *mut AVFilterInOut,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Add a graph described by a string to a graph.
    ///
    /// In the graph filters description, if the input label of the first
    /// filter is not specified, "in" is assumed; if the output label of
    /// the last filter is not specified, "out" is assumed.
    ///
    /// @param graph   the filter graph where to link the parsed graph context
    /// @param filters string to be parsed
    /// @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.
    /// If non-NULL, *inputs is updated to contain the list of open inputs
    /// after the parsing, should be freed with avfilter_inout_free().
    /// @param outputs pointer to a linked list to the outputs of the graph, may be NULL.
    /// If non-NULL, *outputs is updated to contain the list of open outputs
    /// after the parsing, should be freed with avfilter_inout_free().
    /// @return non negative on success, a negative AVERROR code on error
    pub fn avfilter_graph_parse_ptr(
        graph: *mut AVFilterGraph,
        filters: *const libc::c_char,
        inputs: *mut *mut AVFilterInOut,
        outputs: *mut *mut AVFilterInOut,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Add a graph described by a string to a graph.
    ///
    /// @param[in]  graph   the filter graph where to link the parsed graph context
    /// @param[in]  filters string to be parsed
    /// @param[out] inputs  a linked list of all free (unlinked) inputs of the
    /// parsed graph will be returned here. It is to be freed
    /// by the caller using avfilter_inout_free().
    /// @param[out] outputs a linked list of all free (unlinked) outputs of the
    /// parsed graph will be returned here. It is to be freed by the
    /// caller using avfilter_inout_free().
    /// @return zero on success, a negative AVERROR code on error
    ///
    /// @note This function returns the inputs and outputs that are left
    /// unlinked after parsing the graph and the caller then deals with
    /// them.
    /// @note This function makes no reference whatsoever to already
    /// existing parts of the graph and the inputs parameter will on return
    /// contain inputs of the newly parsed part of the graph.  Analogously
    /// the outputs parameter will contain outputs of the newly created
    /// filters.
    pub fn avfilter_graph_parse2(
        graph: *mut AVFilterGraph,
        filters: *const libc::c_char,
        inputs: *mut *mut AVFilterInOut,
        outputs: *mut *mut AVFilterInOut,
    ) -> libc::c_int;
}
extern "C" {
    /// Send a command to one or more filter instances.
    ///
    /// @param graph  the filter graph
    /// @param target the filter(s) to which the command should be sent
    /// "all" sends to all filters
    /// otherwise it can be a filter or filter instance name
    /// which will send the command to all matching filters.
    /// @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only
    /// @param arg    the argument for the command
    /// @param res    a buffer with size res_size where the filter(s) can return a response.
    ///
    /// @returns >=0 on success otherwise an error code.
    /// AVERROR(ENOSYS) on unsupported commands
    pub fn avfilter_graph_send_command(
        graph: *mut AVFilterGraph,
        target: *const libc::c_char,
        cmd: *const libc::c_char,
        arg: *const libc::c_char,
        res: *mut libc::c_char,
        res_len: libc::c_int,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Queue a command for one or more filter instances.
    ///
    /// @param graph  the filter graph
    /// @param target the filter(s) to which the command should be sent
    /// "all" sends to all filters
    /// otherwise it can be a filter or filter instance name
    /// which will send the command to all matching filters.
    /// @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only
    /// @param arg    the argument for the command
    /// @param ts     time at which the command should be sent to the filter
    ///
    /// @note As this executes commands after this function returns, no return code
    /// from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.
    pub fn avfilter_graph_queue_command(
        graph: *mut AVFilterGraph,
        target: *const libc::c_char,
        cmd: *const libc::c_char,
        arg: *const libc::c_char,
        flags: libc::c_int,
        ts: f64,
    ) -> libc::c_int;
}
extern "C" {
    /// Dump a graph into a human-readable string representation.
    ///
    /// @param graph    the graph to dump
    /// @param options  formatting options; currently ignored
    /// @return  a string, or NULL in case of memory allocation failure;
    /// the string must be freed using av_free
    pub fn avfilter_graph_dump(
        graph: *mut AVFilterGraph,
        options: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    /// Request a frame on the oldest sink link.
    ///
    /// If the request returns AVERROR_EOF, try the next.
    ///
    /// Note that this function is not meant to be the sole scheduling mechanism
    /// of a filtergraph, only a convenience function to help drain a filtergraph
    /// in a balanced way under normal circumstances.
    ///
    /// Also note that AVERROR_EOF does not mean that frames did not arrive on
    /// some of the sinks during the process.
    /// When there are multiple sink links, in case the requested link
    /// returns an EOF, this may cause a filter to flush pending frames
    /// which are sent to another sink link, although unrequested.
    ///
    /// @return  the return value of ff_request_frame(),
    /// or AVERROR_EOF if all links returned AVERROR_EOF
    pub fn avfilter_graph_request_oldest(graph: *mut AVFilterGraph) -> libc::c_int;
}
extern "C" {
    /// Get a frame with filtered data from sink and put it in frame.
    ///
    /// @param ctx    pointer to a buffersink or abuffersink filter context.
    /// @param frame  pointer to an allocated frame that will be filled with data.
    /// The data must be freed using av_frame_unref() / av_frame_free()
    /// @param flags  a combination of AV_BUFFERSINK_FLAG_* flags
    ///
    /// @return  >= 0 in for success, a negative AVERROR code for failure.
    pub fn av_buffersink_get_frame_flags(
        ctx: *mut AVFilterContext,
        frame: *mut AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
/// Struct to use for initializing a buffersink context.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBufferSinkParams {
    /// < list of allowed pixel formats, terminated by AV_PIX_FMT_NONE
    pub pixel_fmts: *const AVPixelFormat,
}
#[test]
fn bindgen_test_layout_AVBufferSinkParams() {
    assert_eq!(
        ::std::mem::size_of::<AVBufferSinkParams>(),
        8usize,
        concat!("Size of: ", stringify!(AVBufferSinkParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBufferSinkParams>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBufferSinkParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferSinkParams>())).pixel_fmts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSinkParams),
            "::",
            stringify!(pixel_fmts)
        )
    );
}
extern "C" {
    /// Create an AVBufferSinkParams structure.
    ///
    /// Must be freed with av_free().
    pub fn av_buffersink_params_alloc() -> *mut AVBufferSinkParams;
}
/// Struct to use for initializing an abuffersink context.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVABufferSinkParams {
    /// < list of allowed sample formats, terminated by AV_SAMPLE_FMT_NONE
    pub sample_fmts: *const AVSampleFormat,
    /// < list of allowed channel layouts, terminated by -1
    pub channel_layouts: *const i64,
    /// < list of allowed channel counts, terminated by -1
    pub channel_counts: *const libc::c_int,
    /// < if not 0, accept any channel count or layout
    pub all_channel_counts: libc::c_int,
    /// < list of allowed sample rates, terminated by -1
    pub sample_rates: *mut libc::c_int,
}
#[test]
fn bindgen_test_layout_AVABufferSinkParams() {
    assert_eq!(
        ::std::mem::size_of::<AVABufferSinkParams>(),
        40usize,
        concat!("Size of: ", stringify!(AVABufferSinkParams))
    );
    assert_eq!(
        ::std::mem::align_of::<AVABufferSinkParams>(),
        8usize,
        concat!("Alignment of ", stringify!(AVABufferSinkParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVABufferSinkParams>())).sample_fmts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVABufferSinkParams),
            "::",
            stringify!(sample_fmts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVABufferSinkParams>())).channel_layouts as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVABufferSinkParams),
            "::",
            stringify!(channel_layouts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVABufferSinkParams>())).channel_counts as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVABufferSinkParams),
            "::",
            stringify!(channel_counts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVABufferSinkParams>())).all_channel_counts as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVABufferSinkParams),
            "::",
            stringify!(all_channel_counts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVABufferSinkParams>())).sample_rates as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVABufferSinkParams),
            "::",
            stringify!(sample_rates)
        )
    );
}
extern "C" {
    /// Create an AVABufferSinkParams structure.
    ///
    /// Must be freed with av_free().
    pub fn av_abuffersink_params_alloc() -> *mut AVABufferSinkParams;
}
extern "C" {
    /// Set the frame size for an audio buffer sink.
    ///
    /// All calls to av_buffersink_get_buffer_ref will return a buffer with
    /// exactly the specified number of samples, or AVERROR(EAGAIN) if there is
    /// not enough. The last buffer at EOF will be padded with 0.
    pub fn av_buffersink_set_frame_size(ctx: *mut AVFilterContext, frame_size: libc::c_uint);
}
extern "C" {
    /// @defgroup lavfi_buffersink_accessors Buffer sink accessors
    /// Get the properties of the stream
    /// @{
    pub fn av_buffersink_get_type(ctx: *const AVFilterContext) -> AVMediaType;
}
extern "C" {
    pub fn av_buffersink_get_time_base(ctx: *const AVFilterContext) -> AVRational;
}
extern "C" {
    pub fn av_buffersink_get_format(ctx: *const AVFilterContext) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_frame_rate(ctx: *const AVFilterContext) -> AVRational;
}
extern "C" {
    pub fn av_buffersink_get_w(ctx: *const AVFilterContext) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_h(ctx: *const AVFilterContext) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_sample_aspect_ratio(ctx: *const AVFilterContext) -> AVRational;
}
extern "C" {
    pub fn av_buffersink_get_channels(ctx: *const AVFilterContext) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_channel_layout(ctx: *const AVFilterContext) -> u64;
}
extern "C" {
    pub fn av_buffersink_get_sample_rate(ctx: *const AVFilterContext) -> libc::c_int;
}
extern "C" {
    pub fn av_buffersink_get_hw_frames_ctx(ctx: *const AVFilterContext) -> *mut AVBufferRef;
}
extern "C" {
    /// Get a frame with filtered data from sink and put it in frame.
    ///
    /// @param ctx pointer to a context of a buffersink or abuffersink AVFilter.
    /// @param frame pointer to an allocated frame that will be filled with data.
    /// The data must be freed using av_frame_unref() / av_frame_free()
    ///
    /// @return
    /// - >= 0 if a frame was successfully returned.
    /// - AVERROR(EAGAIN) if no frames are available at this point; more
    /// input frames must be added to the filtergraph to get more output.
    /// - AVERROR_EOF if there will be no more output frames on this sink.
    /// - A different negative AVERROR code in other failure cases.
    pub fn av_buffersink_get_frame(ctx: *mut AVFilterContext, frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    /// Same as av_buffersink_get_frame(), but with the ability to specify the number
    /// of samples read. This function is less efficient than
    /// av_buffersink_get_frame(), because it copies the data around.
    ///
    /// @param ctx pointer to a context of the abuffersink AVFilter.
    /// @param frame pointer to an allocated frame that will be filled with data.
    /// The data must be freed using av_frame_unref() / av_frame_free()
    /// frame will contain exactly nb_samples audio samples, except at
    /// the end of stream, when it can contain less than nb_samples.
    ///
    /// @return The return codes have the same meaning as for
    /// av_buffersink_get_samples().
    ///
    /// @warning do not mix this function with av_buffersink_get_frame(). Use only one or
    /// the other with a single sink, not both.
    pub fn av_buffersink_get_samples(
        ctx: *mut AVFilterContext,
        frame: *mut AVFrame,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
pub const AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT: _bindgen_ty_4 =
    _bindgen_ty_4::AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT;
pub const AV_BUFFERSRC_FLAG_PUSH: _bindgen_ty_4 = _bindgen_ty_4::AV_BUFFERSRC_FLAG_PUSH;
pub const AV_BUFFERSRC_FLAG_KEEP_REF: _bindgen_ty_4 = _bindgen_ty_4::AV_BUFFERSRC_FLAG_KEEP_REF;
#[repr(u32)]
/// @defgroup lavfi_buffersrc Buffer source API
/// @ingroup lavfi
/// @{
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_4 {
    AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1,
    AV_BUFFERSRC_FLAG_PUSH = 4,
    AV_BUFFERSRC_FLAG_KEEP_REF = 8,
}
extern "C" {
    /// Get the number of failed requests.
    ///
    /// A failed request is when the request_frame method is called while no
    /// frame is present in the buffer.
    /// The number is reset when a frame is added.
    pub fn av_buffersrc_get_nb_failed_requests(buffer_src: *mut AVFilterContext) -> libc::c_uint;
}
/// This structure contains the parameters describing the frames that will be
/// passed to this filter.
///
/// It should be allocated with av_buffersrc_parameters_alloc() and freed with
/// av_free(). All the allocated fields in it remain owned by the caller.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVBufferSrcParameters {
    /// video: the pixel format, value corresponds to enum AVPixelFormat
    /// audio: the sample format, value corresponds to enum AVSampleFormat
    pub format: libc::c_int,
    /// The timebase to be used for the timestamps on the input frames.
    pub time_base: AVRational,
    /// Video only, the display dimensions of the input frames.
    pub width: libc::c_int,
    /// Video only, the display dimensions of the input frames.
    pub height: libc::c_int,
    /// Video only, the sample (pixel) aspect ratio.
    pub sample_aspect_ratio: AVRational,
    /// Video only, the frame rate of the input video. This field must only be
    /// set to a non-zero value if input stream has a known constant framerate
    /// and should be left at its initial value if the framerate is variable or
    /// unknown.
    pub frame_rate: AVRational,
    /// Video with a hwaccel pixel format only. This should be a reference to an
    /// AVHWFramesContext instance describing the input frames.
    pub hw_frames_ctx: *mut AVBufferRef,
    /// Audio only, the audio sampling rate in samples per secon.
    pub sample_rate: libc::c_int,
    /// Audio only, the audio channel layout
    pub channel_layout: u64,
}
#[test]
fn bindgen_test_layout_AVBufferSrcParameters() {
    assert_eq!(
        ::std::mem::size_of::<AVBufferSrcParameters>(),
        64usize,
        concat!("Size of: ", stringify!(AVBufferSrcParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBufferSrcParameters>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBufferSrcParameters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferSrcParameters>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferSrcParameters>())).time_base as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(time_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferSrcParameters>())).width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBufferSrcParameters>())).height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBufferSrcParameters>())).sample_aspect_ratio as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(sample_aspect_ratio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBufferSrcParameters>())).frame_rate as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBufferSrcParameters>())).hw_frames_ctx as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(hw_frames_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBufferSrcParameters>())).sample_rate as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(sample_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBufferSrcParameters>())).channel_layout as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBufferSrcParameters),
            "::",
            stringify!(channel_layout)
        )
    );
}
extern "C" {
    /// Allocate a new AVBufferSrcParameters instance. It should be freed by the
    /// caller with av_free().
    pub fn av_buffersrc_parameters_alloc() -> *mut AVBufferSrcParameters;
}
extern "C" {
    /// Initialize the buffersrc or abuffersrc filter with the provided parameters.
    /// This function may be called multiple times, the later calls override the
    /// previous ones. Some of the parameters may also be set through AVOptions, then
    /// whatever method is used last takes precedence.
    ///
    /// @param ctx an instance of the buffersrc or abuffersrc filter
    /// @param param the stream parameters. The frames later passed to this filter
    /// must conform to those parameters. All the allocated fields in
    /// param remain owned by the caller, libavfilter will make internal
    /// copies or references when necessary.
    /// @return 0 on success, a negative AVERROR code on failure.
    pub fn av_buffersrc_parameters_set(
        ctx: *mut AVFilterContext,
        param: *mut AVBufferSrcParameters,
    ) -> libc::c_int;
}
extern "C" {
    /// Add a frame to the buffer source.
    ///
    /// @param ctx   an instance of the buffersrc filter
    /// @param frame frame to be added. If the frame is reference counted, this
    /// function will make a new reference to it. Otherwise the frame data will be
    /// copied.
    ///
    /// @return 0 on success, a negative AVERROR on error
    ///
    /// This function is equivalent to av_buffersrc_add_frame_flags() with the
    /// AV_BUFFERSRC_FLAG_KEEP_REF flag.
    pub fn av_buffersrc_write_frame(
        ctx: *mut AVFilterContext,
        frame: *const AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    /// Add a frame to the buffer source.
    ///
    /// @param ctx   an instance of the buffersrc filter
    /// @param frame frame to be added. If the frame is reference counted, this
    /// function will take ownership of the reference(s) and reset the frame.
    /// Otherwise the frame data will be copied. If this function returns an error,
    /// the input frame is not touched.
    ///
    /// @return 0 on success, a negative AVERROR on error.
    ///
    /// @note the difference between this function and av_buffersrc_write_frame() is
    /// that av_buffersrc_write_frame() creates a new reference to the input frame,
    /// while this function takes ownership of the reference passed to it.
    ///
    /// This function is equivalent to av_buffersrc_add_frame_flags() without the
    /// AV_BUFFERSRC_FLAG_KEEP_REF flag.
    pub fn av_buffersrc_add_frame(ctx: *mut AVFilterContext, frame: *mut AVFrame) -> libc::c_int;
}
extern "C" {
    /// Add a frame to the buffer source.
    ///
    /// By default, if the frame is reference-counted, this function will take
    /// ownership of the reference(s) and reset the frame. This can be controlled
    /// using the flags.
    ///
    /// If this function returns an error, the input frame is not touched.
    ///
    /// @param buffer_src  pointer to a buffer source context
    /// @param frame       a frame, or NULL to mark EOF
    /// @param flags       a combination of AV_BUFFERSRC_FLAG_*
    /// @return            >= 0 in case of success, a negative AVERROR code
    /// in case of failure
    pub fn av_buffersrc_add_frame_flags(
        buffer_src: *mut AVFilterContext,
        frame: *mut AVFrame,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Close the buffer source after EOF.
    ///
    /// This is similar to passing NULL to av_buffersrc_add_frame_flags()
    /// except it takes the timestamp of the EOF, i.e. the timestamp of the end
    /// of the last frame.
    pub fn av_buffersrc_close(
        ctx: *mut AVFilterContext,
        pts: i64,
        flags: libc::c_uint,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVAudioResampleContext {
    _unused: [u8; 0],
}
#[repr(u32)]
/// Mixing Coefficient Types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVMixCoeffType {
    AV_MIX_COEFF_TYPE_Q8 = 0,
    AV_MIX_COEFF_TYPE_Q15 = 1,
    AV_MIX_COEFF_TYPE_FLT = 2,
    AV_MIX_COEFF_TYPE_NB = 3,
}
#[repr(u32)]
/// Resampling Filter Types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVResampleFilterType {
    AV_RESAMPLE_FILTER_TYPE_CUBIC = 0,
    AV_RESAMPLE_FILTER_TYPE_BLACKMAN_NUTTALL = 1,
    AV_RESAMPLE_FILTER_TYPE_KAISER = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVResampleDitherMethod {
    AV_RESAMPLE_DITHER_NONE = 0,
    AV_RESAMPLE_DITHER_RECTANGULAR = 1,
    AV_RESAMPLE_DITHER_TRIANGULAR = 2,
    AV_RESAMPLE_DITHER_TRIANGULAR_HP = 3,
    AV_RESAMPLE_DITHER_TRIANGULAR_NS = 4,
    AV_RESAMPLE_DITHER_NB = 5,
}
extern "C" {
    /// Return the LIBAVRESAMPLE_VERSION_INT constant.
    pub fn avresample_version() -> libc::c_uint;
}
extern "C" {
    /// Return the libavresample build-time configuration.
    /// @return  configure string
    pub fn avresample_configuration() -> *const libc::c_char;
}
extern "C" {
    /// Return the libavresample license.
    pub fn avresample_license() -> *const libc::c_char;
}
extern "C" {
    /// Get the AVClass for AVAudioResampleContext.
    ///
    /// Can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options
    /// without allocating a context.
    ///
    /// @see av_opt_find().
    ///
    /// @return AVClass for AVAudioResampleContext
    pub fn avresample_get_class() -> *const AVClass;
}
extern "C" {
    /// Allocate AVAudioResampleContext and set options.
    ///
    /// @return  allocated audio resample context, or NULL on failure
    pub fn avresample_alloc_context() -> *mut AVAudioResampleContext;
}
extern "C" {
    /// Initialize AVAudioResampleContext.
    /// @note The context must be configured using the AVOption API.
    /// @note The fields "in_channel_layout", "out_channel_layout",
    /// "in_sample_rate", "out_sample_rate", "in_sample_fmt",
    /// "out_sample_fmt" must be set.
    ///
    /// @see av_opt_set_int()
    /// @see av_opt_set_dict()
    /// @see av_get_default_channel_layout()
    ///
    /// @param avr  audio resample context
    /// @return     0 on success, negative AVERROR code on failure
    pub fn avresample_open(avr: *mut AVAudioResampleContext) -> libc::c_int;
}
extern "C" {
    /// Check whether an AVAudioResampleContext is open or closed.
    ///
    /// @param avr AVAudioResampleContext to check
    /// @return 1 if avr is open, 0 if avr is closed.
    pub fn avresample_is_open(avr: *mut AVAudioResampleContext) -> libc::c_int;
}
extern "C" {
    /// Close AVAudioResampleContext.
    ///
    /// This closes the context, but it does not change the parameters. The context
    /// can be reopened with avresample_open(). It does, however, clear the output
    /// FIFO and any remaining leftover samples in the resampling delay buffer. If
    /// there was a custom matrix being used, that is also cleared.
    ///
    /// @see avresample_convert()
    /// @see avresample_set_matrix()
    ///
    /// @param avr  audio resample context
    pub fn avresample_close(avr: *mut AVAudioResampleContext);
}
extern "C" {
    /// Free AVAudioResampleContext and associated AVOption values.
    ///
    /// This also calls avresample_close() before freeing.
    ///
    /// @param avr  audio resample context
    pub fn avresample_free(avr: *mut *mut AVAudioResampleContext);
}
extern "C" {
    /// Generate a channel mixing matrix.
    ///
    /// This function is the one used internally by libavresample for building the
    /// default mixing matrix. It is made public just as a utility function for
    /// building custom matrices.
    ///
    /// @param in_layout           input channel layout
    /// @param out_layout          output channel layout
    /// @param center_mix_level    mix level for the center channel
    /// @param surround_mix_level  mix level for the surround channel(s)
    /// @param lfe_mix_level       mix level for the low-frequency effects channel
    /// @param normalize           if 1, coefficients will be normalized to prevent
    /// overflow. if 0, coefficients will not be
    /// normalized.
    /// @param[out] matrix         mixing coefficients; matrix[i + stride * o] is
    /// the weight of input channel i in output channel o.
    /// @param stride              distance between adjacent input channels in the
    /// matrix array
    /// @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)
    /// @return                    0 on success, negative AVERROR code on failure
    pub fn avresample_build_matrix(
        in_layout: u64,
        out_layout: u64,
        center_mix_level: f64,
        surround_mix_level: f64,
        lfe_mix_level: f64,
        normalize: libc::c_int,
        matrix: *mut f64,
        stride: libc::c_int,
        matrix_encoding: AVMatrixEncoding,
    ) -> libc::c_int;
}
extern "C" {
    /// Get the current channel mixing matrix.
    ///
    /// If no custom matrix has been previously set or the AVAudioResampleContext is
    /// not open, an error is returned.
    ///
    /// @param avr     audio resample context
    /// @param matrix  mixing coefficients; matrix[i + stride * o] is the weight of
    /// input channel i in output channel o.
    /// @param stride  distance between adjacent input channels in the matrix array
    /// @return        0 on success, negative AVERROR code on failure
    pub fn avresample_get_matrix(
        avr: *mut AVAudioResampleContext,
        matrix: *mut f64,
        stride: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Set channel mixing matrix.
    ///
    /// Allows for setting a custom mixing matrix, overriding the default matrix
    /// generated internally during avresample_open(). This function can be called
    /// anytime on an allocated context, either before or after calling
    /// avresample_open(), as long as the channel layouts have been set.
    /// avresample_convert() always uses the current matrix.
    /// Calling avresample_close() on the context will clear the current matrix.
    ///
    /// @see avresample_close()
    ///
    /// @param avr     audio resample context
    /// @param matrix  mixing coefficients; matrix[i + stride * o] is the weight of
    /// input channel i in output channel o.
    /// @param stride  distance between adjacent input channels in the matrix array
    /// @return        0 on success, negative AVERROR code on failure
    pub fn avresample_set_matrix(
        avr: *mut AVAudioResampleContext,
        matrix: *const f64,
        stride: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Set a customized input channel mapping.
    ///
    /// This function can only be called when the allocated context is not open.
    /// Also, the input channel layout must have already been set.
    ///
    /// Calling avresample_close() on the context will clear the channel mapping.
    ///
    /// The map for each input channel specifies the channel index in the source to
    /// use for that particular channel, or -1 to mute the channel. Source channels
    /// can be duplicated by using the same index for multiple input channels.
    ///
    /// Examples:
    ///
    /// Reordering 5.1 AAC order (C,L,R,Ls,Rs,LFE) to FFmpeg order (L,R,C,LFE,Ls,Rs):
    /// { 1, 2, 0, 5, 3, 4 }
    ///
    /// Muting the 3rd channel in 4-channel input:
    /// { 0, 1, -1, 3 }
    ///
    /// Duplicating the left channel of stereo input:
    /// { 0, 0 }
    ///
    /// @param avr         audio resample context
    /// @param channel_map customized input channel mapping
    /// @return            0 on success, negative AVERROR code on failure
    pub fn avresample_set_channel_mapping(
        avr: *mut AVAudioResampleContext,
        channel_map: *const libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Set compensation for resampling.
    ///
    /// This can be called anytime after avresample_open(). If resampling is not
    /// automatically enabled because of a sample rate conversion, the
    /// "force_resampling" option must have been set to 1 when opening the context
    /// in order to use resampling compensation.
    ///
    /// @param avr                    audio resample context
    /// @param sample_delta           compensation delta, in samples
    /// @param compensation_distance  compensation distance, in samples
    /// @return                       0 on success, negative AVERROR code on failure
    pub fn avresample_set_compensation(
        avr: *mut AVAudioResampleContext,
        sample_delta: libc::c_int,
        compensation_distance: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Provide the upper bound on the number of samples the configured
    /// conversion would output.
    ///
    /// @param avr           audio resample context
    /// @param in_nb_samples number of input samples
    ///
    /// @return              number of samples or AVERROR(EINVAL) if the value
    /// would exceed INT_MAX
    pub fn avresample_get_out_samples(
        avr: *mut AVAudioResampleContext,
        in_nb_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Convert input samples and write them to the output FIFO.
    ///
    /// The upper bound on the number of output samples can be obtained through
    /// avresample_get_out_samples().
    ///
    /// The output data can be NULL or have fewer allocated samples than required.
    /// In this case, any remaining samples not written to the output will be added
    /// to an internal FIFO buffer, to be returned at the next call to this function
    /// or to avresample_read().
    ///
    /// If converting sample rate, there may be data remaining in the internal
    /// resampling delay buffer. avresample_get_delay() tells the number of remaining
    /// samples. To get this data as output, call avresample_convert() with NULL
    /// input.
    ///
    /// At the end of the conversion process, there may be data remaining in the
    /// internal FIFO buffer. avresample_available() tells the number of remaining
    /// samples. To get this data as output, either call avresample_convert() with
    /// NULL input or call avresample_read().
    ///
    /// @see avresample_get_out_samples()
    /// @see avresample_read()
    /// @see avresample_get_delay()
    ///
    /// @param avr             audio resample context
    /// @param output          output data pointers
    /// @param out_plane_size  output plane size, in bytes.
    /// This can be 0 if unknown, but that will lead to
    /// optimized functions not being used directly on the
    /// output, which could slow down some conversions.
    /// @param out_samples     maximum number of samples that the output buffer can hold
    /// @param input           input data pointers
    /// @param in_plane_size   input plane size, in bytes
    /// This can be 0 if unknown, but that will lead to
    /// optimized functions not being used directly on the
    /// input, which could slow down some conversions.
    /// @param in_samples      number of input samples to convert
    /// @return                number of samples written to the output buffer,
    /// not including converted samples added to the internal
    /// output FIFO
    pub fn avresample_convert(
        avr: *mut AVAudioResampleContext,
        output: *mut *mut u8,
        out_plane_size: libc::c_int,
        out_samples: libc::c_int,
        input: *const *const u8,
        in_plane_size: libc::c_int,
        in_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Return the number of samples currently in the resampling delay buffer.
    ///
    /// When resampling, there may be a delay between the input and output. Any
    /// unconverted samples in each call are stored internally in a delay buffer.
    /// This function allows the user to determine the current number of samples in
    /// the delay buffer, which can be useful for synchronization.
    ///
    /// @see avresample_convert()
    ///
    /// @param avr  audio resample context
    /// @return     number of samples currently in the resampling delay buffer
    pub fn avresample_get_delay(avr: *mut AVAudioResampleContext) -> libc::c_int;
}
extern "C" {
    /// Return the number of available samples in the output FIFO.
    ///
    /// During conversion, if the user does not specify an output buffer or
    /// specifies an output buffer that is smaller than what is needed, remaining
    /// samples that are not written to the output are stored to an internal FIFO
    /// buffer. The samples in the FIFO can be read with avresample_read() or
    /// avresample_convert().
    ///
    /// @see avresample_read()
    /// @see avresample_convert()
    ///
    /// @param avr  audio resample context
    /// @return     number of samples available for reading
    pub fn avresample_available(avr: *mut AVAudioResampleContext) -> libc::c_int;
}
extern "C" {
    /// Read samples from the output FIFO.
    ///
    /// During conversion, if the user does not specify an output buffer or
    /// specifies an output buffer that is smaller than what is needed, remaining
    /// samples that are not written to the output are stored to an internal FIFO
    /// buffer. This function can be used to read samples from that internal FIFO.
    ///
    /// @see avresample_available()
    /// @see avresample_convert()
    ///
    /// @param avr         audio resample context
    /// @param output      output data pointers. May be NULL, in which case
    /// nb_samples of data is discarded from output FIFO.
    /// @param nb_samples  number of samples to read from the FIFO
    /// @return            the number of samples written to output
    pub fn avresample_read(
        avr: *mut AVAudioResampleContext,
        output: *mut *mut u8,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Convert the samples in the input AVFrame and write them to the output AVFrame.
    ///
    /// Input and output AVFrames must have channel_layout, sample_rate and format set.
    ///
    /// The upper bound on the number of output samples is obtained through
    /// avresample_get_out_samples().
    ///
    /// If the output AVFrame does not have the data pointers allocated the nb_samples
    /// field will be set using avresample_get_out_samples() and av_frame_get_buffer()
    /// is called to allocate the frame.
    ///
    /// The output AVFrame can be NULL or have fewer allocated samples than required.
    /// In this case, any remaining samples not written to the output will be added
    /// to an internal FIFO buffer, to be returned at the next call to this function
    /// or to avresample_convert() or to avresample_read().
    ///
    /// If converting sample rate, there may be data remaining in the internal
    /// resampling delay buffer. avresample_get_delay() tells the number of
    /// remaining samples. To get this data as output, call this function or
    /// avresample_convert() with NULL input.
    ///
    /// At the end of the conversion process, there may be data remaining in the
    /// internal FIFO buffer. avresample_available() tells the number of remaining
    /// samples. To get this data as output, either call this function or
    /// avresample_convert() with NULL input or call avresample_read().
    ///
    /// If the AVAudioResampleContext configuration does not match the output and
    /// input AVFrame settings the conversion does not take place and depending on
    /// which AVFrame is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED
    /// or AVERROR_OUTPUT_CHANGED|AVERROR_INPUT_CHANGED is returned.
    ///
    /// @see avresample_get_out_samples()
    /// @see avresample_available()
    /// @see avresample_convert()
    /// @see avresample_read()
    /// @see avresample_get_delay()
    ///
    /// @param avr             audio resample context
    /// @param output          output AVFrame
    /// @param input           input AVFrame
    /// @return                0 on success, AVERROR on failure or nonmatching
    /// configuration.
    pub fn avresample_convert_frame(
        avr: *mut AVAudioResampleContext,
        output: *mut AVFrame,
        input: *mut AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    /// Configure or reconfigure the AVAudioResampleContext using the information
    /// provided by the AVFrames.
    ///
    /// The original resampling context is reset even on failure.
    /// The function calls avresample_close() internally if the context is open.
    ///
    /// @see avresample_open();
    /// @see avresample_close();
    ///
    /// @param avr             audio resample context
    /// @param out             output AVFrame
    /// @param in              input AVFrame
    /// @return                0 on success, AVERROR on failure.
    pub fn avresample_config(
        avr: *mut AVAudioResampleContext,
        out: *mut AVFrame,
        in_: *mut AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    /// Calculate the Adler32 checksum of a buffer.
    ///
    /// Passing the return value to a subsequent av_adler32_update() call
    /// allows the checksum of multiple buffers to be calculated as though
    /// they were concatenated.
    ///
    /// @param adler initial checksum value
    /// @param buf   pointer to input buffer
    /// @param len   size of input buffer
    /// @return      updated checksum
    pub fn av_adler32_update(
        adler: libc::c_ulong,
        buf: *const u8,
        len: libc::c_uint,
    ) -> libc::c_ulong;
}
extern "C" {
    pub static mut av_aes_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVAES {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate an AVAES context.
    pub fn av_aes_alloc() -> *mut AVAES;
}
extern "C" {
    /// Initialize an AVAES context.
    /// @param key_bits 128, 192 or 256
    /// @param decrypt 0 for encryption, 1 for decryption
    pub fn av_aes_init(
        a: *mut AVAES,
        key: *const u8,
        key_bits: libc::c_int,
        decrypt: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Encrypt or decrypt a buffer using a previously initialized context.
    /// @param count number of 16 byte blocks
    /// @param dst destination array, can be equal to src
    /// @param src source array, can be equal to dst
    /// @param iv initialization vector for CBC mode, if NULL then ECB will be used
    /// @param decrypt 0 for encryption, 1 for decryption
    pub fn av_aes_crypt(
        a: *mut AVAES,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFifoBuffer {
    pub buffer: *mut u8,
    pub rptr: *mut u8,
    pub wptr: *mut u8,
    pub end: *mut u8,
    pub rndx: u32,
    pub wndx: u32,
}
#[test]
fn bindgen_test_layout_AVFifoBuffer() {
    assert_eq!(
        ::std::mem::size_of::<AVFifoBuffer>(),
        40usize,
        concat!("Size of: ", stringify!(AVFifoBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<AVFifoBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(AVFifoBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFifoBuffer>())).buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFifoBuffer>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFifoBuffer>())).wptr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(wptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFifoBuffer>())).end as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFifoBuffer>())).rndx as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(rndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVFifoBuffer>())).wndx as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(AVFifoBuffer),
            "::",
            stringify!(wndx)
        )
    );
}
extern "C" {
    /// Initialize an AVFifoBuffer.
    /// @param size of FIFO
    /// @return AVFifoBuffer or NULL in case of memory allocation failure
    pub fn av_fifo_alloc(size: libc::c_uint) -> *mut AVFifoBuffer;
}
extern "C" {
    /// Initialize an AVFifoBuffer.
    /// @param nmemb number of elements
    /// @param size  size of the single element
    /// @return AVFifoBuffer or NULL in case of memory allocation failure
    pub fn av_fifo_alloc_array(nmemb: usize, size: usize) -> *mut AVFifoBuffer;
}
extern "C" {
    /// Free an AVFifoBuffer.
    /// @param f AVFifoBuffer to free
    pub fn av_fifo_free(f: *mut AVFifoBuffer);
}
extern "C" {
    /// Free an AVFifoBuffer and reset pointer to NULL.
    /// @param f AVFifoBuffer to free
    pub fn av_fifo_freep(f: *mut *mut AVFifoBuffer);
}
extern "C" {
    /// Reset the AVFifoBuffer to the state right after av_fifo_alloc, in particular it is emptied.
    /// @param f AVFifoBuffer to reset
    pub fn av_fifo_reset(f: *mut AVFifoBuffer);
}
extern "C" {
    /// Return the amount of data in bytes in the AVFifoBuffer, that is the
    /// amount of data you can read from it.
    /// @param f AVFifoBuffer to read from
    /// @return size
    pub fn av_fifo_size(f: *const AVFifoBuffer) -> libc::c_int;
}
extern "C" {
    /// Return the amount of space in bytes in the AVFifoBuffer, that is the
    /// amount of data you can write into it.
    /// @param f AVFifoBuffer to write into
    /// @return size
    pub fn av_fifo_space(f: *const AVFifoBuffer) -> libc::c_int;
}
extern "C" {
    /// Feed data at specific position from an AVFifoBuffer to a user-supplied callback.
    /// Similar as av_fifo_gereric_read but without discarding data.
    /// @param f AVFifoBuffer to read from
    /// @param offset offset from current read position
    /// @param buf_size number of bytes to read
    /// @param func generic read function
    /// @param dest data destination
    pub fn av_fifo_generic_peek_at(
        f: *mut AVFifoBuffer,
        dest: *mut libc::c_void,
        offset: libc::c_int,
        buf_size: libc::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_void,
                arg3: libc::c_int,
            ),
        >,
    ) -> libc::c_int;
}
extern "C" {
    /// Feed data from an AVFifoBuffer to a user-supplied callback.
    /// Similar as av_fifo_gereric_read but without discarding data.
    /// @param f AVFifoBuffer to read from
    /// @param buf_size number of bytes to read
    /// @param func generic read function
    /// @param dest data destination
    pub fn av_fifo_generic_peek(
        f: *mut AVFifoBuffer,
        dest: *mut libc::c_void,
        buf_size: libc::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_void,
                arg3: libc::c_int,
            ),
        >,
    ) -> libc::c_int;
}
extern "C" {
    /// Feed data from an AVFifoBuffer to a user-supplied callback.
    /// @param f AVFifoBuffer to read from
    /// @param buf_size number of bytes to read
    /// @param func generic read function
    /// @param dest data destination
    pub fn av_fifo_generic_read(
        f: *mut AVFifoBuffer,
        dest: *mut libc::c_void,
        buf_size: libc::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_void,
                arg3: libc::c_int,
            ),
        >,
    ) -> libc::c_int;
}
extern "C" {
    /// Feed data from a user-supplied callback to an AVFifoBuffer.
    /// @param f AVFifoBuffer to write to
    /// @param src data source; non-const since it may be used as a
    /// modifiable context by the function defined in func
    /// @param size number of bytes to write
    /// @param func generic write function; the first parameter is src,
    /// the second is dest_buf, the third is dest_buf_size.
    /// func must return the number of bytes written to dest_buf, or <= 0 to
    /// indicate no more data available to write.
    /// If func is NULL, src is interpreted as a simple byte array for source data.
    /// @return the number of bytes written to the FIFO
    pub fn av_fifo_generic_write(
        f: *mut AVFifoBuffer,
        src: *mut libc::c_void,
        size: libc::c_int,
        func: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut libc::c_void,
                arg2: *mut libc::c_void,
                arg3: libc::c_int,
            ) -> libc::c_int,
        >,
    ) -> libc::c_int;
}
extern "C" {
    /// Resize an AVFifoBuffer.
    /// In case of reallocation failure, the old FIFO is kept unchanged.
    ///
    /// @param f AVFifoBuffer to resize
    /// @param size new AVFifoBuffer size in bytes
    /// @return <0 for failure, >=0 otherwise
    pub fn av_fifo_realloc2(f: *mut AVFifoBuffer, size: libc::c_uint) -> libc::c_int;
}
extern "C" {
    /// Enlarge an AVFifoBuffer.
    /// In case of reallocation failure, the old FIFO is kept unchanged.
    /// The new fifo size may be larger than the requested size.
    ///
    /// @param f AVFifoBuffer to resize
    /// @param additional_space the amount of space in bytes to allocate in addition to av_fifo_size()
    /// @return <0 for failure, >=0 otherwise
    pub fn av_fifo_grow(f: *mut AVFifoBuffer, additional_space: libc::c_uint) -> libc::c_int;
}
extern "C" {
    /// Read and discard the specified amount of data from an AVFifoBuffer.
    /// @param f AVFifoBuffer to read from
    /// @param size amount of data to read in bytes
    pub fn av_fifo_drain(f: *mut AVFifoBuffer, size: libc::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVAudioFifo {
    _unused: [u8; 0],
}
extern "C" {
    /// Free an AVAudioFifo.
    ///
    /// @param af  AVAudioFifo to free
    pub fn av_audio_fifo_free(af: *mut AVAudioFifo);
}
extern "C" {
    /// Allocate an AVAudioFifo.
    ///
    /// @param sample_fmt  sample format
    /// @param channels    number of channels
    /// @param nb_samples  initial allocation size, in samples
    /// @return            newly allocated AVAudioFifo, or NULL on error
    pub fn av_audio_fifo_alloc(
        sample_fmt: AVSampleFormat,
        channels: libc::c_int,
        nb_samples: libc::c_int,
    ) -> *mut AVAudioFifo;
}
extern "C" {
    /// Reallocate an AVAudioFifo.
    ///
    /// @param af          AVAudioFifo to reallocate
    /// @param nb_samples  new allocation size, in samples
    /// @return            0 if OK, or negative AVERROR code on failure
    pub fn av_audio_fifo_realloc(af: *mut AVAudioFifo, nb_samples: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// Write data to an AVAudioFifo.
    ///
    /// The AVAudioFifo will be reallocated automatically if the available space
    /// is less than nb_samples.
    ///
    /// @see enum AVSampleFormat
    /// The documentation for AVSampleFormat describes the data layout.
    ///
    /// @param af          AVAudioFifo to write to
    /// @param data        audio data plane pointers
    /// @param nb_samples  number of samples to write
    /// @return            number of samples actually written, or negative AVERROR
    /// code on failure. If successful, the number of samples
    /// actually written will always be nb_samples.
    pub fn av_audio_fifo_write(
        af: *mut AVAudioFifo,
        data: *mut *mut libc::c_void,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Peek data from an AVAudioFifo.
    ///
    /// @see enum AVSampleFormat
    /// The documentation for AVSampleFormat describes the data layout.
    ///
    /// @param af          AVAudioFifo to read from
    /// @param data        audio data plane pointers
    /// @param nb_samples  number of samples to peek
    /// @return            number of samples actually peek, or negative AVERROR code
    /// on failure. The number of samples actually peek will not
    /// be greater than nb_samples, and will only be less than
    /// nb_samples if av_audio_fifo_size is less than nb_samples.
    pub fn av_audio_fifo_peek(
        af: *mut AVAudioFifo,
        data: *mut *mut libc::c_void,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Peek data from an AVAudioFifo.
    ///
    /// @see enum AVSampleFormat
    /// The documentation for AVSampleFormat describes the data layout.
    ///
    /// @param af          AVAudioFifo to read from
    /// @param data        audio data plane pointers
    /// @param nb_samples  number of samples to peek
    /// @param offset      offset from current read position
    /// @return            number of samples actually peek, or negative AVERROR code
    /// on failure. The number of samples actually peek will not
    /// be greater than nb_samples, and will only be less than
    /// nb_samples if av_audio_fifo_size is less than nb_samples.
    pub fn av_audio_fifo_peek_at(
        af: *mut AVAudioFifo,
        data: *mut *mut libc::c_void,
        nb_samples: libc::c_int,
        offset: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Read data from an AVAudioFifo.
    ///
    /// @see enum AVSampleFormat
    /// The documentation for AVSampleFormat describes the data layout.
    ///
    /// @param af          AVAudioFifo to read from
    /// @param data        audio data plane pointers
    /// @param nb_samples  number of samples to read
    /// @return            number of samples actually read, or negative AVERROR code
    /// on failure. The number of samples actually read will not
    /// be greater than nb_samples, and will only be less than
    /// nb_samples if av_audio_fifo_size is less than nb_samples.
    pub fn av_audio_fifo_read(
        af: *mut AVAudioFifo,
        data: *mut *mut libc::c_void,
        nb_samples: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Drain data from an AVAudioFifo.
    ///
    /// Removes the data without reading it.
    ///
    /// @param af          AVAudioFifo to drain
    /// @param nb_samples  number of samples to drain
    /// @return            0 if OK, or negative AVERROR code on failure
    pub fn av_audio_fifo_drain(af: *mut AVAudioFifo, nb_samples: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// Reset the AVAudioFifo buffer.
    ///
    /// This empties all data in the buffer.
    ///
    /// @param af  AVAudioFifo to reset
    pub fn av_audio_fifo_reset(af: *mut AVAudioFifo);
}
extern "C" {
    /// Get the current number of samples in the AVAudioFifo available for reading.
    ///
    /// @param af  the AVAudioFifo to query
    /// @return    number of samples available for reading
    pub fn av_audio_fifo_size(af: *mut AVAudioFifo) -> libc::c_int;
}
extern "C" {
    /// Get the current number of samples in the AVAudioFifo available for writing.
    ///
    /// @param af  the AVAudioFifo to query
    /// @return    number of samples available for writing
    pub fn av_audio_fifo_space(af: *mut AVAudioFifo) -> libc::c_int;
}
extern "C" {
    /// Decode a base64-encoded string.
    ///
    /// @param out      buffer for decoded data
    /// @param in       null-terminated input string
    /// @param out_size size in bytes of the out buffer, must be at
    /// least 3/4 of the length of in, that is AV_BASE64_DECODE_SIZE(strlen(in))
    /// @return         number of bytes written, or a negative value in case of
    /// invalid input
    pub fn av_base64_decode(
        out: *mut u8,
        in_: *const libc::c_char,
        out_size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Encode data to base64 and null-terminate.
    ///
    /// @param out      buffer for encoded data
    /// @param out_size size in bytes of the out buffer (including the
    /// null terminator), must be at least AV_BASE64_SIZE(in_size)
    /// @param in       input buffer containing the data to encode
    /// @param in_size  size in bytes of the in buffer
    /// @return         out or NULL in case of error
    pub fn av_base64_encode(
        out: *mut libc::c_char,
        out_size: libc::c_int,
        in_: *const u8,
        in_size: libc::c_int,
    ) -> *mut libc::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVBlowfish {
    pub p: [u32; 18usize],
    pub s: [[u32; 256usize]; 4usize],
}
#[test]
fn bindgen_test_layout_AVBlowfish() {
    assert_eq!(
        ::std::mem::size_of::<AVBlowfish>(),
        4168usize,
        concat!("Size of: ", stringify!(AVBlowfish))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBlowfish>(),
        4usize,
        concat!("Alignment of ", stringify!(AVBlowfish))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBlowfish>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBlowfish),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBlowfish>())).s as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBlowfish),
            "::",
            stringify!(s)
        )
    );
}
extern "C" {
    /// Allocate an AVBlowfish context.
    pub fn av_blowfish_alloc() -> *mut AVBlowfish;
}
extern "C" {
    /// Initialize an AVBlowfish context.
    ///
    /// @param ctx an AVBlowfish context
    /// @param key a key
    /// @param key_len length of the key
    pub fn av_blowfish_init(ctx: *mut AVBlowfish, key: *const u8, key_len: libc::c_int);
}
extern "C" {
    /// Encrypt or decrypt a buffer using a previously initialized context.
    ///
    /// @param ctx an AVBlowfish context
    /// @param xl left four bytes halves of input to be encrypted
    /// @param xr right four bytes halves of input to be encrypted
    /// @param decrypt 0 for encryption, 1 for decryption
    pub fn av_blowfish_crypt_ecb(
        ctx: *mut AVBlowfish,
        xl: *mut u32,
        xr: *mut u32,
        decrypt: libc::c_int,
    );
}
extern "C" {
    /// Encrypt or decrypt a buffer using a previously initialized context.
    ///
    /// @param ctx an AVBlowfish context
    /// @param dst destination array, can be equal to src
    /// @param src source array, can be equal to dst
    /// @param count number of 8 byte blocks
    /// @param iv initialization vector for CBC mode, if NULL ECB will be used
    /// @param decrypt 0 for encryption, 1 for decryption
    pub fn av_blowfish_crypt(
        ctx: *mut AVBlowfish,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
extern "C" {
    /// Return non-zero if pfx is a prefix of str. If it is, *ptr is set to
    /// the address of the first character in str after the prefix.
    ///
    /// @param str input string
    /// @param pfx prefix to test
    /// @param ptr updated if the prefix is matched inside str
    /// @return non-zero if the prefix matches, zero otherwise
    pub fn av_strstart(
        str: *const libc::c_char,
        pfx: *const libc::c_char,
        ptr: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    /// Return non-zero if pfx is a prefix of str independent of case. If
    /// it is, *ptr is set to the address of the first character in str
    /// after the prefix.
    ///
    /// @param str input string
    /// @param pfx prefix to test
    /// @param ptr updated if the prefix is matched inside str
    /// @return non-zero if the prefix matches, zero otherwise
    pub fn av_stristart(
        str: *const libc::c_char,
        pfx: *const libc::c_char,
        ptr: *mut *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    /// Locate the first case-independent occurrence in the string haystack
    /// of the string needle.  A zero-length string needle is considered to
    /// match at the start of haystack.
    ///
    /// This function is a case-insensitive version of the standard strstr().
    ///
    /// @param haystack string to search in
    /// @param needle   string to search for
    /// @return         pointer to the located match within haystack
    /// or a null pointer if no match
    pub fn av_stristr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    /// Locate the first occurrence of the string needle in the string haystack
    /// where not more than hay_length characters are searched. A zero-length
    /// string needle is considered to match at the start of haystack.
    ///
    /// This function is a length-limited version of the standard strstr().
    ///
    /// @param haystack   string to search in
    /// @param needle     string to search for
    /// @param hay_length length of string to search in
    /// @return           pointer to the located match within haystack
    /// or a null pointer if no match
    pub fn av_strnstr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
        hay_length: usize,
    ) -> *mut libc::c_char;
}
extern "C" {
    /// Copy the string src to dst, but no more than size - 1 bytes, and
    /// null-terminate dst.
    ///
    /// This function is the same as BSD strlcpy().
    ///
    /// @param dst destination buffer
    /// @param src source string
    /// @param size size of destination buffer
    /// @return the length of src
    ///
    /// @warning since the return value is the length of src, src absolutely
    /// _must_ be a properly 0-terminated string, otherwise this will read beyond
    /// the end of the buffer and possibly crash.
    pub fn av_strlcpy(dst: *mut libc::c_char, src: *const libc::c_char, size: usize) -> usize;
}
extern "C" {
    /// Append the string src to the string dst, but to a total length of
    /// no more than size - 1 bytes, and null-terminate dst.
    ///
    /// This function is similar to BSD strlcat(), but differs when
    /// size <= strlen(dst).
    ///
    /// @param dst destination buffer
    /// @param src source string
    /// @param size size of destination buffer
    /// @return the total length of src and dst
    ///
    /// @warning since the return value use the length of src and dst, these
    /// absolutely _must_ be a properly 0-terminated strings, otherwise this
    /// will read beyond the end of the buffer and possibly crash.
    pub fn av_strlcat(dst: *mut libc::c_char, src: *const libc::c_char, size: usize) -> usize;
}
extern "C" {
    /// Append output to a string, according to a format. Never write out of
    /// the destination buffer, and always put a terminating 0 within
    /// the buffer.
    /// @param dst destination buffer (string to which the output is
    /// appended)
    /// @param size total size of the destination buffer
    /// @param fmt printf-compatible format string, specifying how the
    /// following parameters are used
    /// @return the length of the string that would have been generated
    /// if enough space had been available
    pub fn av_strlcatf(dst: *mut libc::c_char, size: usize, fmt: *const libc::c_char, ...)
        -> usize;
}
extern "C" {
    /// Print arguments following specified format into a large enough auto
    /// allocated buffer. It is similar to GNU asprintf().
    /// @param fmt printf-compatible format string, specifying how the
    /// following parameters are used.
    /// @return the allocated string
    /// @note You have to free the string yourself with av_free().
    pub fn av_asprintf(fmt: *const libc::c_char, ...) -> *mut libc::c_char;
}
extern "C" {
    /// Convert a number to an av_malloced string.
    pub fn av_d2str(d: f64) -> *mut libc::c_char;
}
extern "C" {
    /// Unescape the given string until a non escaped terminating char,
    /// and return the token corresponding to the unescaped string.
    ///
    /// The normal \ and ' escaping is supported. Leading and trailing
    /// whitespaces are removed, unless they are escaped with '\' or are
    /// enclosed between ''.
    ///
    /// @param buf the buffer to parse, buf will be updated to point to the
    /// terminating char
    /// @param term a 0-terminated list of terminating chars
    /// @return the malloced unescaped string, which must be av_freed by
    /// the user, NULL in case of allocation failure
    pub fn av_get_token(
        buf: *mut *const libc::c_char,
        term: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    /// Split the string into several tokens which can be accessed by
    /// successive calls to av_strtok().
    ///
    /// A token is defined as a sequence of characters not belonging to the
    /// set specified in delim.
    ///
    /// On the first call to av_strtok(), s should point to the string to
    /// parse, and the value of saveptr is ignored. In subsequent calls, s
    /// should be NULL, and saveptr should be unchanged since the previous
    /// call.
    ///
    /// This function is similar to strtok_r() defined in POSIX.1.
    ///
    /// @param s the string to parse, may be NULL
    /// @param delim 0-terminated list of token delimiters, must be non-NULL
    /// @param saveptr user-provided pointer which points to stored
    /// information necessary for av_strtok() to continue scanning the same
    /// string. saveptr is updated to point to the next character after the
    /// first delimiter found, or to NULL if the string was terminated
    /// @return the found token, or NULL when no token is found
    pub fn av_strtok(
        s: *mut libc::c_char,
        delim: *const libc::c_char,
        saveptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    /// Locale-independent case-insensitive compare.
    /// @note This means only ASCII-range characters are case-insensitive
    pub fn av_strcasecmp(a: *const libc::c_char, b: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Locale-independent case-insensitive compare.
    /// @note This means only ASCII-range characters are case-insensitive
    pub fn av_strncasecmp(a: *const libc::c_char, b: *const libc::c_char, n: usize) -> libc::c_int;
}
extern "C" {
    /// Locale-independent strings replace.
    /// @note This means only ASCII-range characters are replace
    pub fn av_strireplace(
        str: *const libc::c_char,
        from: *const libc::c_char,
        to: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    /// Thread safe basename.
    /// @param path the path, on DOS both \ and / are considered separators.
    /// @return pointer to the basename substring.
    pub fn av_basename(path: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    /// Thread safe dirname.
    /// @param path the path, on DOS both \ and / are considered separators.
    /// @return the path with the separator replaced by the string terminator or ".".
    /// @note the function may change the input string.
    pub fn av_dirname(path: *mut libc::c_char) -> *const libc::c_char;
}
extern "C" {
    /// Match instances of a name in a comma-separated list of names.
    /// List entries are checked from the start to the end of the names list,
    /// the first match ends further processing. If an entry prefixed with '-'
    /// matches, then 0 is returned. The "ALL" list entry is considered to
    /// match all names.
    ///
    /// @param name  Name to look for.
    /// @param names List of names.
    /// @return 1 on match, 0 otherwise.
    pub fn av_match_name(name: *const libc::c_char, names: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Append path component to the existing path.
    /// Path separator '/' is placed between when needed.
    /// Resulting string have to be freed with av_free().
    /// @param path      base path
    /// @param component component to be appended
    /// @return new path or NULL on error.
    pub fn av_append_path_component(
        path: *const libc::c_char,
        component: *const libc::c_char,
    ) -> *mut libc::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVEscapeMode {
    AV_ESCAPE_MODE_AUTO = 0,
    AV_ESCAPE_MODE_BACKSLASH = 1,
    AV_ESCAPE_MODE_QUOTE = 2,
}
extern "C" {
    /// Escape string in src, and put the escaped string in an allocated
    /// string in *dst, which must be freed with av_free().
    ///
    /// @param dst           pointer where an allocated string is put
    /// @param src           string to escape, must be non-NULL
    /// @param special_chars string containing the special characters which
    /// need to be escaped, can be NULL
    /// @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.
    /// Any unknown value for mode will be considered equivalent to
    /// AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without
    /// notice.
    /// @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_ macros
    /// @return the length of the allocated string, or a negative error code in case of error
    /// @see av_bprint_escape()
    pub fn av_escape(
        dst: *mut *mut libc::c_char,
        src: *const libc::c_char,
        special_chars: *const libc::c_char,
        mode: AVEscapeMode,
        flags: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Read and decode a single UTF-8 code point (character) from the
    /// buffer in *buf, and update *buf to point to the next byte to
    /// decode.
    ///
    /// In case of an invalid byte sequence, the pointer will be updated to
    /// the next byte after the invalid sequence and the function will
    /// return an error code.
    ///
    /// Depending on the specified flags, the function will also fail in
    /// case the decoded code point does not belong to a valid range.
    ///
    /// @note For speed-relevant code a carefully implemented use of
    /// GET_UTF8() may be preferred.
    ///
    /// @param codep   pointer used to return the parsed code in case of success.
    /// The value in *codep is set even in case the range check fails.
    /// @param bufp    pointer to the address the first byte of the sequence
    /// to decode, updated by the function to point to the
    /// byte next after the decoded sequence
    /// @param buf_end pointer to the end of the buffer, points to the next
    /// byte past the last in the buffer. This is used to
    /// avoid buffer overreads (in case of an unfinished
    /// UTF-8 sequence towards the end of the buffer).
    /// @param flags   a collection of AV_UTF8_FLAG_* flags
    /// @return >= 0 in case a sequence was successfully read, a negative
    /// value in case of invalid sequence
    pub fn av_utf8_decode(
        codep: *mut i32,
        bufp: *mut *const u8,
        buf_end: *const u8,
        flags: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    /// Check if a name is in a list.
    /// @returns 0 if not found, or the 1 based index where it has been found in the
    /// list.
    pub fn av_match_list(
        name: *const libc::c_char,
        list: *const libc::c_char,
        separator: libc::c_char,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct ff_pad_helper_AVBPrint {
    pub str: *mut libc::c_char,
    pub len: libc::c_uint,
    pub size: libc::c_uint,
    pub size_max: libc::c_uint,
    pub reserved_internal_buffer: [libc::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_ff_pad_helper_AVBPrint() {
    assert_eq!(
        ::std::mem::size_of::<ff_pad_helper_AVBPrint>(),
        24usize,
        concat!("Size of: ", stringify!(ff_pad_helper_AVBPrint))
    );
    assert_eq!(
        ::std::mem::align_of::<ff_pad_helper_AVBPrint>(),
        8usize,
        concat!("Alignment of ", stringify!(ff_pad_helper_AVBPrint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_pad_helper_AVBPrint>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_pad_helper_AVBPrint>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_pad_helper_AVBPrint>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ff_pad_helper_AVBPrint>())).size_max as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(size_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ff_pad_helper_AVBPrint>())).reserved_internal_buffer as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ff_pad_helper_AVBPrint),
            "::",
            stringify!(reserved_internal_buffer)
        )
    );
}
/// Buffer to print data progressively
///
/// The string buffer grows as necessary and is always 0-terminated.
/// The content of the string is never accessed, and thus is
/// encoding-agnostic and can even hold binary data.
///
/// Small buffers are kept in the structure itself, and thus require no
/// memory allocation at all (unless the contents of the buffer is needed
/// after the structure goes out of scope). This is almost as lightweight as
/// declaring a local "char buf[512]".
///
/// The length of the string can go beyond the allocated size: the buffer is
/// then truncated, but the functions still keep account of the actual total
/// length.
///
/// In other words, buf->len can be greater than buf->size and records the
/// total length of what would have been to the buffer if there had been
/// enough memory.
///
/// Append operations do not need to be tested for failure: if a memory
/// allocation fails, data stop being appended to the buffer, but the length
/// is still updated. This situation can be tested with
/// av_bprint_is_complete().
///
/// The size_max field determines several possible behaviours:
///
/// size_max = -1 (= UINT_MAX) or any large value will let the buffer be
/// reallocated as necessary, with an amortized linear cost.
///
/// size_max = 0 prevents writing anything to the buffer: only the total
/// length is computed. The write operations can then possibly be repeated in
/// a buffer with exactly the necessary size
/// (using size_init = size_max = len + 1).
///
/// size_max = 1 is automatically replaced by the exact size available in the
/// structure itself, thus ensuring no dynamic memory allocation. The
/// internal buffer is large enough to hold a reasonable paragraph of text,
/// such as the current paragraph.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVBPrint {
    pub str: *mut libc::c_char,
    pub len: libc::c_uint,
    pub size: libc::c_uint,
    pub size_max: libc::c_uint,
    pub reserved_internal_buffer: [libc::c_char; 1usize],
    pub reserved_padding: [libc::c_char; 1000usize],
}
#[test]
fn bindgen_test_layout_AVBPrint() {
    assert_eq!(
        ::std::mem::size_of::<AVBPrint>(),
        1024usize,
        concat!("Size of: ", stringify!(AVBPrint))
    );
    assert_eq!(
        ::std::mem::align_of::<AVBPrint>(),
        8usize,
        concat!("Alignment of ", stringify!(AVBPrint))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBPrint>())).str as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(str)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBPrint>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBPrint>())).size as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBPrint>())).size_max as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(size_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVBPrint>())).reserved_internal_buffer as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(reserved_internal_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVBPrint>())).reserved_padding as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(AVBPrint),
            "::",
            stringify!(reserved_padding)
        )
    );
}
extern "C" {
    /// Init a print buffer.
    ///
    /// @param buf        buffer to init
    /// @param size_init  initial size (including the final 0)
    /// @param size_max   maximum size;
    /// 0 means do not write anything, just count the length;
    /// 1 is replaced by the maximum value for automatic storage;
    /// any large value means that the internal buffer will be
    /// reallocated as needed up to that limit; -1 is converted to
    /// UINT_MAX, the largest limit possible.
    /// Check also AV_BPRINT_SIZE_* macros.
    pub fn av_bprint_init(buf: *mut AVBPrint, size_init: libc::c_uint, size_max: libc::c_uint);
}
extern "C" {
    /// Init a print buffer using a pre-existing buffer.
    ///
    /// The buffer will not be reallocated.
    ///
    /// @param buf     buffer structure to init
    /// @param buffer  byte buffer to use for the string data
    /// @param size    size of buffer
    pub fn av_bprint_init_for_buffer(
        buf: *mut AVBPrint,
        buffer: *mut libc::c_char,
        size: libc::c_uint,
    );
}
extern "C" {
    /// Append a formatted string to a print buffer.
    pub fn av_bprintf(buf: *mut AVBPrint, fmt: *const libc::c_char, ...);
}
extern "C" {
    /// Append a formatted string to a print buffer.
    pub fn av_vbprintf(buf: *mut AVBPrint, fmt: *const libc::c_char, vl_arg: *mut __va_list_tag);
}
extern "C" {
    /// Append char c n times to a print buffer.
    pub fn av_bprint_chars(buf: *mut AVBPrint, c: libc::c_char, n: libc::c_uint);
}
extern "C" {
    /// Append data to a print buffer.
    ///
    /// param buf  bprint buffer to use
    /// param data pointer to data
    /// param size size of data
    pub fn av_bprint_append_data(buf: *mut AVBPrint, data: *const libc::c_char, size: libc::c_uint);
}
extern "C" {
    /// Append a formatted date and time to a print buffer.
    ///
    /// param buf  bprint buffer to use
    /// param fmt  date and time format string, see strftime()
    /// param tm   broken-down time structure to translate
    ///
    /// @note due to poor design of the standard strftime function, it may
    /// produce poor results if the format string expands to a very long text and
    /// the bprint buffer is near the limit stated by the size_max option.
    pub fn av_bprint_strftime(buf: *mut AVBPrint, fmt: *const libc::c_char, tm: *const tm);
}
extern "C" {
    /// Allocate bytes in the buffer for external use.
    ///
    /// @param[in]  buf          buffer structure
    /// @param[in]  size         required size
    /// @param[out] mem          pointer to the memory area
    /// @param[out] actual_size  size of the memory area after allocation;
    /// can be larger or smaller than size
    pub fn av_bprint_get_buffer(
        buf: *mut AVBPrint,
        size: libc::c_uint,
        mem: *mut *mut libc::c_uchar,
        actual_size: *mut libc::c_uint,
    );
}
extern "C" {
    /// Reset the string to "" but keep internal allocated data.
    pub fn av_bprint_clear(buf: *mut AVBPrint);
}
extern "C" {
    /// Finalize a print buffer.
    ///
    /// The print buffer can no longer be used afterwards,
    /// but the len and size fields are still valid.
    ///
    /// @arg[out] ret_str  if not NULL, used to return a permanent copy of the
    /// buffer contents, or NULL if memory allocation fails;
    /// if NULL, the buffer is discarded and freed
    /// @return  0 for success or error code (probably AVERROR(ENOMEM))
    pub fn av_bprint_finalize(buf: *mut AVBPrint, ret_str: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Escape the content in src and append it to dstbuf.
    ///
    /// @param dstbuf        already inited destination bprint buffer
    /// @param src           string containing the text to escape
    /// @param special_chars string containing the special characters which
    /// need to be escaped, can be NULL
    /// @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.
    /// Any unknown value for mode will be considered equivalent to
    /// AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without
    /// notice.
    /// @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_* macros
    pub fn av_bprint_escape(
        dstbuf: *mut AVBPrint,
        src: *const libc::c_char,
        special_chars: *const libc::c_char,
        mode: AVEscapeMode,
        flags: libc::c_int,
    );
}
extern "C" {
    pub static mut av_camellia_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCAMELLIA {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate an AVCAMELLIA context
    /// To free the struct: av_free(ptr)
    pub fn av_camellia_alloc() -> *mut AVCAMELLIA;
}
extern "C" {
    /// Initialize an AVCAMELLIA context.
    ///
    /// @param ctx an AVCAMELLIA context
    /// @param key a key of 16, 24, 32 bytes used for encryption/decryption
    /// @param key_bits number of keybits: possible are 128, 192, 256
    pub fn av_camellia_init(
        ctx: *mut AVCAMELLIA,
        key: *const u8,
        key_bits: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Encrypt or decrypt a buffer using a previously initialized context
    ///
    /// @param ctx an AVCAMELLIA context
    /// @param dst destination array, can be equal to src
    /// @param src source array, can be equal to dst
    /// @param count number of 16 byte blocks
    /// @paran iv initialization vector for CBC mode, NULL for ECB mode
    /// @param decrypt 0 for encryption, 1 for decryption
    pub fn av_camellia_crypt(
        ctx: *mut AVCAMELLIA,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
extern "C" {
    pub static mut av_cast5_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVCAST5 {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate an AVCAST5 context
    /// To free the struct: av_free(ptr)
    pub fn av_cast5_alloc() -> *mut AVCAST5;
}
extern "C" {
    /// Initialize an AVCAST5 context.
    ///
    /// @param ctx an AVCAST5 context
    /// @param key a key of 5,6,...16 bytes used for encryption/decryption
    /// @param key_bits number of keybits: possible are 40,48,...,128
    /// @return 0 on success, less than 0 on failure
    pub fn av_cast5_init(ctx: *mut AVCAST5, key: *const u8, key_bits: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// Encrypt or decrypt a buffer using a previously initialized context, ECB mode only
    ///
    /// @param ctx an AVCAST5 context
    /// @param dst destination array, can be equal to src
    /// @param src source array, can be equal to dst
    /// @param count number of 8 byte blocks
    /// @param decrypt 0 for encryption, 1 for decryption
    pub fn av_cast5_crypt(
        ctx: *mut AVCAST5,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        decrypt: libc::c_int,
    );
}
extern "C" {
    /// Encrypt or decrypt a buffer using a previously initialized context
    ///
    /// @param ctx an AVCAST5 context
    /// @param dst destination array, can be equal to src
    /// @param src source array, can be equal to dst
    /// @param count number of 8 byte blocks
    /// @param iv initialization vector for CBC mode, NULL for ECB mode
    /// @param decrypt 0 for encryption, 1 for decryption
    pub fn av_cast5_crypt2(
        ctx: *mut AVCAST5,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
/// @defgroup lavu_crc32 CRC
/// @ingroup lavu_hash
/// CRC (Cyclic Redundancy Check) hash function implementation.
///
/// This module supports numerous CRC polynomials, in addition to the most
/// widely used CRC-32-IEEE. See @ref AVCRCId for a list of available
/// polynomials.
///
/// @{
pub type AVCRC = u32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVCRCId {
    AV_CRC_8_ATM = 0,
    AV_CRC_16_ANSI = 1,
    AV_CRC_16_CCITT = 2,
    AV_CRC_32_IEEE = 3,
    AV_CRC_32_IEEE_LE = 4,
    AV_CRC_16_ANSI_LE = 5,
    AV_CRC_24_IEEE = 12,
    AV_CRC_MAX = 13,
}
extern "C" {
    /// Initialize a CRC table.
    /// @param ctx must be an array of size sizeof(AVCRC)*257 or sizeof(AVCRC)*1024
    /// @param le If 1, the lowest bit represents the coefficient for the highest
    /// exponent of the corresponding polynomial (both for poly and
    /// actual CRC).
    /// If 0, you must swap the CRC parameter and the result of av_crc
    /// if you need the standard representation (can be simplified in
    /// most cases to e.g. bswap16):
    /// av_bswap32(crc << (32-bits))
    /// @param bits number of bits for the CRC
    /// @param poly generator polynomial without the x**bits coefficient, in the
    /// representation as specified by le
    /// @param ctx_size size of ctx in bytes
    /// @return <0 on failure
    pub fn av_crc_init(
        ctx: *mut AVCRC,
        le: libc::c_int,
        bits: libc::c_int,
        poly: u32,
        ctx_size: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Get an initialized standard CRC table.
    /// @param crc_id ID of a standard CRC
    /// @return a pointer to the CRC table or NULL on failure
    pub fn av_crc_get_table(crc_id: AVCRCId) -> *const AVCRC;
}
extern "C" {
    /// Calculate the CRC of a block.
    /// @param crc CRC of previous blocks if any or initial value for CRC
    /// @return CRC updated with the data from the given block
    ///
    /// @see av_crc_init() "le" parameter
    pub fn av_crc(ctx: *const AVCRC, crc: u32, buffer: *const u8, length: usize) -> u32;
}
extern "C" {
    /// Extract the rotation component of the transformation matrix.
    ///
    /// @param matrix the transformation matrix
    /// @return the angle (in degrees) by which the transformation rotates the frame
    /// counterclockwise. The angle will be in range [-180.0, 180.0],
    /// or NaN if the matrix is singular.
    ///
    /// @note floating point numbers are inherently inexact, so callers are
    /// recommended to round the return value to nearest integer before use.
    pub fn av_display_rotation_get(matrix: *const i32) -> f64;
}
extern "C" {
    /// Initialize a transformation matrix describing a pure counterclockwise
    /// rotation by the specified angle (in degrees).
    ///
    /// @param matrix an allocated transformation matrix (will be fully overwritten
    /// by this function)
    /// @param angle rotation angle in degrees.
    pub fn av_display_rotation_set(matrix: *mut i32, angle: f64);
}
extern "C" {
    /// Flip the input matrix horizontally and/or vertically.
    ///
    /// @param matrix an allocated transformation matrix
    /// @param hflip whether the matrix should be flipped horizontally
    /// @param vflip whether the matrix should be flipped vertically
    pub fn av_display_matrix_flip(matrix: *mut i32, hflip: libc::c_int, vflip: libc::c_int);
}
#[repr(u32)]
/// Possible downmix types.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVDownmixType {
    AV_DOWNMIX_TYPE_UNKNOWN = 0,
    AV_DOWNMIX_TYPE_LORO = 1,
    AV_DOWNMIX_TYPE_LTRT = 2,
    AV_DOWNMIX_TYPE_DPLII = 3,
    AV_DOWNMIX_TYPE_NB = 4,
}
/// This structure describes optional metadata relevant to a downmix procedure.
///
/// All fields are set by the decoder to the value indicated in the audio
/// bitstream (if present), or to a "sane" default otherwise.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct AVDownmixInfo {
    /// Type of downmix preferred by the mastering engineer.
    pub preferred_downmix_type: AVDownmixType,
    /// Absolute scale factor representing the nominal level of the center
    /// channel during a regular downmix.
    pub center_mix_level: f64,
    /// Absolute scale factor representing the nominal level of the center
    /// channel during an Lt/Rt compatible downmix.
    pub center_mix_level_ltrt: f64,
    /// Absolute scale factor representing the nominal level of the surround
    /// channels during a regular downmix.
    pub surround_mix_level: f64,
    /// Absolute scale factor representing the nominal level of the surround
    /// channels during an Lt/Rt compatible downmix.
    pub surround_mix_level_ltrt: f64,
    /// Absolute scale factor representing the level at which the LFE data is
    /// mixed into L/R channels during downmixing.
    pub lfe_mix_level: f64,
}
#[test]
fn bindgen_test_layout_AVDownmixInfo() {
    assert_eq!(
        ::std::mem::size_of::<AVDownmixInfo>(),
        48usize,
        concat!("Size of: ", stringify!(AVDownmixInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AVDownmixInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AVDownmixInfo))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDownmixInfo>())).preferred_downmix_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(preferred_downmix_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDownmixInfo>())).center_mix_level as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(center_mix_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDownmixInfo>())).center_mix_level_ltrt as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(center_mix_level_ltrt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDownmixInfo>())).surround_mix_level as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(surround_mix_level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVDownmixInfo>())).surround_mix_level_ltrt as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(surround_mix_level_ltrt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVDownmixInfo>())).lfe_mix_level as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AVDownmixInfo),
            "::",
            stringify!(lfe_mix_level)
        )
    );
}
extern "C" {
    /// Get a frame's AV_FRAME_DATA_DOWNMIX_INFO side data for editing.
    ///
    /// If the side data is absent, it is created and added to the frame.
    ///
    /// @param frame the frame for which the side data is to be obtained or created
    ///
    /// @return the AVDownmixInfo structure to be edited by the caller, or NULL if
    /// the structure cannot be allocated.
    pub fn av_downmix_info_update_side_data(frame: *mut AVFrame) -> *mut AVDownmixInfo;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVExpr {
    _unused: [u8; 0],
}
extern "C" {
    /// Parse and evaluate an expression.
    /// Note, this is significantly slower than av_expr_eval().
    ///
    /// @param res a pointer to a double where is put the result value of
    /// the expression, or NAN in case of error
    /// @param s expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"
    /// @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}
    /// @param const_values a zero terminated array of values for the identifiers from const_names
    /// @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers
    /// @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
    /// @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
    /// @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
    /// @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
    /// @param log_ctx parent logging context
    /// @return >= 0 in case of success, a negative value corresponding to an
    /// AVERROR code otherwise
    pub fn av_expr_parse_and_eval(
        res: *mut f64,
        s: *const libc::c_char,
        const_names: *const *const libc::c_char,
        const_values: *const f64,
        func1_names: *const *const libc::c_char,
        funcs1: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: f64) -> f64,
        >,
        func2_names: *const *const libc::c_char,
        funcs2: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: f64, arg3: f64) -> f64,
        >,
        opaque: *mut libc::c_void,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Parse an expression.
    ///
    /// @param expr a pointer where is put an AVExpr containing the parsed
    /// value in case of successful parsing, or NULL otherwise.
    /// The pointed to AVExpr must be freed with av_expr_free() by the user
    /// when it is not needed anymore.
    /// @param s expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"
    /// @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}
    /// @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers
    /// @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
    /// @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
    /// @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
    /// @param log_ctx parent logging context
    /// @return >= 0 in case of success, a negative value corresponding to an
    /// AVERROR code otherwise
    pub fn av_expr_parse(
        expr: *mut *mut AVExpr,
        s: *const libc::c_char,
        const_names: *const *const libc::c_char,
        func1_names: *const *const libc::c_char,
        funcs1: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: f64) -> f64,
        >,
        func2_names: *const *const libc::c_char,
        funcs2: *const ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut libc::c_void, arg2: f64, arg3: f64) -> f64,
        >,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Evaluate a previously parsed expression.
    ///
    /// @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names
    /// @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
    /// @return the value of the expression
    pub fn av_expr_eval(e: *mut AVExpr, const_values: *const f64, opaque: *mut libc::c_void)
        -> f64;
}
extern "C" {
    /// Free a parsed expression previously created with av_expr_parse().
    pub fn av_expr_free(e: *mut AVExpr);
}
extern "C" {
    /// Parse the string in numstr and return its value as a double. If
    /// the string is empty, contains only whitespaces, or does not contain
    /// an initial substring that has the expected syntax for a
    /// floating-point number, no conversion is performed. In this case,
    /// returns a value of zero and the value returned in tail is the value
    /// of numstr.
    ///
    /// @param numstr a string representing a number, may contain one of
    /// the International System number postfixes, for example 'K', 'M',
    /// 'G'. If 'i' is appended after the postfix, powers of 2 are used
    /// instead of powers of 10. The 'B' postfix multiplies the value by
    /// 8, and can be appended after another postfix or used alone. This
    /// allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.
    /// @param tail if non-NULL puts here the pointer to the char next
    /// after the last parsed character
    pub fn av_strtod(numstr: *const libc::c_char, tail: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    /// Read the file with name filename, and put its content in a newly
    /// allocated buffer or map it with mmap() when available.
    /// In case of success set *bufptr to the read or mmapped buffer, and
    /// *size to the size in bytes of the buffer in *bufptr.
    /// The returned buffer must be released with av_file_unmap().
    ///
    /// @param log_offset loglevel offset used for logging
    /// @param log_ctx context used for logging
    /// @return a non negative number in case of success, a negative value
    /// corresponding to an AVERROR error code in case of failure
    pub fn av_file_map(
        filename: *const libc::c_char,
        bufptr: *mut *mut u8,
        size: *mut usize,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Unmap or free the buffer bufptr created by av_file_map().
    ///
    /// @param size size in bytes of bufptr, must be the same as returned
    /// by av_file_map()
    pub fn av_file_unmap(bufptr: *mut u8, size: usize);
}
extern "C" {
    /// Wrapper to work around the lack of mkstemp() on mingw.
    /// Also, tries to create file in /tmp first, if possible.
    /// *prefix can be a character constant; *filename will be allocated internally.
    /// @return file descriptor of opened file (or negative value corresponding to an
    /// AVERROR code on error)
    /// and opened file name in **filename.
    /// @note On very old libcs it is necessary to set a secure umask before
    /// calling this, av_tempfile() can't call umask itself as it is used in
    /// libraries and could interfere with the calling application.
    /// @deprecated as fd numbers cannot be passed saftely between libs on some platforms
    pub fn av_tempfile(
        prefix: *const libc::c_char,
        filename: *mut *mut libc::c_char,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHashContext {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate a hash context for the algorithm specified by name.
    ///
    /// @return  >= 0 for success, a negative error code for failure
    ///
    /// @note The context is not initialized after a call to this function; you must
    /// call av_hash_init() to do so.
    pub fn av_hash_alloc(ctx: *mut *mut AVHashContext, name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Get the names of available hash algorithms.
    ///
    /// This function can be used to enumerate the algorithms.
    ///
    /// @param[in] i  Index of the hash algorithm, starting from 0
    /// @return       Pointer to a static string or `NULL` if `i` is out of range
    pub fn av_hash_names(i: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    /// Get the name of the algorithm corresponding to the given hash context.
    pub fn av_hash_get_name(ctx: *const AVHashContext) -> *const libc::c_char;
}
extern "C" {
    /// Get the size of the resulting hash value in bytes.
    ///
    /// The maximum value this function will currently return is available as macro
    /// #AV_HASH_MAX_SIZE.
    ///
    /// @param[in]     ctx Hash context
    /// @return            Size of the hash value in bytes
    pub fn av_hash_get_size(ctx: *const AVHashContext) -> libc::c_int;
}
extern "C" {
    /// Initialize or reset a hash context.
    ///
    /// @param[in,out] ctx Hash context
    pub fn av_hash_init(ctx: *mut AVHashContext);
}
extern "C" {
    /// Update a hash context with additional data.
    ///
    /// @param[in,out] ctx Hash context
    /// @param[in]     src Data to be added to the hash context
    /// @param[in]     len Size of the additional data
    pub fn av_hash_update(ctx: *mut AVHashContext, src: *const u8, len: libc::c_int);
}
extern "C" {
    /// Finalize a hash context and compute the actual hash value.
    ///
    /// The minimum size of `dst` buffer is given by av_hash_get_size() or
    /// #AV_HASH_MAX_SIZE. The use of the latter macro is discouraged.
    ///
    /// It is not safe to update or finalize a hash context again, if it has already
    /// been finalized.
    ///
    /// @param[in,out] ctx Hash context
    /// @param[out]    dst Where the final hash value will be stored
    ///
    /// @see av_hash_final_bin() provides an alternative API
    pub fn av_hash_final(ctx: *mut AVHashContext, dst: *mut u8);
}
extern "C" {
    /// Finalize a hash context and store the actual hash value in a buffer.
    ///
    /// It is not safe to update or finalize a hash context again, if it has already
    /// been finalized.
    ///
    /// If `size` is smaller than the hash size (given by av_hash_get_size()), the
    /// hash is truncated; if size is larger, the buffer is padded with 0.
    ///
    /// @param[in,out] ctx  Hash context
    /// @param[out]    dst  Where the final hash value will be stored
    /// @param[in]     size Number of bytes to write to `dst`
    pub fn av_hash_final_bin(ctx: *mut AVHashContext, dst: *mut u8, size: libc::c_int);
}
extern "C" {
    /// Finalize a hash context and store the hexadecimal representation of the
    /// actual hash value as a string.
    ///
    /// It is not safe to update or finalize a hash context again, if it has already
    /// been finalized.
    ///
    /// The string is always 0-terminated.
    ///
    /// If `size` is smaller than `2 * hash_size + 1`, where `hash_size` is the
    /// value returned by av_hash_get_size(), the string will be truncated.
    ///
    /// @param[in,out] ctx  Hash context
    /// @param[out]    dst  Where the string will be stored
    /// @param[in]     size Maximum number of bytes to write to `dst`
    pub fn av_hash_final_hex(ctx: *mut AVHashContext, dst: *mut u8, size: libc::c_int);
}
extern "C" {
    /// Finalize a hash context and store the Base64 representation of the
    /// actual hash value as a string.
    ///
    /// It is not safe to update or finalize a hash context again, if it has already
    /// been finalized.
    ///
    /// The string is always 0-terminated.
    ///
    /// If `size` is smaller than AV_BASE64_SIZE(hash_size), where `hash_size` is
    /// the value returned by av_hash_get_size(), the string will be truncated.
    ///
    /// @param[in,out] ctx  Hash context
    /// @param[out]    dst  Where the final hash value will be stored
    /// @param[in]     size Maximum number of bytes to write to `dst`
    pub fn av_hash_final_b64(ctx: *mut AVHashContext, dst: *mut u8, size: libc::c_int);
}
extern "C" {
    /// Free hash context and set hash context pointer to `NULL`.
    ///
    /// @param[in,out] ctx  Pointer to hash context
    pub fn av_hash_freep(ctx: *mut *mut AVHashContext);
}
#[repr(u32)]
/// @defgroup lavu_hmac HMAC
/// @ingroup lavu_crypto
/// @{
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVHMACType {
    AV_HMAC_MD5 = 0,
    AV_HMAC_SHA1 = 1,
    AV_HMAC_SHA224 = 2,
    AV_HMAC_SHA256 = 3,
    AV_HMAC_SHA384 = 12,
    AV_HMAC_SHA512 = 13,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVHMAC {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate an AVHMAC context.
    /// @param type The hash function used for the HMAC.
    pub fn av_hmac_alloc(type_: AVHMACType) -> *mut AVHMAC;
}
extern "C" {
    /// Free an AVHMAC context.
    /// @param ctx The context to free, may be NULL
    pub fn av_hmac_free(ctx: *mut AVHMAC);
}
extern "C" {
    /// Initialize an AVHMAC context with an authentication key.
    /// @param ctx    The HMAC context
    /// @param key    The authentication key
    /// @param keylen The length of the key, in bytes
    pub fn av_hmac_init(ctx: *mut AVHMAC, key: *const u8, keylen: libc::c_uint);
}
extern "C" {
    /// Hash data with the HMAC.
    /// @param ctx  The HMAC context
    /// @param data The data to hash
    /// @param len  The length of the data, in bytes
    pub fn av_hmac_update(ctx: *mut AVHMAC, data: *const u8, len: libc::c_uint);
}
extern "C" {
    /// Finish hashing and output the HMAC digest.
    /// @param ctx    The HMAC context
    /// @param out    The output buffer to write the digest into
    /// @param outlen The length of the out buffer, in bytes
    /// @return       The number of bytes written to out, or a negative error code.
    pub fn av_hmac_final(ctx: *mut AVHMAC, out: *mut u8, outlen: libc::c_uint) -> libc::c_int;
}
extern "C" {
    /// Hash an array of data with a key.
    /// @param ctx    The HMAC context
    /// @param data   The data to hash
    /// @param len    The length of the data, in bytes
    /// @param key    The authentication key
    /// @param keylen The length of the key, in bytes
    /// @param out    The output buffer to write the digest into
    /// @param outlen The length of the out buffer, in bytes
    /// @return       The number of bytes written to out, or a negative error code.
    pub fn av_hmac_calc(
        ctx: *mut AVHMAC,
        data: *const u8,
        len: libc::c_uint,
        key: *const u8,
        keylen: libc::c_uint,
        out: *mut u8,
        outlen: libc::c_uint,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVComponentDescriptor {
    /// Which of the 4 planes contains the component.
    pub plane: libc::c_int,
    /// Number of elements between 2 horizontally consecutive pixels.
    /// Elements are bits for bitstream formats, bytes otherwise.
    pub step: libc::c_int,
    /// Number of elements before the component of the first pixel.
    /// Elements are bits for bitstream formats, bytes otherwise.
    pub offset: libc::c_int,
    /// Number of least significant bits that must be shifted away
    /// to get the value.
    pub shift: libc::c_int,
    /// Number of bits in the component.
    pub depth: libc::c_int,
    /// deprecated, use step instead
    pub step_minus1: libc::c_int,
    /// deprecated, use depth instead
    pub depth_minus1: libc::c_int,
    /// deprecated, use offset instead
    pub offset_plus1: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVComponentDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<AVComponentDescriptor>(),
        32usize,
        concat!("Size of: ", stringify!(AVComponentDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVComponentDescriptor>(),
        4usize,
        concat!("Alignment of ", stringify!(AVComponentDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVComponentDescriptor>())).plane as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(plane)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVComponentDescriptor>())).step as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVComponentDescriptor>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVComponentDescriptor>())).shift as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(shift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVComponentDescriptor>())).depth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVComponentDescriptor>())).step_minus1 as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(step_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVComponentDescriptor>())).depth_minus1 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(depth_minus1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVComponentDescriptor>())).offset_plus1 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVComponentDescriptor),
            "::",
            stringify!(offset_plus1)
        )
    );
}
/// Descriptor that unambiguously describes how the bits of a pixel are
/// stored in the up to 4 data planes of an image. It also stores the
/// subsampling factors and number of components.
///
/// @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV
/// and all the YUV variants) AVPixFmtDescriptor just stores how values
/// are stored not what these values represent.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVPixFmtDescriptor {
    pub name: *const libc::c_char,
    /// < The number of components each pixel has, (1-4)
    pub nb_components: u8,
    /// Amount to shift the luma width right to find the chroma width.
    /// For YV12 this is 1 for example.
    /// chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w)
    /// The note above is needed to ensure rounding up.
    /// This value only refers to the chroma components.
    pub log2_chroma_w: u8,
    /// Amount to shift the luma height right to find the chroma height.
    /// For YV12 this is 1 for example.
    /// chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h)
    /// The note above is needed to ensure rounding up.
    /// This value only refers to the chroma components.
    pub log2_chroma_h: u8,
    /// Combination of AV_PIX_FMT_FLAG_... flags.
    pub flags: u64,
    /// Parameters that describe how pixels are packed.
    /// If the format has 1 or 2 components, then luma is 0.
    /// If the format has 3 or 4 components:
    /// if the RGB flag is set then 0 is red, 1 is green and 2 is blue;
    /// otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V.
    ///
    /// If present, the Alpha channel is always the last component.
    pub comp: [AVComponentDescriptor; 4usize],
    /// Alternative comma-separated names.
    pub alias: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_AVPixFmtDescriptor() {
    assert_eq!(
        ::std::mem::size_of::<AVPixFmtDescriptor>(),
        160usize,
        concat!("Size of: ", stringify!(AVPixFmtDescriptor))
    );
    assert_eq!(
        ::std::mem::align_of::<AVPixFmtDescriptor>(),
        8usize,
        concat!("Alignment of ", stringify!(AVPixFmtDescriptor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPixFmtDescriptor>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVPixFmtDescriptor>())).nb_components as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(nb_components)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVPixFmtDescriptor>())).log2_chroma_w as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(log2_chroma_w)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<AVPixFmtDescriptor>())).log2_chroma_h as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(log2_chroma_h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPixFmtDescriptor>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPixFmtDescriptor>())).comp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(comp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVPixFmtDescriptor>())).alias as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(AVPixFmtDescriptor),
            "::",
            stringify!(alias)
        )
    );
}
extern "C" {
    /// Return the number of bits per pixel used by the pixel format
    /// described by pixdesc. Note that this is not the same as the number
    /// of bits per sample.
    ///
    /// The returned number of bits refers to the number of bits actually
    /// used for storing the pixel information, that is padding bits are
    /// not counted.
    pub fn av_get_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor) -> libc::c_int;
}
extern "C" {
    /// Return the number of bits per pixel for the pixel format
    /// described by pixdesc, including any padding or unused bits.
    pub fn av_get_padded_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor) -> libc::c_int;
}
extern "C" {
    /// @return a pixel format descriptor for provided pixel format or NULL if
    /// this pixel format is unknown.
    pub fn av_pix_fmt_desc_get(pix_fmt: AVPixelFormat) -> *const AVPixFmtDescriptor;
}
extern "C" {
    /// Iterate over all pixel format descriptors known to libavutil.
    ///
    /// @param prev previous descriptor. NULL to get the first descriptor.
    ///
    /// @return next descriptor or NULL after the last descriptor
    pub fn av_pix_fmt_desc_next(prev: *const AVPixFmtDescriptor) -> *const AVPixFmtDescriptor;
}
extern "C" {
    /// @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc
    /// is not a valid pointer to a pixel format descriptor.
    pub fn av_pix_fmt_desc_get_id(desc: *const AVPixFmtDescriptor) -> AVPixelFormat;
}
extern "C" {
    /// Utility function to access log2_chroma_w log2_chroma_h from
    /// the pixel format AVPixFmtDescriptor.
    ///
    /// See av_get_chroma_sub_sample() for a function that asserts a
    /// valid pixel format instead of returning an error code.
    /// Its recommended that you use avcodec_get_chroma_sub_sample unless
    /// you do check the return code!
    ///
    /// @param[in]  pix_fmt the pixel format
    /// @param[out] h_shift store log2_chroma_w (horizontal/width shift)
    /// @param[out] v_shift store log2_chroma_h (vertical/height shift)
    ///
    /// @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format
    pub fn av_pix_fmt_get_chroma_sub_sample(
        pix_fmt: AVPixelFormat,
        h_shift: *mut libc::c_int,
        v_shift: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a
    /// valid pixel format.
    pub fn av_pix_fmt_count_planes(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    /// @return the name for provided color range or NULL if unknown.
    pub fn av_color_range_name(range: AVColorRange) -> *const libc::c_char;
}
extern "C" {
    /// @return the AVColorRange value for name or an AVError if not found.
    pub fn av_color_range_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// @return the name for provided color primaries or NULL if unknown.
    pub fn av_color_primaries_name(primaries: AVColorPrimaries) -> *const libc::c_char;
}
extern "C" {
    /// @return the AVColorPrimaries value for name or an AVError if not found.
    pub fn av_color_primaries_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// @return the name for provided color transfer or NULL if unknown.
    pub fn av_color_transfer_name(transfer: AVColorTransferCharacteristic) -> *const libc::c_char;
}
extern "C" {
    /// @return the AVColorTransferCharacteristic value for name or an AVError if not found.
    pub fn av_color_transfer_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// @return the name for provided color space or NULL if unknown.
    pub fn av_color_space_name(space: AVColorSpace) -> *const libc::c_char;
}
extern "C" {
    /// @return the AVColorSpace value for name or an AVError if not found.
    pub fn av_color_space_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// @return the name for provided chroma location or NULL if unknown.
    pub fn av_chroma_location_name(location: AVChromaLocation) -> *const libc::c_char;
}
extern "C" {
    /// @return the AVChromaLocation value for name or an AVError if not found.
    pub fn av_chroma_location_from_name(name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Return the pixel format corresponding to name.
    ///
    /// If there is no pixel format with name name, then looks for a
    /// pixel format with the name corresponding to the native endian
    /// format of name.
    /// For example in a little-endian system, first looks for "gray16",
    /// then for "gray16le".
    ///
    /// Finally if no pixel format has been found, returns AV_PIX_FMT_NONE.
    pub fn av_get_pix_fmt(name: *const libc::c_char) -> AVPixelFormat;
}
extern "C" {
    /// Return the short name for a pixel format, NULL in case pix_fmt is
    /// unknown.
    ///
    /// @see av_get_pix_fmt(), av_get_pix_fmt_string()
    pub fn av_get_pix_fmt_name(pix_fmt: AVPixelFormat) -> *const libc::c_char;
}
extern "C" {
    /// Print in buf the string corresponding to the pixel format with
    /// number pix_fmt, or a header if pix_fmt is negative.
    ///
    /// @param buf the buffer where to write the string
    /// @param buf_size the size of buf
    /// @param pix_fmt the number of the pixel format to print the
    /// corresponding info string, or a negative value to print the
    /// corresponding header.
    pub fn av_get_pix_fmt_string(
        buf: *mut libc::c_char,
        buf_size: libc::c_int,
        pix_fmt: AVPixelFormat,
    ) -> *mut libc::c_char;
}
extern "C" {
    /// Read a line from an image, and write the values of the
    /// pixel format component c to dst.
    ///
    /// @param data the array containing the pointers to the planes of the image
    /// @param linesize the array containing the linesizes of the image
    /// @param desc the pixel format descriptor for the image
    /// @param x the horizontal coordinate of the first pixel to read
    /// @param y the vertical coordinate of the first pixel to read
    /// @param w the width of the line to read, that is the number of
    /// values to write to dst
    /// @param read_pal_component if not zero and the format is a paletted
    /// format writes the values corresponding to the palette
    /// component c in data[1] to dst, rather than the palette indexes in
    /// data[0]. The behavior is undefined if the format is not paletted.
    pub fn av_read_image_line(
        dst: *mut u16,
        data: *mut *const u8,
        linesize: *const libc::c_int,
        desc: *const AVPixFmtDescriptor,
        x: libc::c_int,
        y: libc::c_int,
        c: libc::c_int,
        w: libc::c_int,
        read_pal_component: libc::c_int,
    );
}
extern "C" {
    /// Write the values from src to the pixel format component c of an
    /// image line.
    ///
    /// @param src array containing the values to write
    /// @param data the array containing the pointers to the planes of the
    /// image to write into. It is supposed to be zeroed.
    /// @param linesize the array containing the linesizes of the image
    /// @param desc the pixel format descriptor for the image
    /// @param x the horizontal coordinate of the first pixel to write
    /// @param y the vertical coordinate of the first pixel to write
    /// @param w the width of the line to write, that is the number of
    /// values to write to the image line
    pub fn av_write_image_line(
        src: *const u16,
        data: *mut *mut u8,
        linesize: *const libc::c_int,
        desc: *const AVPixFmtDescriptor,
        x: libc::c_int,
        y: libc::c_int,
        c: libc::c_int,
        w: libc::c_int,
    );
}
extern "C" {
    /// Utility function to swap the endianness of a pixel format.
    ///
    /// @param[in]  pix_fmt the pixel format
    ///
    /// @return pixel format with swapped endianness if it exists,
    /// otherwise AV_PIX_FMT_NONE
    pub fn av_pix_fmt_swap_endianness(pix_fmt: AVPixelFormat) -> AVPixelFormat;
}
extern "C" {
    /// Compute what kind of losses will occur when converting from one specific
    /// pixel format to another.
    /// When converting from one pixel format to another, information loss may occur.
    /// For example, when converting from RGB24 to GRAY, the color information will
    /// be lost. Similarly, other losses occur when converting from some formats to
    /// other formats. These losses can involve loss of chroma, but also loss of
    /// resolution, loss of color depth, loss due to the color space conversion, loss
    /// of the alpha bits or loss due to color quantization.
    /// av_get_fix_fmt_loss() informs you about the various types of losses
    /// which will occur when converting from one pixel format to another.
    ///
    /// @param[in] dst_pix_fmt destination pixel format
    /// @param[in] src_pix_fmt source pixel format
    /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
    /// @return Combination of flags informing you what kind of losses will occur
    /// (maximum loss for an invalid dst_pix_fmt).
    pub fn av_get_pix_fmt_loss(
        dst_pix_fmt: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Compute what kind of losses will occur when converting from one specific
    /// pixel format to another.
    /// When converting from one pixel format to another, information loss may occur.
    /// For example, when converting from RGB24 to GRAY, the color information will
    /// be lost. Similarly, other losses occur when converting from some formats to
    /// other formats. These losses can involve loss of chroma, but also loss of
    /// resolution, loss of color depth, loss due to the color space conversion, loss
    /// of the alpha bits or loss due to color quantization.
    /// av_get_fix_fmt_loss() informs you about the various types of losses
    /// which will occur when converting from one pixel format to another.
    ///
    /// @param[in] dst_pix_fmt destination pixel format
    /// @param[in] src_pix_fmt source pixel format
    /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
    /// @return Combination of flags informing you what kind of losses will occur
    /// (maximum loss for an invalid dst_pix_fmt).
    pub fn av_find_best_pix_fmt_of_2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: libc::c_int,
        loss_ptr: *mut libc::c_int,
    ) -> AVPixelFormat;
}
extern "C" {
    /// Compute the max pixel step for each plane of an image with a
    /// format described by pixdesc.
    ///
    /// The pixel step is the distance in bytes between the first byte of
    /// the group of bytes which describe a pixel component and the first
    /// byte of the successive group in the same plane for the same
    /// component.
    ///
    /// @param max_pixsteps an array which is filled with the max pixel step
    /// for each plane. Since a plane may contain different pixel
    /// components, the computed max_pixsteps[plane] is relative to the
    /// component in the plane with the max pixel step.
    /// @param max_pixstep_comps an array which is filled with the component
    /// for each plane which has the max pixel step. May be NULL.
    pub fn av_image_fill_max_pixsteps(
        max_pixsteps: *mut libc::c_int,
        max_pixstep_comps: *mut libc::c_int,
        pixdesc: *const AVPixFmtDescriptor,
    );
}
extern "C" {
    /// Compute the size of an image line with format pix_fmt and width
    /// width for the plane plane.
    ///
    /// @return the computed size in bytes
    pub fn av_image_get_linesize(
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        plane: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Fill plane linesizes for an image with pixel format pix_fmt and
    /// width width.
    ///
    /// @param linesizes array to be filled with the linesize for each plane
    /// @return >= 0 in case of success, a negative error code otherwise
    pub fn av_image_fill_linesizes(
        linesizes: *mut libc::c_int,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Fill plane data pointers for an image with pixel format pix_fmt and
    /// height height.
    ///
    /// @param data pointers array to be filled with the pointer for each image plane
    /// @param ptr the pointer to a buffer which will contain the image
    /// @param linesizes the array containing the linesize for each
    /// plane, should be filled by av_image_fill_linesizes()
    /// @return the size in bytes required for the image buffer, a negative
    /// error code in case of failure
    pub fn av_image_fill_pointers(
        data: *mut *mut u8,
        pix_fmt: AVPixelFormat,
        height: libc::c_int,
        ptr: *mut u8,
        linesizes: *const libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Allocate an image with size w and h and pixel format pix_fmt, and
    /// fill pointers and linesizes accordingly.
    /// The allocated image buffer has to be freed by using
    /// av_freep(&pointers[0]).
    ///
    /// @param align the value to use for buffer size alignment
    /// @return the size in bytes required for the image buffer, a negative
    /// error code in case of failure
    pub fn av_image_alloc(
        pointers: *mut *mut u8,
        linesizes: *mut libc::c_int,
        w: libc::c_int,
        h: libc::c_int,
        pix_fmt: AVPixelFormat,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Copy image plane from src to dst.
    /// That is, copy "height" number of lines of "bytewidth" bytes each.
    /// The first byte of each successive line is separated by *_linesize
    /// bytes.
    ///
    /// bytewidth must be contained by both absolute values of dst_linesize
    /// and src_linesize, otherwise the function behavior is undefined.
    ///
    /// @param dst_linesize linesize for the image plane in dst
    /// @param src_linesize linesize for the image plane in src
    pub fn av_image_copy_plane(
        dst: *mut u8,
        dst_linesize: libc::c_int,
        src: *const u8,
        src_linesize: libc::c_int,
        bytewidth: libc::c_int,
        height: libc::c_int,
    );
}
extern "C" {
    /// Copy image in src_data to dst_data.
    ///
    /// @param dst_linesizes linesizes for the image in dst_data
    /// @param src_linesizes linesizes for the image in src_data
    pub fn av_image_copy(
        dst_data: *mut *mut u8,
        dst_linesizes: *mut libc::c_int,
        src_data: *mut *const u8,
        src_linesizes: *const libc::c_int,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    );
}
extern "C" {
    /// Copy image data located in uncacheable (e.g. GPU mapped) memory. Where
    /// available, this function will use special functionality for reading from such
    /// memory, which may result in greatly improved performance compared to plain
    /// av_image_copy().
    ///
    /// The data pointers and the linesizes must be aligned to the maximum required
    /// by the CPU architecture.
    ///
    /// @note The linesize parameters have the type ptrdiff_t here, while they are
    /// int for av_image_copy().
    /// @note On x86, the linesizes currently need to be aligned to the cacheline
    /// size (i.e. 64) to get improved performance.
    pub fn av_image_copy_uc_from(
        dst_data: *mut *mut u8,
        dst_linesizes: *const isize,
        src_data: *mut *const u8,
        src_linesizes: *const isize,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
    );
}
extern "C" {
    /// Setup the data pointers and linesizes based on the specified image
    /// parameters and the provided array.
    ///
    /// The fields of the given image are filled in by using the src
    /// address which points to the image data buffer. Depending on the
    /// specified pixel format, one or multiple image data pointers and
    /// line sizes will be set.  If a planar format is specified, several
    /// pointers will be set pointing to the different picture planes and
    /// the line sizes of the different planes will be stored in the
    /// lines_sizes array. Call with src == NULL to get the required
    /// size for the src buffer.
    ///
    /// To allocate the buffer and fill in the dst_data and dst_linesize in
    /// one call, use av_image_alloc().
    ///
    /// @param dst_data      data pointers to be filled in
    /// @param dst_linesize  linesizes for the image in dst_data to be filled in
    /// @param src           buffer which will contain or contains the actual image data, can be NULL
    /// @param pix_fmt       the pixel format of the image
    /// @param width         the width of the image in pixels
    /// @param height        the height of the image in pixels
    /// @param align         the value used in src for linesize alignment
    /// @return the size in bytes required for src, a negative error code
    /// in case of failure
    pub fn av_image_fill_arrays(
        dst_data: *mut *mut u8,
        dst_linesize: *mut libc::c_int,
        src: *const u8,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Return the size in bytes of the amount of data required to store an
    /// image with the given parameters.
    ///
    /// @param pix_fmt  the pixel format of the image
    /// @param width    the width of the image in pixels
    /// @param height   the height of the image in pixels
    /// @param align    the assumed linesize alignment
    /// @return the buffer size in bytes, a negative error code in case of failure
    pub fn av_image_get_buffer_size(
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Copy image data from an image into a buffer.
    ///
    /// av_image_get_buffer_size() can be used to compute the required size
    /// for the buffer to fill.
    ///
    /// @param dst           a buffer into which picture data will be copied
    /// @param dst_size      the size in bytes of dst
    /// @param src_data      pointers containing the source image data
    /// @param src_linesize  linesizes for the image in src_data
    /// @param pix_fmt       the pixel format of the source image
    /// @param width         the width of the source image in pixels
    /// @param height        the height of the source image in pixels
    /// @param align         the assumed linesize alignment for dst
    /// @return the number of bytes written to dst, or a negative value
    /// (error code) on error
    pub fn av_image_copy_to_buffer(
        dst: *mut u8,
        dst_size: libc::c_int,
        src_data: *const *const u8,
        src_linesize: *const libc::c_int,
        pix_fmt: AVPixelFormat,
        width: libc::c_int,
        height: libc::c_int,
        align: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Check if the given dimension of an image is valid, meaning that all
    /// bytes of the image can be addressed with a signed int.
    ///
    /// @param w the width of the picture
    /// @param h the height of the picture
    /// @param log_offset the offset to sum to the log level for logging with log_ctx
    /// @param log_ctx the parent logging context, it may be NULL
    /// @return >= 0 if valid, a negative error code otherwise
    pub fn av_image_check_size(
        w: libc::c_uint,
        h: libc::c_uint,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Check if the given dimension of an image is valid, meaning that all
    /// bytes of a plane of an image with the specified pix_fmt can be addressed
    /// with a signed int.
    ///
    /// @param w the width of the picture
    /// @param h the height of the picture
    /// @param max_pixels the maximum number of pixels the user wants to accept
    /// @param pix_fmt the pixel format, can be AV_PIX_FMT_NONE if unknown.
    /// @param log_offset the offset to sum to the log level for logging with log_ctx
    /// @param log_ctx the parent logging context, it may be NULL
    /// @return >= 0 if valid, a negative error code otherwise
    pub fn av_image_check_size2(
        w: libc::c_uint,
        h: libc::c_uint,
        max_pixels: i64,
        pix_fmt: AVPixelFormat,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Check if the given sample aspect ratio of an image is valid.
    ///
    /// It is considered invalid if the denominator is 0 or if applying the ratio
    /// to the image size would make the smaller dimension less than 1. If the
    /// sar numerator is 0, it is considered unknown and will return as valid.
    ///
    /// @param w width of the image
    /// @param h height of the image
    /// @param sar sample aspect ratio of the image
    /// @return 0 if valid, a negative AVERROR code otherwise
    pub fn av_image_check_sar(w: libc::c_uint, h: libc::c_uint, sar: AVRational) -> libc::c_int;
}
extern "C" {
    /// Overwrite the image data with black. This is suitable for filling a
    /// sub-rectangle of an image, meaning the padding between the right most pixel
    /// and the left most pixel on the next line will not be overwritten. For some
    /// formats, the image size might be rounded up due to inherent alignment.
    ///
    /// If the pixel format has alpha, the alpha is cleared to opaque.
    ///
    /// This can return an error if the pixel format is not supported. Normally, all
    /// non-hwaccel pixel formats should be supported.
    ///
    /// Passing NULL for dst_data is allowed. Then the function returns whether the
    /// operation would have succeeded. (It can return an error if the pix_fmt is
    /// not supported.)
    ///
    /// @param dst_data      data pointers to destination image
    /// @param dst_linesize  linesizes for the destination image
    /// @param pix_fmt       the pixel format of the image
    /// @param range         the color range of the image (important for colorspaces such as YUV)
    /// @param width         the width of the image in pixels
    /// @param height        the height of the image in pixels
    /// @return 0 if the image data was cleared, a negative AVERROR code otherwise
    pub fn av_image_fill_black(
        dst_data: *mut *mut u8,
        dst_linesize: *const isize,
        pix_fmt: AVPixelFormat,
        range: AVColorRange,
        width: libc::c_int,
        height: libc::c_int,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct AVLFG {
    pub state: [libc::c_uint; 64usize],
    pub index: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVLFG() {
    assert_eq!(
        ::std::mem::size_of::<AVLFG>(),
        260usize,
        concat!("Size of: ", stringify!(AVLFG))
    );
    assert_eq!(
        ::std::mem::align_of::<AVLFG>(),
        4usize,
        concat!("Alignment of ", stringify!(AVLFG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVLFG>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVLFG),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVLFG>())).index as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(AVLFG),
            "::",
            stringify!(index)
        )
    );
}
extern "C" {
    pub fn av_lfg_init(c: *mut AVLFG, seed: libc::c_uint);
}
extern "C" {
    /// Seed the state of the ALFG using binary data.
    ///
    /// Return value: 0 on success, negative value (AVERROR) on failure.
    pub fn av_lfg_init_from_data(
        c: *mut AVLFG,
        data: *const u8,
        length: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    /// Get the next two numbers generated by a Box-Muller Gaussian
    /// generator using the random numbers issued by lfg.
    ///
    /// @param out array where the two generated numbers are placed
    pub fn av_bmg_get(lfg: *mut AVLFG, out: *mut f64);
}
extern "C" {
    /// @brief Decodes LZO 1x compressed data.
    /// @param out output buffer
    /// @param outlen size of output buffer, number of bytes left are returned here
    /// @param in input buffer
    /// @param inlen size of input buffer, number of bytes left are returned here
    /// @return 0 on success, otherwise a combination of the error flags above
    ///
    /// Make sure all buffers are appropriately padded, in must provide
    /// AV_LZO_INPUT_PADDING, out must provide AV_LZO_OUTPUT_PADDING additional bytes.
    pub fn av_lzo1x_decode(
        out: *mut libc::c_void,
        outlen: *mut libc::c_int,
        in_: *const libc::c_void,
        inlen: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub static mut av_md5_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVMD5 {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate an AVMD5 context.
    pub fn av_md5_alloc() -> *mut AVMD5;
}
extern "C" {
    /// Initialize MD5 hashing.
    ///
    /// @param ctx pointer to the function context (of size av_md5_size)
    pub fn av_md5_init(ctx: *mut AVMD5);
}
extern "C" {
    pub fn av_md5_update(ctx: *mut AVMD5, src: *const u8, len: libc::c_int);
}
extern "C" {
    /// Finish hashing and output digest value.
    ///
    /// @param ctx hash function context
    /// @param dst buffer where output digest value is stored
    pub fn av_md5_final(ctx: *mut AVMD5, dst: *mut u8);
}
extern "C" {
    pub fn av_md5_sum(dst: *mut u8, src: *const u8, len: libc::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVMotionVector {
    /// Where the current macroblock comes from; negative value when it comes
    /// from the past, positive value when it comes from the future.
    /// XXX: set exact relative ref frame reference instead of a +/- 1 "direction".
    pub source: i32,
    /// Width and height of the block.
    pub w: u8,
    /// Width and height of the block.
    pub h: u8,
    /// Absolute source position. Can be outside the frame area.
    pub src_x: i16,
    /// Absolute source position. Can be outside the frame area.
    pub src_y: i16,
    /// Absolute destination position. Can be outside the frame area.
    pub dst_x: i16,
    /// Absolute destination position. Can be outside the frame area.
    pub dst_y: i16,
    /// Extra flag information.
    /// Currently unused.
    pub flags: u64,
    /// Motion vector
    /// src_x = dst_x + motion_x / motion_scale
    /// src_y = dst_y + motion_y / motion_scale
    pub motion_x: i32,
    /// Motion vector
    /// src_x = dst_x + motion_x / motion_scale
    /// src_y = dst_y + motion_y / motion_scale
    pub motion_y: i32,
    pub motion_scale: u16,
}
#[test]
fn bindgen_test_layout_AVMotionVector() {
    assert_eq!(
        ::std::mem::size_of::<AVMotionVector>(),
        40usize,
        concat!("Size of: ", stringify!(AVMotionVector))
    );
    assert_eq!(
        ::std::mem::align_of::<AVMotionVector>(),
        8usize,
        concat!("Alignment of ", stringify!(AVMotionVector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).source as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).w as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).h as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).src_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(src_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).src_y as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(src_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).dst_x as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(dst_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).dst_y as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(dst_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).motion_x as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(motion_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).motion_y as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(motion_y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVMotionVector>())).motion_scale as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AVMotionVector),
            "::",
            stringify!(motion_scale)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVMurMur3 {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate an AVMurMur3 hash context.
    ///
    /// @return Uninitialized hash context or `NULL` in case of error
    pub fn av_murmur3_alloc() -> *mut AVMurMur3;
}
extern "C" {
    /// Initialize or reinitialize an AVMurMur3 hash context with a seed.
    ///
    /// @param[out] c    Hash context
    /// @param[in]  seed Random seed
    ///
    /// @see av_murmur3_init()
    /// @see @ref lavu_murmur3_seedinfo "Detailed description" on a discussion of
    /// seeds for MurmurHash3.
    pub fn av_murmur3_init_seeded(c: *mut AVMurMur3, seed: u64);
}
extern "C" {
    /// Initialize or reinitialize an AVMurMur3 hash context.
    ///
    /// Equivalent to av_murmur3_init_seeded() with a built-in seed.
    ///
    /// @param[out] c    Hash context
    ///
    /// @see av_murmur3_init_seeded()
    /// @see @ref lavu_murmur3_seedinfo "Detailed description" on a discussion of
    /// seeds for MurmurHash3.
    pub fn av_murmur3_init(c: *mut AVMurMur3);
}
extern "C" {
    /// Update hash context with new data.
    ///
    /// @param[out] c    Hash context
    /// @param[in]  src  Input data to update hash with
    /// @param[in]  len  Number of bytes to read from `src`
    pub fn av_murmur3_update(c: *mut AVMurMur3, src: *const u8, len: libc::c_int);
}
extern "C" {
    /// Finish hashing and output digest value.
    ///
    /// @param[in,out] c    Hash context
    /// @param[out]    dst  Buffer where output digest value is stored
    pub fn av_murmur3_final(c: *mut AVMurMur3, dst: *mut u8);
}
extern "C" {
    /// Parse str and store the parsed ratio in q.
    ///
    /// Note that a ratio with infinite (1/0) or negative value is
    /// considered valid, so you should check on the returned value if you
    /// want to exclude those values.
    ///
    /// The undefined value can be expressed using the "0:0" string.
    ///
    /// @param[in,out] q pointer to the AVRational which will contain the ratio
    /// @param[in] str the string to parse: it has to be a string in the format
    /// num:den, a float number or an expression
    /// @param[in] max the maximum allowed numerator and denominator
    /// @param[in] log_offset log level offset which is applied to the log
    /// level of log_ctx
    /// @param[in] log_ctx parent logging context
    /// @return >= 0 on success, a negative error code otherwise
    pub fn av_parse_ratio(
        q: *mut AVRational,
        str: *const libc::c_char,
        max: libc::c_int,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Parse str and put in width_ptr and height_ptr the detected values.
    ///
    /// @param[in,out] width_ptr pointer to the variable which will contain the detected
    /// width value
    /// @param[in,out] height_ptr pointer to the variable which will contain the detected
    /// height value
    /// @param[in] str the string to parse: it has to be a string in the format
    /// width x height or a valid video size abbreviation.
    /// @return >= 0 on success, a negative error code otherwise
    pub fn av_parse_video_size(
        width_ptr: *mut libc::c_int,
        height_ptr: *mut libc::c_int,
        str: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    /// Parse str and store the detected values in *rate.
    ///
    /// @param[in,out] rate pointer to the AVRational which will contain the detected
    /// frame rate
    /// @param[in] str the string to parse: it has to be a string in the format
    /// rate_num / rate_den, a float number or a valid video rate abbreviation
    /// @return >= 0 on success, a negative error code otherwise
    pub fn av_parse_video_rate(rate: *mut AVRational, str: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    /// Put the RGBA values that correspond to color_string in rgba_color.
    ///
    /// @param color_string a string specifying a color. It can be the name of
    /// a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,
    /// possibly followed by "@" and a string representing the alpha
    /// component.
    /// The alpha component may be a string composed by "0x" followed by an
    /// hexadecimal number or a decimal number between 0.0 and 1.0, which
    /// represents the opacity value (0x00/0.0 means completely transparent,
    /// 0xff/1.0 completely opaque).
    /// If the alpha component is not specified then 0xff is assumed.
    /// The string "random" will result in a random color.
    /// @param slen length of the initial part of color_string containing the
    /// color. It can be set to -1 if color_string is a null terminated string
    /// containing nothing else than the color.
    /// @return >= 0 in case of success, a negative value in case of
    /// failure (for example if color_string cannot be parsed).
    pub fn av_parse_color(
        rgba_color: *mut u8,
        color_string: *const libc::c_char,
        slen: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Get the name of a color from the internal table of hard-coded named
    /// colors.
    ///
    /// This function is meant to enumerate the color names recognized by
    /// av_parse_color().
    ///
    /// @param color_idx index of the requested color, starting from 0
    /// @param rgbp      if not NULL, will point to a 3-elements array with the color value in RGB
    /// @return the color name string or NULL if color_idx is not in the array
    pub fn av_get_known_color_name(
        color_idx: libc::c_int,
        rgb: *mut *const u8,
    ) -> *const libc::c_char;
}
extern "C" {
    /// Parse timestr and return in *time a corresponding number of
    /// microseconds.
    ///
    /// @param timeval puts here the number of microseconds corresponding
    /// to the string in timestr. If the string represents a duration, it
    /// is the number of microseconds contained in the time interval.  If
    /// the string is a date, is the number of microseconds since 1st of
    /// January, 1970 up to the time of the parsed date.  If timestr cannot
    /// be successfully parsed, set *time to INT64_MIN.
    ///
    /// @param timestr a string representing a date or a duration.
    /// - If a date the syntax is:
    /// @code
    /// [{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]
    /// now
    /// @endcode
    /// If the value is "now" it takes the current time.
    /// Time is local time unless Z is appended, in which case it is
    /// interpreted as UTC.
    /// If the year-month-day part is not specified it takes the current
    /// year-month-day.
    /// - If a duration the syntax is:
    /// @code
    /// [-][HH:]MM:SS[.m...]
    /// [-]S+[.m...]
    /// @endcode
    /// @param duration flag which tells how to interpret timestr, if not
    /// zero timestr is interpreted as a duration, otherwise as a date
    /// @return >= 0 in case of success, a negative value corresponding to an
    /// AVERROR code otherwise
    pub fn av_parse_time(
        timeval: *mut i64,
        timestr: *const libc::c_char,
        duration: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Attempt to find a specific tag in a URL.
    ///
    /// syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done.
    /// Return 1 if found.
    pub fn av_find_info_tag(
        arg: *mut libc::c_char,
        arg_size: libc::c_int,
        tag1: *const libc::c_char,
        info: *const libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    /// Simplified version of strptime
    ///
    /// Parse the input string p according to the format string fmt and
    /// store its results in the structure dt.
    /// This implementation supports only a subset of the formats supported
    /// by the standard strptime().
    ///
    /// The supported input field descriptors are listed below.
    /// - %H: the hour as a decimal number, using a 24-hour clock, in the
    /// range '00' through '23'
    /// - %J: hours as a decimal number, in the range '0' through INT_MAX
    /// - %M: the minute as a decimal number, using a 24-hour clock, in the
    /// range '00' through '59'
    /// - %S: the second as a decimal number, using a 24-hour clock, in the
    /// range '00' through '59'
    /// - %Y: the year as a decimal number, using the Gregorian calendar
    /// - %m: the month as a decimal number, in the range '1' through '12'
    /// - %d: the day of the month as a decimal number, in the range '1'
    /// through '31'
    /// - %T: alias for '%H:%M:%S'
    /// - %%: a literal '%'
    ///
    /// @return a pointer to the first character not processed in this function
    /// call. In case the input string contains more characters than
    /// required by the format string the return value points right after
    /// the last consumed input character. In case the whole input string
    /// is consumed the return value points to the null byte at the end of
    /// the string. On failure NULL is returned.
    pub fn av_small_strptime(
        p: *const libc::c_char,
        fmt: *const libc::c_char,
        dt: *mut tm,
    ) -> *mut libc::c_char;
}
extern "C" {
    /// Convert the decomposed UTC time in tm to a time_t value.
    pub fn av_timegm(tm: *mut tm) -> time_t;
}
extern "C" {
    /// Get a seed to use in conjunction with random functions.
    /// This function tries to provide a good seed at a best effort bases.
    /// Its possible to call this function multiple times if more bits are needed.
    /// It can be quite slow, which is why it should only be used as seed for a faster
    /// PRNG. The quality of the seed depends on the platform.
    pub fn av_get_random_seed() -> u32;
}
/// ReplayGain information (see
/// http://wiki.hydrogenaudio.org/index.php?title=ReplayGain_1.0_specification).
/// The size of this struct is a part of the public ABI.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVReplayGain {
    /// Track replay gain in microbels (divide by 100000 to get the value in dB).
    /// Should be set to INT32_MIN when unknown.
    pub track_gain: i32,
    /// Peak track amplitude, with 100000 representing full scale (but values
    /// may overflow). 0 when unknown.
    pub track_peak: u32,
    /// Same as track_gain, but for the whole album.
    pub album_gain: i32,
    /// Same as track_peak, but for the whole album,
    pub album_peak: u32,
}
#[test]
fn bindgen_test_layout_AVReplayGain() {
    assert_eq!(
        ::std::mem::size_of::<AVReplayGain>(),
        16usize,
        concat!("Size of: ", stringify!(AVReplayGain))
    );
    assert_eq!(
        ::std::mem::align_of::<AVReplayGain>(),
        4usize,
        concat!("Alignment of ", stringify!(AVReplayGain))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVReplayGain>())).track_gain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVReplayGain),
            "::",
            stringify!(track_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVReplayGain>())).track_peak as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVReplayGain),
            "::",
            stringify!(track_peak)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVReplayGain>())).album_gain as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVReplayGain),
            "::",
            stringify!(album_gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVReplayGain>())).album_peak as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(AVReplayGain),
            "::",
            stringify!(album_peak)
        )
    );
}
extern "C" {
    pub static mut av_ripemd_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVRIPEMD {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate an AVRIPEMD context.
    pub fn av_ripemd_alloc() -> *mut AVRIPEMD;
}
extern "C" {
    /// Initialize RIPEMD hashing.
    ///
    /// @param context pointer to the function context (of size av_ripemd_size)
    /// @param bits    number of bits in digest (128, 160, 256 or 320 bits)
    /// @return        zero if initialization succeeded, -1 otherwise
    pub fn av_ripemd_init(context: *mut AVRIPEMD, bits: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// Update hash value.
    ///
    /// @param context hash function context
    /// @param data    input data to update hash with
    /// @param len     input data length
    pub fn av_ripemd_update(context: *mut AVRIPEMD, data: *const u8, len: libc::c_uint);
}
extern "C" {
    /// Finish hashing and output digest value.
    ///
    /// @param context hash function context
    /// @param digest  buffer where output digest value is stored
    pub fn av_ripemd_final(context: *mut AVRIPEMD, digest: *mut u8);
}
extern "C" {
    pub static mut av_sha_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSHA {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate an AVSHA context.
    pub fn av_sha_alloc() -> *mut AVSHA;
}
extern "C" {
    /// Initialize SHA-1 or SHA-2 hashing.
    ///
    /// @param context pointer to the function context (of size av_sha_size)
    /// @param bits    number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)
    /// @return        zero if initialization succeeded, -1 otherwise
    pub fn av_sha_init(context: *mut AVSHA, bits: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_sha_update(ctx: *mut AVSHA, data: *const u8, len: libc::c_uint);
}
extern "C" {
    /// Finish hashing and output digest value.
    ///
    /// @param context hash function context
    /// @param digest  buffer where output digest value is stored
    pub fn av_sha_final(context: *mut AVSHA, digest: *mut u8);
}
extern "C" {
    pub static mut av_sha512_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVSHA512 {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate an AVSHA512 context.
    pub fn av_sha512_alloc() -> *mut AVSHA512;
}
extern "C" {
    /// Initialize SHA-2 512 hashing.
    ///
    /// @param context pointer to the function context (of size av_sha512_size)
    /// @param bits    number of bits in digest (224, 256, 384 or 512 bits)
    /// @return        zero if initialization succeeded, -1 otherwise
    pub fn av_sha512_init(context: *mut AVSHA512, bits: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn av_sha512_update(context: *mut AVSHA512, data: *const u8, len: libc::c_uint);
}
extern "C" {
    /// Finish hashing and output digest value.
    ///
    /// @param context hash function context
    /// @param digest  buffer where output digest value is stored
    pub fn av_sha512_final(context: *mut AVSHA512, digest: *mut u8);
}
#[repr(u32)]
/// List of possible 3D Types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVStereo3DType {
    AV_STEREO3D_2D = 0,
    AV_STEREO3D_SIDEBYSIDE = 1,
    AV_STEREO3D_TOPBOTTOM = 2,
    AV_STEREO3D_FRAMESEQUENCE = 3,
    AV_STEREO3D_CHECKERBOARD = 4,
    AV_STEREO3D_SIDEBYSIDE_QUINCUNX = 5,
    AV_STEREO3D_LINES = 6,
    AV_STEREO3D_COLUMNS = 7,
}
/// Stereo 3D type: this structure describes how two videos are packed
/// within a single video surface, with additional information as needed.
///
/// @note The struct must be allocated with av_stereo3d_alloc() and
/// its size is not a part of the public ABI.
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVStereo3D {
    /// How views are packed within the video.
    pub type_: AVStereo3DType,
    /// Additional information about the frame packing.
    pub flags: libc::c_int,
}
#[test]
fn bindgen_test_layout_AVStereo3D() {
    assert_eq!(
        ::std::mem::size_of::<AVStereo3D>(),
        8usize,
        concat!("Size of: ", stringify!(AVStereo3D))
    );
    assert_eq!(
        ::std::mem::align_of::<AVStereo3D>(),
        4usize,
        concat!("Alignment of ", stringify!(AVStereo3D))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStereo3D>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStereo3D),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVStereo3D>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVStereo3D),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    /// Allocate an AVStereo3D structure and set its fields to default values.
    /// The resulting struct can be freed using av_freep().
    ///
    /// @return An AVStereo3D filled with default values or NULL on failure.
    pub fn av_stereo3d_alloc() -> *mut AVStereo3D;
}
extern "C" {
    /// Allocate a complete AVFrameSideData and add it to the frame.
    ///
    /// @param frame The frame which side data is added to.
    ///
    /// @return The AVStereo3D structure to be filled by caller.
    pub fn av_stereo3d_create_side_data(frame: *mut AVFrame) -> *mut AVStereo3D;
}
extern "C" {
    /// Provide a human-readable name of a given stereo3d type.
    ///
    /// @param type The input stereo3d type value.
    ///
    /// @return The name of the stereo3d value, or "unknown".
    pub fn av_stereo3d_type_name(type_: libc::c_uint) -> *const libc::c_char;
}
extern "C" {
    /// Get the AVStereo3DType form a human-readable name.
    ///
    /// @param name The input string.
    ///
    /// @return The AVStereo3DType value, or -1 if not found.
    pub fn av_stereo3d_from_name(name: *const libc::c_char) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVThreadMessageQueue {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVThreadMessageFlags {
    AV_THREAD_MESSAGE_NONBLOCK = 1,
}
extern "C" {
    /// Allocate a new message queue.
    ///
    /// @param mq      pointer to the message queue
    /// @param nelem   maximum number of elements in the queue
    /// @param elsize  size of each element in the queue
    /// @return  >=0 for success; <0 for error, in particular AVERROR(ENOSYS) if
    /// lavu was built without thread support
    pub fn av_thread_message_queue_alloc(
        mq: *mut *mut AVThreadMessageQueue,
        nelem: libc::c_uint,
        elsize: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    /// Free a message queue.
    ///
    /// The message queue must no longer be in use by another thread.
    pub fn av_thread_message_queue_free(mq: *mut *mut AVThreadMessageQueue);
}
extern "C" {
    /// Send a message on the queue.
    pub fn av_thread_message_queue_send(
        mq: *mut AVThreadMessageQueue,
        msg: *mut libc::c_void,
        flags: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    /// Receive a message from the queue.
    pub fn av_thread_message_queue_recv(
        mq: *mut AVThreadMessageQueue,
        msg: *mut libc::c_void,
        flags: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    /// Set the sending error code.
    ///
    /// If the error code is set to non-zero, av_thread_message_queue_send() will
    /// return it immediately. Conventional values, such as AVERROR_EOF or
    /// AVERROR(EAGAIN), can be used to cause the sending thread to stop or
    /// suspend its operation.
    pub fn av_thread_message_queue_set_err_send(mq: *mut AVThreadMessageQueue, err: libc::c_int);
}
extern "C" {
    /// Set the receiving error code.
    ///
    /// If the error code is set to non-zero, av_thread_message_queue_recv() will
    /// return it immediately when there are no longer available messages.
    /// Conventional values, such as AVERROR_EOF or AVERROR(EAGAIN), can be used
    /// to cause the receiving thread to stop or suspend its operation.
    pub fn av_thread_message_queue_set_err_recv(mq: *mut AVThreadMessageQueue, err: libc::c_int);
}
extern "C" {
    /// Set the optional free message callback function which will be called if an
    /// operation is removing messages from the queue.
    pub fn av_thread_message_queue_set_free_func(
        mq: *mut AVThreadMessageQueue,
        free_func: ::std::option::Option<unsafe extern "C" fn(msg: *mut libc::c_void)>,
    );
}
extern "C" {
    /// Flush the message queue
    ///
    /// This function is mostly equivalent to reading and free-ing every message
    /// except that it will be done in a single operation (no lock/unlock between
    /// reads).
    pub fn av_thread_message_flush(mq: *mut AVThreadMessageQueue);
}
extern "C" {
    /// Get the current time in microseconds.
    pub fn av_gettime() -> i64;
}
extern "C" {
    /// Get the current time in microseconds since some unspecified starting point.
    /// On platforms that support it, the time comes from a monotonic clock
    /// This property makes this time source ideal for measuring relative time.
    /// The returned values may not be monotonic on platforms where a monotonic
    /// clock is not available.
    pub fn av_gettime_relative() -> i64;
}
extern "C" {
    /// Indicates with a boolean result if the av_gettime_relative() time source
    /// is monotonic.
    pub fn av_gettime_relative_is_monotonic() -> libc::c_int;
}
extern "C" {
    /// Sleep for a period of time.  Although the duration is expressed in
    /// microseconds, the actual delay may be rounded to the precision of the
    /// system timer.
    ///
    /// @param  usec Number of microseconds to sleep.
    /// @return zero on success or (negative) error code.
    pub fn av_usleep(usec: libc::c_uint) -> libc::c_int;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum AVTimecodeFlag {
    AV_TIMECODE_FLAG_DROPFRAME = 1,
    AV_TIMECODE_FLAG_24HOURSMAX = 2,
    AV_TIMECODE_FLAG_ALLOWNEGATIVE = 4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVTimecode {
    /// < timecode frame start (first base frame number)
    pub start: libc::c_int,
    /// < flags such as drop frame, +24 hours support, ...
    pub flags: u32,
    /// < frame rate in rational form
    pub rate: AVRational,
    /// < frame per second; must be consistent with the rate field
    pub fps: libc::c_uint,
}
#[test]
fn bindgen_test_layout_AVTimecode() {
    assert_eq!(
        ::std::mem::size_of::<AVTimecode>(),
        20usize,
        concat!("Size of: ", stringify!(AVTimecode))
    );
    assert_eq!(
        ::std::mem::align_of::<AVTimecode>(),
        4usize,
        concat!("Alignment of ", stringify!(AVTimecode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVTimecode>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTimecode),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVTimecode>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTimecode),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVTimecode>())).rate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTimecode),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVTimecode>())).fps as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AVTimecode),
            "::",
            stringify!(fps)
        )
    );
}
extern "C" {
    /// Adjust frame number for NTSC drop frame time code.
    ///
    /// @param framenum frame number to adjust
    /// @param fps      frame per second, 30 or 60
    /// @return         adjusted frame number
    /// @warning        adjustment is only valid in NTSC 29.97 and 59.94
    pub fn av_timecode_adjust_ntsc_framenum2(
        framenum: libc::c_int,
        fps: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Convert frame number to SMPTE 12M binary representation.
    ///
    /// @param tc       timecode data correctly initialized
    /// @param framenum frame number
    /// @return         the SMPTE binary representation
    ///
    /// @note Frame number adjustment is automatically done in case of drop timecode,
    /// you do NOT have to call av_timecode_adjust_ntsc_framenum2().
    /// @note The frame number is relative to tc->start.
    /// @note Color frame (CF), binary group flags (BGF) and biphase mark polarity
    /// correction (PC) bits are set to zero.
    pub fn av_timecode_get_smpte_from_framenum(tc: *const AVTimecode, framenum: libc::c_int)
        -> u32;
}
extern "C" {
    /// Load timecode string in buf.
    ///
    /// @param buf      destination buffer, must be at least AV_TIMECODE_STR_SIZE long
    /// @param tc       timecode data correctly initialized
    /// @param framenum frame number
    /// @return         the buf parameter
    ///
    /// @note Timecode representation can be a negative timecode and have more than
    /// 24 hours, but will only be honored if the flags are correctly set.
    /// @note The frame number is relative to tc->start.
    pub fn av_timecode_make_string(
        tc: *const AVTimecode,
        buf: *mut libc::c_char,
        framenum: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    /// Get the timecode string from the SMPTE timecode format.
    ///
    /// @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long
    /// @param tcsmpte    the 32-bit SMPTE timecode
    /// @param prevent_df prevent the use of a drop flag when it is known the DF bit
    /// is arbitrary
    /// @return           the buf parameter
    pub fn av_timecode_make_smpte_tc_string(
        buf: *mut libc::c_char,
        tcsmpte: u32,
        prevent_df: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    /// Get the timecode string from the 25-bit timecode format (MPEG GOP format).
    ///
    /// @param buf     destination buffer, must be at least AV_TIMECODE_STR_SIZE long
    /// @param tc25bit the 25-bits timecode
    /// @return        the buf parameter
    pub fn av_timecode_make_mpeg_tc_string(
        buf: *mut libc::c_char,
        tc25bit: u32,
    ) -> *mut libc::c_char;
}
extern "C" {
    /// Init a timecode struct with the passed parameters.
    ///
    /// @param log_ctx     a pointer to an arbitrary struct of which the first field
    /// is a pointer to an AVClass struct (used for av_log)
    /// @param tc          pointer to an allocated AVTimecode
    /// @param rate        frame rate in rational form
    /// @param flags       miscellaneous flags such as drop frame, +24 hours, ...
    /// (see AVTimecodeFlag)
    /// @param frame_start the first frame number
    /// @return            0 on success, AVERROR otherwise
    pub fn av_timecode_init(
        tc: *mut AVTimecode,
        rate: AVRational,
        flags: libc::c_int,
        frame_start: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Parse timecode representation (hh:mm:ss[:;.]ff).
    ///
    /// @param log_ctx a pointer to an arbitrary struct of which the first field is a
    /// pointer to an AVClass struct (used for av_log).
    /// @param tc      pointer to an allocated AVTimecode
    /// @param rate    frame rate in rational form
    /// @param str     timecode string which will determine the frame start
    /// @return        0 on success, AVERROR otherwise
    pub fn av_timecode_init_from_string(
        tc: *mut AVTimecode,
        rate: AVRational,
        str: *const libc::c_char,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Check if the timecode feature is available for the given frame rate
    ///
    /// @return 0 if supported, <0 otherwise
    pub fn av_timecode_check_frame_rate(rate: AVRational) -> libc::c_int;
}
extern "C" {
    pub static mut av_twofish_size: libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AVTWOFISH {
    _unused: [u8; 0],
}
extern "C" {
    /// Allocate an AVTWOFISH context
    /// To free the struct: av_free(ptr)
    pub fn av_twofish_alloc() -> *mut AVTWOFISH;
}
extern "C" {
    /// Initialize an AVTWOFISH context.
    ///
    /// @param ctx an AVTWOFISH context
    /// @param key a key of size ranging from 1 to 32 bytes used for encryption/decryption
    /// @param key_bits number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key_bits is 128/192/256, -1 if less than 0, 1 otherwise
    pub fn av_twofish_init(
        ctx: *mut AVTWOFISH,
        key: *const u8,
        key_bits: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Encrypt or decrypt a buffer using a previously initialized context
    ///
    /// @param ctx an AVTWOFISH context
    /// @param dst destination array, can be equal to src
    /// @param src source array, can be equal to dst
    /// @param count number of 16 byte blocks
    /// @paran iv initialization vector for CBC mode, NULL for ECB mode
    /// @param decrypt 0 for encryption, 1 for decryption
    pub fn av_twofish_crypt(
        ctx: *mut AVTWOFISH,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
/// @file
/// @brief Public header for libavutil XTEA algorithm
/// @defgroup lavu_xtea XTEA
/// @ingroup lavu_crypto
/// @{
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVXTEA {
    pub key: [u32; 16usize],
}
#[test]
fn bindgen_test_layout_AVXTEA() {
    assert_eq!(
        ::std::mem::size_of::<AVXTEA>(),
        64usize,
        concat!("Size of: ", stringify!(AVXTEA))
    );
    assert_eq!(
        ::std::mem::align_of::<AVXTEA>(),
        4usize,
        concat!("Alignment of ", stringify!(AVXTEA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AVXTEA>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AVXTEA),
            "::",
            stringify!(key)
        )
    );
}
extern "C" {
    /// Allocate an AVXTEA context.
    pub fn av_xtea_alloc() -> *mut AVXTEA;
}
extern "C" {
    /// Initialize an AVXTEA context.
    ///
    /// @param ctx an AVXTEA context
    /// @param key a key of 16 bytes used for encryption/decryption,
    /// interpreted as big endian 32 bit numbers
    pub fn av_xtea_init(ctx: *mut AVXTEA, key: *const u8);
}
extern "C" {
    /// Initialize an AVXTEA context.
    ///
    /// @param ctx an AVXTEA context
    /// @param key a key of 16 bytes used for encryption/decryption,
    /// interpreted as little endian 32 bit numbers
    pub fn av_xtea_le_init(ctx: *mut AVXTEA, key: *const u8);
}
extern "C" {
    /// Encrypt or decrypt a buffer using a previously initialized context,
    /// in big endian format.
    ///
    /// @param ctx an AVXTEA context
    /// @param dst destination array, can be equal to src
    /// @param src source array, can be equal to dst
    /// @param count number of 8 byte blocks
    /// @param iv initialization vector for CBC mode, if NULL then ECB will be used
    /// @param decrypt 0 for encryption, 1 for decryption
    pub fn av_xtea_crypt(
        ctx: *mut AVXTEA,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
extern "C" {
    /// Encrypt or decrypt a buffer using a previously initialized context,
    /// in little endian format.
    ///
    /// @param ctx an AVXTEA context
    /// @param dst destination array, can be equal to src
    /// @param src source array, can be equal to dst
    /// @param count number of 8 byte blocks
    /// @param iv initialization vector for CBC mode, if NULL then ECB will be used
    /// @param decrypt 0 for encryption, 1 for decryption
    pub fn av_xtea_le_crypt(
        ctx: *mut AVXTEA,
        dst: *mut u8,
        src: *const u8,
        count: libc::c_int,
        iv: *mut u8,
        decrypt: libc::c_int,
    );
}
#[repr(u32)]
/// Dithering algorithms
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SwrDitherType {
    SWR_DITHER_NONE = 0,
    SWR_DITHER_RECTANGULAR = 1,
    SWR_DITHER_TRIANGULAR = 2,
    SWR_DITHER_TRIANGULAR_HIGHPASS = 3,
    SWR_DITHER_NS = 64,
    SWR_DITHER_NS_LIPSHITZ = 65,
    SWR_DITHER_NS_F_WEIGHTED = 66,
    SWR_DITHER_NS_MODIFIED_E_WEIGHTED = 67,
    SWR_DITHER_NS_IMPROVED_E_WEIGHTED = 68,
    SWR_DITHER_NS_SHIBATA = 69,
    SWR_DITHER_NS_LOW_SHIBATA = 70,
    SWR_DITHER_NS_HIGH_SHIBATA = 71,
    SWR_DITHER_NB = 72,
}
#[repr(u32)]
/// Resampling Engines
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SwrEngine {
    SWR_ENGINE_SWR = 0,
    SWR_ENGINE_SOXR = 1,
    SWR_ENGINE_NB = 2,
}
#[repr(u32)]
/// Resampling Filter Types
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum SwrFilterType {
    SWR_FILTER_TYPE_CUBIC = 0,
    SWR_FILTER_TYPE_BLACKMAN_NUTTALL = 1,
    SWR_FILTER_TYPE_KAISER = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwrContext {
    _unused: [u8; 0],
}
extern "C" {
    /// Get the AVClass for SwrContext. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    /// @return the AVClass of SwrContext
    pub fn swr_get_class() -> *const AVClass;
}
extern "C" {
    /// Allocate SwrContext.
    ///
    /// If you use this function you will need to set the parameters (manually or
    /// with swr_alloc_set_opts()) before calling swr_init().
    ///
    /// @see swr_alloc_set_opts(), swr_init(), swr_free()
    /// @return NULL on error, allocated context otherwise
    pub fn swr_alloc() -> *mut SwrContext;
}
extern "C" {
    /// Initialize context after user parameters have been set.
    /// @note The context must be configured using the AVOption API.
    ///
    /// @see av_opt_set_int()
    /// @see av_opt_set_dict()
    ///
    /// @param[in,out]   s Swr context to initialize
    /// @return AVERROR error code in case of failure.
    pub fn swr_init(s: *mut SwrContext) -> libc::c_int;
}
extern "C" {
    /// Check whether an swr context has been initialized or not.
    ///
    /// @param[in]       s Swr context to check
    /// @see swr_init()
    /// @return positive if it has been initialized, 0 if not initialized
    pub fn swr_is_initialized(s: *mut SwrContext) -> libc::c_int;
}
extern "C" {
    /// Allocate SwrContext if needed and set/reset common parameters.
    ///
    /// This function does not require s to be allocated with swr_alloc(). On the
    /// other hand, swr_alloc() can use swr_alloc_set_opts() to set the parameters
    /// on the allocated context.
    ///
    /// @param s               existing Swr context if available, or NULL if not
    /// @param out_ch_layout   output channel layout (AV_CH_LAYOUT_*)
    /// @param out_sample_fmt  output sample format (AV_SAMPLE_FMT_*).
    /// @param out_sample_rate output sample rate (frequency in Hz)
    /// @param in_ch_layout    input channel layout (AV_CH_LAYOUT_*)
    /// @param in_sample_fmt   input sample format (AV_SAMPLE_FMT_*).
    /// @param in_sample_rate  input sample rate (frequency in Hz)
    /// @param log_offset      logging level offset
    /// @param log_ctx         parent logging context, can be NULL
    ///
    /// @see swr_init(), swr_free()
    /// @return NULL on error, allocated context otherwise
    pub fn swr_alloc_set_opts(
        s: *mut SwrContext,
        out_ch_layout: i64,
        out_sample_fmt: AVSampleFormat,
        out_sample_rate: libc::c_int,
        in_ch_layout: i64,
        in_sample_fmt: AVSampleFormat,
        in_sample_rate: libc::c_int,
        log_offset: libc::c_int,
        log_ctx: *mut libc::c_void,
    ) -> *mut SwrContext;
}
extern "C" {
    /// Free the given SwrContext and set the pointer to NULL.
    ///
    /// @param[in] s a pointer to a pointer to Swr context
    pub fn swr_free(s: *mut *mut SwrContext);
}
extern "C" {
    /// Closes the context so that swr_is_initialized() returns 0.
    ///
    /// The context can be brought back to life by running swr_init(),
    /// swr_init() can also be used without swr_close().
    /// This function is mainly provided for simplifying the usecase
    /// where one tries to support libavresample and libswresample.
    ///
    /// @param[in,out] s Swr context to be closed
    pub fn swr_close(s: *mut SwrContext);
}
extern "C" {
    /// Convert audio.
    ///
    /// in and in_count can be set to 0 to flush the last few samples out at the
    /// end.
    ///
    /// If more input is provided than output space, then the input will be buffered.
    /// You can avoid this buffering by using swr_get_out_samples() to retrieve an
    /// upper bound on the required number of output samples for the given number of
    /// input samples. Conversion will run directly without copying whenever possible.
    ///
    /// @param s         allocated Swr context, with parameters set
    /// @param out       output buffers, only the first one need be set in case of packed audio
    /// @param out_count amount of space available for output in samples per channel
    /// @param in        input buffers, only the first one need to be set in case of packed audio
    /// @param in_count  number of input samples available in one channel
    ///
    /// @return number of samples output per channel, negative value on error
    pub fn swr_convert(
        s: *mut SwrContext,
        out: *mut *mut u8,
        out_count: libc::c_int,
        in_: *mut *const u8,
        in_count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Convert the next timestamp from input to output
    /// timestamps are in 1/(in_sample_rate * out_sample_rate) units.
    ///
    /// @note There are 2 slightly differently behaving modes.
    /// @li When automatic timestamp compensation is not used, (min_compensation >= FLT_MAX)
    /// in this case timestamps will be passed through with delays compensated
    /// @li When automatic timestamp compensation is used, (min_compensation < FLT_MAX)
    /// in this case the output timestamps will match output sample numbers.
    /// See ffmpeg-resampler(1) for the two modes of compensation.
    ///
    /// @param s[in]     initialized Swr context
    /// @param pts[in]   timestamp for the next input sample, INT64_MIN if unknown
    /// @see swr_set_compensation(), swr_drop_output(), and swr_inject_silence() are
    /// function used internally for timestamp compensation.
    /// @return the output timestamp for the next output sample
    pub fn swr_next_pts(s: *mut SwrContext, pts: i64) -> i64;
}
extern "C" {
    /// Activate resampling compensation ("soft" compensation). This function is
    /// internally called when needed in swr_next_pts().
    ///
    /// @param[in,out] s             allocated Swr context. If it is not initialized,
    /// or SWR_FLAG_RESAMPLE is not set, swr_init() is
    /// called with the flag set.
    /// @param[in]     sample_delta  delta in PTS per sample
    /// @param[in]     compensation_distance number of samples to compensate for
    /// @return    >= 0 on success, AVERROR error codes if:
    /// @li @c s is NULL,
    /// @li @c compensation_distance is less than 0,
    /// @li @c compensation_distance is 0 but sample_delta is not,
    /// @li compensation unsupported by resampler, or
    /// @li swr_init() fails when called.
    pub fn swr_set_compensation(
        s: *mut SwrContext,
        sample_delta: libc::c_int,
        compensation_distance: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Set a customized input channel mapping.
    ///
    /// @param[in,out] s           allocated Swr context, not yet initialized
    /// @param[in]     channel_map customized input channel mapping (array of channel
    /// indexes, -1 for a muted channel)
    /// @return >= 0 on success, or AVERROR error code in case of failure.
    pub fn swr_set_channel_mapping(
        s: *mut SwrContext,
        channel_map: *const libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Generate a channel mixing matrix.
    ///
    /// This function is the one used internally by libswresample for building the
    /// default mixing matrix. It is made public just as a utility function for
    /// building custom matrices.
    ///
    /// @param in_layout           input channel layout
    /// @param out_layout          output channel layout
    /// @param center_mix_level    mix level for the center channel
    /// @param surround_mix_level  mix level for the surround channel(s)
    /// @param lfe_mix_level       mix level for the low-frequency effects channel
    /// @param rematrix_maxval     if 1.0, coefficients will be normalized to prevent
    /// overflow. if INT_MAX, coefficients will not be
    /// normalized.
    /// @param[out] matrix         mixing coefficients; matrix[i + stride * o] is
    /// the weight of input channel i in output channel o.
    /// @param stride              distance between adjacent input channels in the
    /// matrix array
    /// @param matrix_encoding     matrixed stereo downmix mode (e.g. dplii)
    /// @param log_ctx             parent logging context, can be NULL
    /// @return                    0 on success, negative AVERROR code on failure
    pub fn swr_build_matrix(
        in_layout: u64,
        out_layout: u64,
        center_mix_level: f64,
        surround_mix_level: f64,
        lfe_mix_level: f64,
        rematrix_maxval: f64,
        rematrix_volume: f64,
        matrix: *mut f64,
        stride: libc::c_int,
        matrix_encoding: AVMatrixEncoding,
        log_ctx: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    /// Set a customized remix matrix.
    ///
    /// @param s       allocated Swr context, not yet initialized
    /// @param matrix  remix coefficients; matrix[i + stride * o] is
    /// the weight of input channel i in output channel o
    /// @param stride  offset between lines of the matrix
    /// @return  >= 0 on success, or AVERROR error code in case of failure.
    pub fn swr_set_matrix(
        s: *mut SwrContext,
        matrix: *const f64,
        stride: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Drops the specified number of output samples.
    ///
    /// This function, along with swr_inject_silence(), is called by swr_next_pts()
    /// if needed for "hard" compensation.
    ///
    /// @param s     allocated Swr context
    /// @param count number of samples to be dropped
    ///
    /// @return >= 0 on success, or a negative AVERROR code on failure
    pub fn swr_drop_output(s: *mut SwrContext, count: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// Injects the specified number of silence samples.
    ///
    /// This function, along with swr_drop_output(), is called by swr_next_pts()
    /// if needed for "hard" compensation.
    ///
    /// @param s     allocated Swr context
    /// @param count number of samples to be dropped
    ///
    /// @return >= 0 on success, or a negative AVERROR code on failure
    pub fn swr_inject_silence(s: *mut SwrContext, count: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// Gets the delay the next input sample will experience relative to the next output sample.
    ///
    /// Swresample can buffer data if more input has been provided than available
    /// output space, also converting between sample rates needs a delay.
    /// This function returns the sum of all such delays.
    /// The exact delay is not necessarily an integer value in either input or
    /// output sample rate. Especially when downsampling by a large value, the
    /// output sample rate may be a poor choice to represent the delay, similarly
    /// for upsampling and the input sample rate.
    ///
    /// @param s     swr context
    /// @param base  timebase in which the returned delay will be:
    /// @li if it's set to 1 the returned delay is in seconds
    /// @li if it's set to 1000 the returned delay is in milliseconds
    /// @li if it's set to the input sample rate then the returned
    /// delay is in input samples
    /// @li if it's set to the output sample rate then the returned
    /// delay is in output samples
    /// @li if it's the least common multiple of in_sample_rate and
    /// out_sample_rate then an exact rounding-free delay will be
    /// returned
    /// @returns     the delay in 1 / @c base units.
    pub fn swr_get_delay(s: *mut SwrContext, base: i64) -> i64;
}
extern "C" {
    /// Find an upper bound on the number of samples that the next swr_convert
    /// call will output, if called with in_samples of input samples. This
    /// depends on the internal state, and anything changing the internal state
    /// (like further swr_convert() calls) will may change the number of samples
    /// swr_get_out_samples() returns for the same number of input samples.
    ///
    /// @param in_samples    number of input samples.
    /// @note any call to swr_inject_silence(), swr_convert(), swr_next_pts()
    /// or swr_set_compensation() invalidates this limit
    /// @note it is recommended to pass the correct available buffer size
    /// to all functions like swr_convert() even if swr_get_out_samples()
    /// indicates that less would be used.
    /// @returns an upper bound on the number of samples that the next swr_convert
    /// will output or a negative value to indicate an error
    pub fn swr_get_out_samples(s: *mut SwrContext, in_samples: libc::c_int) -> libc::c_int;
}
extern "C" {
    /// Return the @ref LIBSWRESAMPLE_VERSION_INT constant.
    ///
    /// This is useful to check if the build-time libswresample has the same version
    /// as the run-time one.
    ///
    /// @returns     the unsigned int-typed version
    pub fn swresample_version() -> libc::c_uint;
}
extern "C" {
    /// Return the swr build-time configuration.
    ///
    /// @returns     the build-time @c ./configure flags
    pub fn swresample_configuration() -> *const libc::c_char;
}
extern "C" {
    /// Return the swr license.
    ///
    /// @returns     the license of libswresample, determined at build-time
    pub fn swresample_license() -> *const libc::c_char;
}
extern "C" {
    /// Convert the samples in the input AVFrame and write them to the output AVFrame.
    ///
    /// Input and output AVFrames must have channel_layout, sample_rate and format set.
    ///
    /// If the output AVFrame does not have the data pointers allocated the nb_samples
    /// field will be set using av_frame_get_buffer()
    /// is called to allocate the frame.
    ///
    /// The output AVFrame can be NULL or have fewer allocated samples than required.
    /// In this case, any remaining samples not written to the output will be added
    /// to an internal FIFO buffer, to be returned at the next call to this function
    /// or to swr_convert().
    ///
    /// If converting sample rate, there may be data remaining in the internal
    /// resampling delay buffer. swr_get_delay() tells the number of
    /// remaining samples. To get this data as output, call this function or
    /// swr_convert() with NULL input.
    ///
    /// If the SwrContext configuration does not match the output and
    /// input AVFrame settings the conversion does not take place and depending on
    /// which AVFrame is not matching AVERROR_OUTPUT_CHANGED, AVERROR_INPUT_CHANGED
    /// or the result of a bitwise-OR of them is returned.
    ///
    /// @see swr_delay()
    /// @see swr_convert()
    /// @see swr_get_delay()
    ///
    /// @param swr             audio resample context
    /// @param output          output AVFrame
    /// @param input           input AVFrame
    /// @return                0 on success, AVERROR on failure or nonmatching
    /// configuration.
    pub fn swr_convert_frame(
        swr: *mut SwrContext,
        output: *mut AVFrame,
        input: *const AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    /// Configure or reconfigure the SwrContext using the information
    /// provided by the AVFrames.
    ///
    /// The original resampling context is reset even on failure.
    /// The function calls swr_close() internally if the context is open.
    ///
    /// @see swr_close();
    ///
    /// @param swr             audio resample context
    /// @param output          output AVFrame
    /// @param input           input AVFrame
    /// @return                0 on success, AVERROR on failure.
    pub fn swr_config_frame(
        swr: *mut SwrContext,
        out: *const AVFrame,
        in_: *const AVFrame,
    ) -> libc::c_int;
}
extern "C" {
    /// @defgroup libsws libswscale
    /// Color conversion and scaling library.
    ///
    /// @{
    ///
    /// Return the LIBSWSCALE_VERSION_INT constant.
    pub fn swscale_version() -> libc::c_uint;
}
extern "C" {
    /// Return the libswscale build-time configuration.
    pub fn swscale_configuration() -> *const libc::c_char;
}
extern "C" {
    /// Return the libswscale license.
    pub fn swscale_license() -> *const libc::c_char;
}
extern "C" {
    /// Return a pointer to yuv<->rgb coefficients for the given colorspace
    /// suitable for sws_setColorspaceDetails().
    ///
    /// @param colorspace One of the SWS_CS_* macros. If invalid,
    /// SWS_CS_DEFAULT is used.
    pub fn sws_getCoefficients(colorspace: libc::c_int) -> *const libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SwsVector {
    /// < pointer to the list of coefficients
    pub coeff: *mut f64,
    /// < number of coefficients in the vector
    pub length: libc::c_int,
}
#[test]
fn bindgen_test_layout_SwsVector() {
    assert_eq!(
        ::std::mem::size_of::<SwsVector>(),
        16usize,
        concat!("Size of: ", stringify!(SwsVector))
    );
    assert_eq!(
        ::std::mem::align_of::<SwsVector>(),
        8usize,
        concat!("Alignment of ", stringify!(SwsVector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwsVector>())).coeff as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsVector),
            "::",
            stringify!(coeff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwsVector>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsVector),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SwsFilter {
    pub lumH: *mut SwsVector,
    pub lumV: *mut SwsVector,
    pub chrH: *mut SwsVector,
    pub chrV: *mut SwsVector,
}
#[test]
fn bindgen_test_layout_SwsFilter() {
    assert_eq!(
        ::std::mem::size_of::<SwsFilter>(),
        32usize,
        concat!("Size of: ", stringify!(SwsFilter))
    );
    assert_eq!(
        ::std::mem::align_of::<SwsFilter>(),
        8usize,
        concat!("Alignment of ", stringify!(SwsFilter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwsFilter>())).lumH as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(lumH)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwsFilter>())).lumV as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(lumV)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwsFilter>())).chrH as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(chrH)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SwsFilter>())).chrV as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SwsFilter),
            "::",
            stringify!(chrV)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SwsContext {
    _unused: [u8; 0],
}
extern "C" {
    /// Return a positive value if pix_fmt is a supported input format, 0
    /// otherwise.
    pub fn sws_isSupportedInput(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    /// Return a positive value if pix_fmt is a supported output format, 0
    /// otherwise.
    pub fn sws_isSupportedOutput(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    /// @param[in]  pix_fmt the pixel format
    /// @return a positive value if an endianness conversion for pix_fmt is
    /// supported, 0 otherwise.
    pub fn sws_isSupportedEndiannessConversion(pix_fmt: AVPixelFormat) -> libc::c_int;
}
extern "C" {
    /// Allocate an empty SwsContext. This must be filled and passed to
    /// sws_init_context(). For filling see AVOptions, options.c and
    /// sws_setColorspaceDetails().
    pub fn sws_alloc_context() -> *mut SwsContext;
}
extern "C" {
    /// Initialize the swscaler context sws_context.
    ///
    /// @return zero or positive value on success, a negative value on
    /// error
    pub fn sws_init_context(
        sws_context: *mut SwsContext,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
    ) -> libc::c_int;
}
extern "C" {
    /// Free the swscaler context swsContext.
    /// If swsContext is NULL, then does nothing.
    pub fn sws_freeContext(swsContext: *mut SwsContext);
}
extern "C" {
    /// Allocate and return an SwsContext. You need it to perform
    /// scaling/conversion operations using sws_scale().
    ///
    /// @param srcW the width of the source image
    /// @param srcH the height of the source image
    /// @param srcFormat the source image format
    /// @param dstW the width of the destination image
    /// @param dstH the height of the destination image
    /// @param dstFormat the destination image format
    /// @param flags specify which algorithm and options to use for rescaling
    /// @param param extra parameters to tune the used scaler
    /// For SWS_BICUBIC param[0] and [1] tune the shape of the basis
    /// function, param[0] tunes f(1) and param[1] f´(1)
    /// For SWS_GAUSS param[0] tunes the exponent and thus cutoff
    /// frequency
    /// For SWS_LANCZOS param[0] tunes the width of the window function
    /// @return a pointer to an allocated context, or NULL in case of error
    /// @note this function is to be removed after a saner alternative is
    /// written
    pub fn sws_getContext(
        srcW: libc::c_int,
        srcH: libc::c_int,
        srcFormat: AVPixelFormat,
        dstW: libc::c_int,
        dstH: libc::c_int,
        dstFormat: AVPixelFormat,
        flags: libc::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    /// Scale the image slice in srcSlice and put the resulting scaled
    /// slice in the image in dst. A slice is a sequence of consecutive
    /// rows in an image.
    ///
    /// Slices have to be provided in sequential order, either in
    /// top-bottom or bottom-top order. If slices are provided in
    /// non-sequential order the behavior of the function is undefined.
    ///
    /// @param c         the scaling context previously created with
    /// sws_getContext()
    /// @param srcSlice  the array containing the pointers to the planes of
    /// the source slice
    /// @param srcStride the array containing the strides for each plane of
    /// the source image
    /// @param srcSliceY the position in the source image of the slice to
    /// process, that is the number (counted starting from
    /// zero) in the image of the first row of the slice
    /// @param srcSliceH the height of the source slice, that is the number
    /// of rows in the slice
    /// @param dst       the array containing the pointers to the planes of
    /// the destination image
    /// @param dstStride the array containing the strides for each plane of
    /// the destination image
    /// @return          the height of the output slice
    pub fn sws_scale(
        c: *mut SwsContext,
        srcSlice: *const *const u8,
        srcStride: *const libc::c_int,
        srcSliceY: libc::c_int,
        srcSliceH: libc::c_int,
        dst: *const *const u8,
        dstStride: *const libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @param dstRange flag indicating the while-black range of the output (1=jpeg / 0=mpeg)
    /// @param srcRange flag indicating the while-black range of the input (1=jpeg / 0=mpeg)
    /// @param table the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]
    /// @param inv_table the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]
    /// @param brightness 16.16 fixed point brightness correction
    /// @param contrast 16.16 fixed point contrast correction
    /// @param saturation 16.16 fixed point saturation correction
    /// @return -1 if not supported
    pub fn sws_setColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *const libc::c_int,
        srcRange: libc::c_int,
        table: *const libc::c_int,
        dstRange: libc::c_int,
        brightness: libc::c_int,
        contrast: libc::c_int,
        saturation: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// @return -1 if not supported
    pub fn sws_getColorspaceDetails(
        c: *mut SwsContext,
        inv_table: *mut *mut libc::c_int,
        srcRange: *mut libc::c_int,
        table: *mut *mut libc::c_int,
        dstRange: *mut libc::c_int,
        brightness: *mut libc::c_int,
        contrast: *mut libc::c_int,
        saturation: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    /// Allocate and return an uninitialized vector with length coefficients.
    pub fn sws_allocVec(length: libc::c_int) -> *mut SwsVector;
}
extern "C" {
    /// Return a normalized Gaussian curve used to filter stuff
    /// quality = 3 is high quality, lower is lower quality.
    pub fn sws_getGaussianVec(variance: f64, quality: f64) -> *mut SwsVector;
}
extern "C" {
    /// Scale all the coefficients of a by the scalar value.
    pub fn sws_scaleVec(a: *mut SwsVector, scalar: f64);
}
extern "C" {
    /// Scale all the coefficients of a so that their sum equals height.
    pub fn sws_normalizeVec(a: *mut SwsVector, height: f64);
}
extern "C" {
    pub fn sws_getConstVec(c: f64, length: libc::c_int) -> *mut SwsVector;
}
extern "C" {
    pub fn sws_getIdentityVec() -> *mut SwsVector;
}
extern "C" {
    pub fn sws_convVec(a: *mut SwsVector, b: *mut SwsVector);
}
extern "C" {
    pub fn sws_addVec(a: *mut SwsVector, b: *mut SwsVector);
}
extern "C" {
    pub fn sws_subVec(a: *mut SwsVector, b: *mut SwsVector);
}
extern "C" {
    pub fn sws_shiftVec(a: *mut SwsVector, shift: libc::c_int);
}
extern "C" {
    pub fn sws_cloneVec(a: *mut SwsVector) -> *mut SwsVector;
}
extern "C" {
    pub fn sws_printVec2(a: *mut SwsVector, log_ctx: *mut AVClass, log_level: libc::c_int);
}
extern "C" {
    pub fn sws_freeVec(a: *mut SwsVector);
}
extern "C" {
    pub fn sws_getDefaultFilter(
        lumaGBlur: f32,
        chromaGBlur: f32,
        lumaSharpen: f32,
        chromaSharpen: f32,
        chromaHShift: f32,
        chromaVShift: f32,
        verbose: libc::c_int,
    ) -> *mut SwsFilter;
}
extern "C" {
    pub fn sws_freeFilter(filter: *mut SwsFilter);
}
extern "C" {
    /// Check if context can be reused, otherwise reallocate a new one.
    ///
    /// If context is NULL, just calls sws_getContext() to get a new
    /// context. Otherwise, checks if the parameters are the ones already
    /// saved in context. If that is the case, returns the current
    /// context. Otherwise, frees context and gets a new context with
    /// the new parameters.
    ///
    /// Be warned that srcFilter and dstFilter are not checked, they
    /// are assumed to remain the same.
    pub fn sws_getCachedContext(
        context: *mut SwsContext,
        srcW: libc::c_int,
        srcH: libc::c_int,
        srcFormat: AVPixelFormat,
        dstW: libc::c_int,
        dstH: libc::c_int,
        dstFormat: AVPixelFormat,
        flags: libc::c_int,
        srcFilter: *mut SwsFilter,
        dstFilter: *mut SwsFilter,
        param: *const f64,
    ) -> *mut SwsContext;
}
extern "C" {
    /// Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.
    ///
    /// The output frame will have the same packed format as the palette.
    ///
    /// @param src        source frame buffer
    /// @param dst        destination frame buffer
    /// @param num_pixels number of pixels to convert
    /// @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
    pub fn sws_convertPalette8ToPacked32(
        src: *const u8,
        dst: *mut u8,
        num_pixels: libc::c_int,
        palette: *const u8,
    );
}
extern "C" {
    /// Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.
    ///
    /// With the palette format "ABCD", the destination frame ends up with the format "ABC".
    ///
    /// @param src        source frame buffer
    /// @param dst        destination frame buffer
    /// @param num_pixels number of pixels to convert
    /// @param palette    array with [256] entries, which must match color arrangement (RGB or BGR) of src
    pub fn sws_convertPalette8ToPacked24(
        src: *const u8,
        dst: *mut u8,
        num_pixels: libc::c_int,
        palette: *const u8,
    );
}
extern "C" {
    /// Get the AVClass for swsContext. It can be used in combination with
    /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
    ///
    /// @see av_opt_find().
    pub fn sws_get_class() -> *const AVClass;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct URLContext {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct FFFrac {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFilterCommand {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct AVFilterChannelLayouts {
    pub _address: u8,
}
